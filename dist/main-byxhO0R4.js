var jg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qg(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var xf = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
 */
(function(x, d) {
  (function(p, v) {
    x.exports = v();
  })(jg, function() {
    var p = {}, v = {};
    function S(_, c, C) {
      if (v[_] = C, _ === "index") {
        var N = "var sharedModule = {}; (" + v.shared + ")(sharedModule); (" + v.worker + ")(sharedModule);", q = {};
        return v.shared(q), v.index(p, q), typeof window < "u" && p.setWorkerUrl(window.URL.createObjectURL(new Blob([N], { type: "text/javascript" }))), p;
      }
    }
    S("shared", ["exports"], function(_) {
      function c(i, t, n, o) {
        return new (n || (n = Promise))(function(u, f) {
          function g(E) {
            try {
              L(o.next(E));
            } catch (D) {
              f(D);
            }
          }
          function P(E) {
            try {
              L(o.throw(E));
            } catch (D) {
              f(D);
            }
          }
          function L(E) {
            var D;
            E.done ? u(E.value) : (D = E.value, D instanceof n ? D : new n(function(R) {
              R(D);
            })).then(g, P);
          }
          L((o = o.apply(i, t || [])).next());
        });
      }
      function C(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var N = q;
      function q(i, t) {
        this.x = i, this.y = t;
      }
      q.prototype = { clone: function() {
        return new q(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, t) {
        return this.clone()._rotateAround(i, t);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var t = i.x - this.x, n = i.y - this.y;
        return t * t + n * n;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, t) {
        return Math.atan2(this.x * t - this.y * i, this.x * i + this.y * t);
      }, _matMult: function(i) {
        var t = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = t, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var t = Math.cos(i), n = Math.sin(i), o = n * this.x + t * this.y;
        return this.x = t * this.x - n * this.y, this.y = o, this;
      }, _rotateAround: function(i, t) {
        var n = Math.cos(i), o = Math.sin(i), u = t.y + o * (this.x - t.x) + n * (this.y - t.y);
        return this.x = t.x + n * (this.x - t.x) - o * (this.y - t.y), this.y = u, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, q.convert = function(i) {
        return i instanceof q ? i : Array.isArray(i) ? new q(i[0], i[1]) : i;
      };
      var j = C(N), V = F;
      function F(i, t, n, o) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (o - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = o;
      }
      F.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, o = 0; o < 8; o++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < t) return n;
          var f = this.sampleCurveDerivativeX(n);
          if (Math.abs(f) < 1e-6) break;
          n -= u / f;
        }
        var g = 0, P = 1;
        for (n = i, o = 0; o < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < t)); o++) i > u ? g = n : P = n, n = 0.5 * (P - g) + g;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var de = C(V);
      let ae, ye;
      function se() {
        return ae == null && (ae = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ae;
      }
      function ge() {
        if (ye == null && (ye = !1, se())) {
          const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (t) {
            for (let o = 0; o < 5 * 5; o++) {
              const u = 4 * o;
              t.fillStyle = `rgb(${u},${u + 1},${u + 2})`, t.fillRect(o % 5, Math.floor(o / 5), 1, 1);
            }
            const n = t.getImageData(0, 0, 5, 5).data;
            for (let o = 0; o < 5 * 5 * 4; o++) if (o % 4 != 3 && n[o] !== o) {
              ye = !0;
              break;
            }
          }
        }
        return ye || !1;
      }
      function Me(i, t, n, o) {
        const u = new de(i, t, n, o);
        return (f) => u.solve(f);
      }
      const Ye = Me(0.25, 0.1, 0.25, 1);
      function $e(i, t, n) {
        return Math.min(n, Math.max(t, i));
      }
      function tt(i, t, n) {
        const o = n - t, u = ((i - t) % o + o) % o + t;
        return u === t ? n : u;
      }
      function Be(i, ...t) {
        for (const n of t) for (const o in n) i[o] = n[o];
        return i;
      }
      let Ie = 1;
      function ot(i, t, n) {
        const o = {};
        for (const u in i) o[u] = t.call(this, i[u], u, i);
        return o;
      }
      function it(i, t, n) {
        const o = {};
        for (const u in i) t.call(this, i[u], u, i) && (o[u] = i[u]);
        return o;
      }
      function oe(i) {
        return Array.isArray(i) ? i.map(oe) : typeof i == "object" && i ? ot(i, oe) : i;
      }
      const le = {};
      function Le(i) {
        le[i] || (typeof console < "u" && console.warn(i), le[i] = !0);
      }
      function Se(i, t, n) {
        return (n.y - i.y) * (t.x - i.x) > (t.y - i.y) * (n.x - i.x);
      }
      function He(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let We = null;
      function Je(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const je = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function rt(i, t, n, o, u) {
        return c(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const f = new VideoFrame(i, { timestamp: 0 });
          try {
            const g = f == null ? void 0 : f.format;
            if (!g || !g.startsWith("BGR") && !g.startsWith("RGB")) throw new Error(`Unrecognized format ${g}`);
            const P = g.startsWith("BGR"), L = new Uint8ClampedArray(o * u * 4);
            if (yield f.copyTo(L, function(E, D, R, Z, H) {
              const K = 4 * Math.max(-D, 0), re = (Math.max(0, R) - R) * Z * 4 + K, pe = 4 * Z, xe = Math.max(0, D), Ne = Math.max(0, R);
              return { rect: { x: xe, y: Ne, width: Math.min(E.width, D + Z) - xe, height: Math.min(E.height, R + H) - Ne }, layout: [{ offset: re, stride: pe }] };
            }(i, t, n, o, u)), P) for (let E = 0; E < L.length; E += 4) {
              const D = L[E];
              L[E] = L[E + 2], L[E + 2] = D;
            }
            return L;
          } finally {
            f.close();
          }
        });
      }
      let Ke, St;
      const J = "AbortError";
      function fe() {
        return new Error(J);
      }
      const _e = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Ce(i) {
        return _e.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const De = "global-dispatcher";
      class Oe extends Error {
        constructor(t, n, o, u) {
          super(`AJAXError: ${n} (${t}): ${o}`), this.status = t, this.statusText = n, this.url = o, this.body = u;
        }
      }
      const qe = () => He(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Ze = function(i, t) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const o = Ce(i.url);
          if (o) return o(i, t);
          if (He(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: De }, t);
        }
        if (!(/^file:/.test(n = i.url) || /^file:/.test(qe()) && !/^\w+:/.test(n))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(o, u) {
            return c(this, void 0, void 0, function* () {
              const f = new Request(o.url, { method: o.method || "GET", body: o.body, credentials: o.credentials, headers: o.headers, cache: o.cache, referrer: qe(), signal: u.signal });
              o.type !== "json" || f.headers.has("Accept") || f.headers.set("Accept", "application/json");
              const g = yield fetch(f);
              if (!g.ok) {
                const E = yield g.blob();
                throw new Oe(g.status, g.statusText, o.url, E);
              }
              let P;
              P = o.type === "arrayBuffer" || o.type === "image" ? g.arrayBuffer() : o.type === "json" ? g.json() : g.text();
              const L = yield P;
              if (u.signal.aborted) throw fe();
              return { data: L, cacheControl: g.headers.get("Cache-Control"), expires: g.headers.get("Expires") };
            });
          }(i, t);
          if (He(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: De }, t);
        }
        var n;
        return function(o, u) {
          return new Promise((f, g) => {
            var P;
            const L = new XMLHttpRequest();
            L.open(o.method || "GET", o.url, !0), o.type !== "arrayBuffer" && o.type !== "image" || (L.responseType = "arraybuffer");
            for (const E in o.headers) L.setRequestHeader(E, o.headers[E]);
            o.type === "json" && (L.responseType = "text", !((P = o.headers) === null || P === void 0) && P.Accept || L.setRequestHeader("Accept", "application/json")), L.withCredentials = o.credentials === "include", L.onerror = () => {
              g(new Error(L.statusText));
            }, L.onload = () => {
              if (!u.signal.aborted) if ((L.status >= 200 && L.status < 300 || L.status === 0) && L.response !== null) {
                let E = L.response;
                if (o.type === "json") try {
                  E = JSON.parse(L.response);
                } catch (D) {
                  return void g(D);
                }
                f({ data: E, cacheControl: L.getResponseHeader("Cache-Control"), expires: L.getResponseHeader("Expires") });
              } else {
                const E = new Blob([L.response], { type: L.getResponseHeader("Content-Type") });
                g(new Oe(L.status, L.statusText, o.url, E));
              }
            }, u.signal.addEventListener("abort", () => {
              L.abort(), g(fe());
            }), L.send(o.body);
          });
        }(i, t);
      };
      function wt(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const t = new URL(i), n = window.location;
        return t.protocol === n.protocol && t.host === n.host;
      }
      function bt(i, t, n) {
        n[i] && n[i].indexOf(t) !== -1 || (n[i] = n[i] || [], n[i].push(t));
      }
      function Tt(i, t, n) {
        if (n && n[i]) {
          const o = n[i].indexOf(t);
          o !== -1 && n[i].splice(o, 1);
        }
      }
      class Mt {
        constructor(t, n = {}) {
          Be(this, n), this.type = t;
        }
      }
      class Qt extends Mt {
        constructor(t, n = {}) {
          super("error", Be({ error: t }, n));
        }
      }
      class Qe {
        on(t, n) {
          return this._listeners = this._listeners || {}, bt(t, n, this._listeners), this;
        }
        off(t, n) {
          return Tt(t, n, this._listeners), Tt(t, n, this._oneTimeListeners), this;
        }
        once(t, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, bt(t, n, this._oneTimeListeners), this) : new Promise((o) => this.once(t, o));
        }
        fire(t, n) {
          typeof t == "string" && (t = new Mt(t, n || {}));
          const o = t.type;
          if (this.listens(o)) {
            t.target = this;
            const u = this._listeners && this._listeners[o] ? this._listeners[o].slice() : [];
            for (const P of u) P.call(this, t);
            const f = this._oneTimeListeners && this._oneTimeListeners[o] ? this._oneTimeListeners[o].slice() : [];
            for (const P of f) Tt(o, P, this._oneTimeListeners), P.call(this, t);
            const g = this._eventedParent;
            g && (Be(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), g.fire(t));
          } else t instanceof Qt && console.error(t.error);
          return this;
        }
        listens(t) {
          return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
        }
        setEventedParent(t, n) {
          return this._eventedParent = t, this._eventedParentData = n, this;
        }
      }
      var Y = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const ui = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function $t(i, t) {
        const n = {};
        for (const o in i) o !== "ref" && (n[o] = i[o]);
        return ui.forEach((o) => {
          o in t && (n[o] = t[o]);
        }), n;
      }
      function at(i, t) {
        if (Array.isArray(i)) {
          if (!Array.isArray(t) || i.length !== t.length) return !1;
          for (let n = 0; n < i.length; n++) if (!at(i[n], t[n])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && t !== null) {
          if (typeof t != "object" || Object.keys(i).length !== Object.keys(t).length) return !1;
          for (const n in i) if (!at(i[n], t[n])) return !1;
          return !0;
        }
        return i === t;
      }
      function yt(i, t) {
        i.push(t);
      }
      function zt(i, t, n) {
        yt(n, { command: "addSource", args: [i, t[i]] });
      }
      function Pt(i, t, n) {
        yt(t, { command: "removeSource", args: [i] }), n[i] = !0;
      }
      function Gt(i, t, n, o) {
        Pt(i, n, o), zt(i, t, n);
      }
      function di(i, t, n) {
        let o;
        for (o in i[n]) if (Object.prototype.hasOwnProperty.call(i[n], o) && o !== "data" && !at(i[n][o], t[n][o])) return !1;
        for (o in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], o) && o !== "data" && !at(i[n][o], t[n][o])) return !1;
        return !0;
      }
      function oi(i, t, n, o, u, f) {
        i = i || {}, t = t || {};
        for (const g in i) Object.prototype.hasOwnProperty.call(i, g) && (at(i[g], t[g]) || n.push({ command: f, args: [o, g, t[g], u] }));
        for (const g in t) Object.prototype.hasOwnProperty.call(t, g) && !Object.prototype.hasOwnProperty.call(i, g) && (at(i[g], t[g]) || n.push({ command: f, args: [o, g, t[g], u] }));
      }
      function bi(i) {
        return i.id;
      }
      function Ci(i, t) {
        return i[t.id] = t, i;
      }
      class lt {
        constructor(t, n, o, u) {
          this.message = (t ? `${t}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function ei(i, ...t) {
        for (const n of t) for (const o in n) i[o] = n[o];
        return i;
      }
      class ai extends Error {
        constructor(t, n) {
          super(n), this.message = n, this.key = t;
        }
      }
      class It {
        constructor(t, n = []) {
          this.parent = t, this.bindings = {};
          for (const [o, u] of n) this.bindings[o] = u;
        }
        concat(t) {
          return new It(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || !!this.parent && this.parent.has(t);
        }
      }
      const cr = { kind: "null" }, ct = { kind: "number" }, si = { kind: "string" }, kt = { kind: "boolean" }, Ei = { kind: "color" }, Pr = { kind: "object" }, Et = { kind: "value" }, $r = { kind: "collator" }, qi = { kind: "formatted" }, Cr = { kind: "padding" }, Er = { kind: "resolvedImage" }, ue = { kind: "variableAnchorOffsetCollection" };
      function $(i, t) {
        return { kind: "array", itemType: i, N: t };
      }
      function W(i) {
        if (i.kind === "array") {
          const t = W(i.itemType);
          return typeof i.N == "number" ? `array<${t}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${t}>`;
        }
        return i.kind;
      }
      const te = [cr, ct, si, kt, Ei, qi, Pr, $(Et), Cr, Er, ue];
      function ce(i, t) {
        if (t.kind === "error") return null;
        if (i.kind === "array") {
          if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ce(i.itemType, t.itemType)) && (typeof i.N != "number" || i.N === t.N)) return null;
        } else {
          if (i.kind === t.kind) return null;
          if (i.kind === "value") {
            for (const n of te) if (!ce(n, t)) return null;
          }
        }
        return `Expected ${W(i)} but found ${W(t)} instead.`;
      }
      function Pe(i, t) {
        return t.some((n) => n.kind === i.kind);
      }
      function Ee(i, t) {
        return t.some((n) => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i);
      }
      function Ae(i, t) {
        return i.kind === "array" && t.kind === "array" ? i.itemType.kind === t.itemType.kind && typeof i.N == "number" : i.kind === t.kind;
      }
      const be = 0.96422, Ve = 0.82521, et = 4 / 29, Re = 6 / 29, mt = 3 * Re * Re, Dt = Re * Re * Re, Zt = Math.PI / 180, vi = 180 / Math.PI;
      function Jt(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function gi([i, t, n, o]) {
        let u, f;
        const g = Ui((0.2225045 * (i = pi(i)) + 0.7168786 * (t = pi(t)) + 0.0606169 * (n = pi(n))) / 1);
        i === t && t === n ? u = f = g : (u = Ui((0.4360747 * i + 0.3850649 * t + 0.1430804 * n) / be), f = Ui((0.0139322 * i + 0.0971045 * t + 0.7141733 * n) / Ve));
        const P = 116 * g - 16;
        return [P < 0 ? 0 : P, 500 * (u - g), 200 * (g - f), o];
      }
      function pi(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Ui(i) {
        return i > Dt ? Math.pow(i, 1 / 3) : i / mt + et;
      }
      function Fi([i, t, n, o]) {
        let u = (i + 16) / 116, f = isNaN(t) ? u : u + t / 500, g = isNaN(n) ? u : u - n / 200;
        return u = 1 * Di(u), f = be * Di(f), g = Ve * Di(g), [li(3.1338561 * f - 1.6168667 * u - 0.4906146 * g), li(-0.9787684 * f + 1.9161415 * u + 0.033454 * g), li(0.0719453 * f - 0.2289914 * u + 1.4052427 * g), o];
      }
      function li(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function Di(i) {
        return i > Re ? i * i * i : mt * (i - et);
      }
      function Vi(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function hr(i, t) {
        return fr(t ? i / 100 : i, 0, 1);
      }
      function fr(i, t, n) {
        return Math.min(Math.max(t, i), n);
      }
      function Ir(i) {
        return !i.some(Number.isNaN);
      }
      const Ns = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Ri {
        constructor(t, n, o, u = 1, f = !0) {
          this.r = t, this.g = n, this.b = o, this.a = u, f || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [t, n, o, u]));
        }
        static parse(t) {
          if (t instanceof Ri) return t;
          if (typeof t != "string") return;
          const n = function(o) {
            if ((o = o.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const u = Ns[o];
            if (u) {
              const [g, P, L] = u;
              return [g / 255, P / 255, L / 255, 1];
            }
            if (o.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(o)) {
              const g = o.length < 6 ? 1 : 2;
              let P = 1;
              return [Vi(o.slice(P, P += g)), Vi(o.slice(P, P += g)), Vi(o.slice(P, P += g)), Vi(o.slice(P, P + g) || "ff")];
            }
            if (o.startsWith("rgb")) {
              const g = o.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (g) {
                const [P, L, E, D, R, Z, H, K, re, pe, xe, Ne] = g, Te = [D || " ", H || " ", pe].join("");
                if (Te === "  " || Te === "  /" || Te === ",," || Te === ",,,") {
                  const ze = [E, Z, re].join(""), Ge = ze === "%%%" ? 100 : ze === "" ? 255 : 0;
                  if (Ge) {
                    const gt = [fr(+L / Ge, 0, 1), fr(+R / Ge, 0, 1), fr(+K / Ge, 0, 1), xe ? hr(+xe, Ne) : 1];
                    if (Ir(gt)) return gt;
                  }
                }
                return;
              }
            }
            const f = o.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (f) {
              const [g, P, L, E, D, R, Z, H, K] = f, re = [L || " ", D || " ", Z].join("");
              if (re === "  " || re === "  /" || re === ",," || re === ",,,") {
                const pe = [+P, fr(+E, 0, 100), fr(+R, 0, 100), H ? hr(+H, K) : 1];
                if (Ir(pe)) return function([xe, Ne, Te, ze]) {
                  function Ge(gt) {
                    const Ct = (gt + xe / 30) % 12, ri = Ne * Math.min(Te, 1 - Te);
                    return Te - ri * Math.max(-1, Math.min(Ct - 3, 9 - Ct, 1));
                  }
                  return xe = Jt(xe), Ne /= 100, Te /= 100, [Ge(0), Ge(8), Ge(4), ze];
                }(pe);
              }
            }
          }(t);
          return n ? new Ri(...n, !1) : void 0;
        }
        get rgb() {
          const { r: t, g: n, b: o, a: u } = this, f = u || 1 / 0;
          return this.overwriteGetter("rgb", [t / f, n / f, o / f, u]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t) {
            const [n, o, u, f] = gi(t), g = Math.sqrt(o * o + u * u);
            return [Math.round(1e4 * g) ? Jt(Math.atan2(u, o) * vi) : NaN, g, n, f];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", gi(this.rgb));
        }
        overwriteGetter(t, n) {
          return Object.defineProperty(this, t, { value: n }), n;
        }
        toString() {
          const [t, n, o, u] = this.rgb;
          return `rgba(${[t, n, o].map((f) => Math.round(255 * f)).join(",")},${u})`;
        }
      }
      Ri.black = new Ri(0, 0, 0, 1), Ri.white = new Ri(1, 1, 1, 1), Ri.transparent = new Ri(0, 0, 0, 0), Ri.red = new Ri(1, 0, 0, 1);
      class Na {
        constructor(t, n, o) {
          this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t, n) {
          return this.collator.compare(t, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class eo {
        constructor(t, n, o, u, f) {
          this.text = t, this.image = n, this.scale = o, this.fontStack = u, this.textColor = f;
        }
      }
      class Zr {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new Zr([new eo(t, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0);
        }
        static factory(t) {
          return t instanceof Zr ? t : Zr.fromString(t);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t) => t.text).join("");
        }
      }
      class nn {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof nn) return t;
          if (typeof t == "number") return new nn([t, t, t, t]);
          if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
            for (const n of t) if (typeof n != "number") return;
            switch (t.length) {
              case 1:
                t = [t[0], t[0], t[0], t[0]];
                break;
              case 2:
                t = [t[0], t[1], t[0], t[1]];
                break;
              case 3:
                t = [t[0], t[1], t[2], t[1]];
            }
            return new nn(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Fa = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class pn {
        constructor(t) {
          this.values = t.slice();
        }
        static parse(t) {
          if (t instanceof pn) return t;
          if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
            for (let n = 0; n < t.length; n += 2) {
              const o = t[n], u = t[n + 1];
              if (typeof o != "string" || !Fa.has(o) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return;
            }
            return new pn(t);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Gr {
        constructor(t) {
          this.name = t.name, this.available = t.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t) {
          return t ? new Gr({ name: t, available: !1 }) : null;
        }
      }
      function to(i, t, n, o) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[i, t, n, o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o == "number" ? [i, t, n, o] : [i, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Dn(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof Ri || i instanceof Na || i instanceof Zr || i instanceof nn || i instanceof pn || i instanceof Gr) return !0;
        if (Array.isArray(i)) {
          for (const t of i) if (!Dn(t)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const t in i) if (!Dn(i[t])) return !1;
          return !0;
        }
        return !1;
      }
      function mr(i) {
        if (i === null) return cr;
        if (typeof i == "string") return si;
        if (typeof i == "boolean") return kt;
        if (typeof i == "number") return ct;
        if (i instanceof Ri) return Ei;
        if (i instanceof Na) return $r;
        if (i instanceof Zr) return qi;
        if (i instanceof nn) return Cr;
        if (i instanceof pn) return ue;
        if (i instanceof Gr) return Er;
        if (Array.isArray(i)) {
          const t = i.length;
          let n;
          for (const o of i) {
            const u = mr(o);
            if (n) {
              if (n === u) continue;
              n = Et;
              break;
            }
            n = u;
          }
          return $(n || Et, t);
        }
        return Pr;
      }
      function Ji(i) {
        const t = typeof i;
        return i === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(i) : i instanceof Ri || i instanceof Zr || i instanceof nn || i instanceof pn || i instanceof Gr ? i.toString() : JSON.stringify(i);
      }
      class fn {
        constructor(t, n) {
          this.type = t, this.value = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (!Dn(t[1])) return n.error("invalid value");
          const o = t[1];
          let u = mr(o);
          const f = n.expectedType;
          return u.kind !== "array" || u.N !== 0 || !f || f.kind !== "array" || typeof f.N == "number" && f.N !== 0 || (u = f), new fn(u, o);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class nr {
        constructor(t) {
          this.name = "ExpressionEvaluationError", this.message = t;
        }
        toJSON() {
          return this.message;
        }
      }
      const So = { string: si, number: ct, boolean: kt, object: Pr };
      class sn {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          let o, u = 1;
          const f = t[0];
          if (f === "array") {
            let P, L;
            if (t.length > 2) {
              const E = t[1];
              if (typeof E != "string" || !(E in So) || E === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              P = So[E], u++;
            } else P = Et;
            if (t.length > 3) {
              if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
              L = t[2], u++;
            }
            o = $(P, L);
          } else {
            if (!So[f]) throw new Error(`Types doesn't contain name = ${f}`);
            o = So[f];
          }
          const g = [];
          for (; u < t.length; u++) {
            const P = n.parse(t[u], u, Et);
            if (!P) return null;
            g.push(P);
          }
          return new sn(o, g);
        }
        evaluate(t) {
          for (let n = 0; n < this.args.length; n++) {
            const o = this.args[n].evaluate(t);
            if (!ce(this.type, mr(o))) return o;
            if (n === this.args.length - 1) throw new nr(`Expected value to be of type ${W(this.type)}, but found ${W(mr(o))} instead.`);
          }
          throw new Error();
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const Ra = { "to-boolean": kt, "to-color": Ei, "to-number": ct, "to-string": si };
      class _r {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const o = t[0];
          if (!Ra[o]) throw new Error(`Can't parse ${o} as it is not part of the known types`);
          if ((o === "to-boolean" || o === "to-string") && t.length !== 2) return n.error("Expected one argument.");
          const u = Ra[o], f = [];
          for (let g = 1; g < t.length; g++) {
            const P = n.parse(t[g], g, Et);
            if (!P) return null;
            f.push(P);
          }
          return new _r(u, f);
        }
        evaluate(t) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(t);
            case "color": {
              let n, o;
              for (const u of this.args) {
                if (n = u.evaluate(t), o = null, n instanceof Ri) return n;
                if (typeof n == "string") {
                  const f = t.parseColor(n);
                  if (f) return f;
                } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : to(n[0], n[1], n[2], n[3]), !o)) return new Ri(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
              }
              throw new nr(o || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "padding": {
              let n;
              for (const o of this.args) {
                n = o.evaluate(t);
                const u = nn.parse(n);
                if (u) return u;
              }
              throw new nr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let n;
              for (const o of this.args) {
                n = o.evaluate(t);
                const u = pn.parse(n);
                if (u) return u;
              }
              throw new nr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "number": {
              let n = null;
              for (const o of this.args) {
                if (n = o.evaluate(t), n === null) return 0;
                const u = Number(n);
                if (!isNaN(u)) return u;
              }
              throw new nr(`Could not convert ${JSON.stringify(n)} to number.`);
            }
            case "formatted":
              return Zr.fromString(Ji(this.args[0].evaluate(t)));
            case "resolvedImage":
              return Gr.fromString(Ji(this.args[0].evaluate(t)));
            default:
              return Ji(this.args[0].evaluate(t));
          }
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      const Wo = ["Unknown", "Point", "LineString", "Polygon"];
      class Fr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Wo[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t) {
          let n = this._parseColorCache[t];
          return n || (n = this._parseColorCache[t] = Ri.parse(t)), n;
        }
      }
      class ts {
        constructor(t, n, o = [], u, f = new It(), g = []) {
          this.registry = t, this.path = o, this.key = o.map((P) => `[${P}]`).join(""), this.scope = f, this.errors = g, this.expectedType = u, this._isConstant = n;
        }
        parse(t, n, o, u, f = {}) {
          return n ? this.concat(n, o, u)._parse(t, f) : this._parse(t, f);
        }
        _parse(t, n) {
          function o(u, f, g) {
            return g === "assert" ? new sn(f, [u]) : g === "coerce" ? new _r(f, [u]) : u;
          }
          if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
            if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const u = t[0];
            if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const f = this.registry[u];
            if (f) {
              let g = f.parse(t, this);
              if (!g) return null;
              if (this.expectedType) {
                const P = this.expectedType, L = g.type;
                if (P.kind !== "string" && P.kind !== "number" && P.kind !== "boolean" && P.kind !== "object" && P.kind !== "array" || L.kind !== "value") if (P.kind !== "color" && P.kind !== "formatted" && P.kind !== "resolvedImage" || L.kind !== "value" && L.kind !== "string") if (P.kind !== "padding" || L.kind !== "value" && L.kind !== "number" && L.kind !== "array") if (P.kind !== "variableAnchorOffsetCollection" || L.kind !== "value" && L.kind !== "array") {
                  if (this.checkSubtype(P, L)) return null;
                } else g = o(g, P, n.typeAnnotation || "coerce");
                else g = o(g, P, n.typeAnnotation || "coerce");
                else g = o(g, P, n.typeAnnotation || "coerce");
                else g = o(g, P, n.typeAnnotation || "assert");
              }
              if (!(g instanceof fn) && g.type.kind !== "resolvedImage" && this._isConstant(g)) {
                const P = new Fr();
                try {
                  g = new fn(g.type, g.evaluate(P));
                } catch (L) {
                  return this.error(L.message), null;
                }
              }
              return g;
            }
            return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
        }
        concat(t, n, o) {
          const u = typeof t == "number" ? this.path.concat(t) : this.path, f = o ? this.scope.concat(o) : this.scope;
          return new ts(this.registry, this._isConstant, u, n || null, f, this.errors);
        }
        error(t, ...n) {
          const o = `${this.key}${n.map((u) => `[${u}]`).join("")}`;
          this.errors.push(new ai(o, t));
        }
        checkSubtype(t, n) {
          const o = ce(t, n);
          return o && this.error(o), o;
        }
      }
      class is {
        constructor(t, n) {
          this.type = n.type, this.bindings = [].concat(t), this.result = n;
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const n of this.bindings) t(n[1]);
          t(this.result);
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
          const o = [];
          for (let f = 1; f < t.length - 1; f += 2) {
            const g = t[f];
            if (typeof g != "string") return n.error(`Expected string, but found ${typeof g} instead.`, f);
            if (/[^a-zA-Z0-9_]/.test(g)) return n.error("Variable names must contain only alphanumeric characters or '_'.", f);
            const P = n.parse(t[f + 1], f + 1);
            if (!P) return null;
            o.push([g, P]);
          }
          const u = n.parse(t[t.length - 1], t.length - 1, n.expectedType, o);
          return u ? new is(o, u) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Ni {
        constructor(t, n) {
          this.type = n.type, this.name = t, this.boundExpression = n;
        }
        static parse(t, n) {
          if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
          const o = t[1];
          return n.scope.has(o) ? new Ni(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class Ho {
        constructor(t, n, o) {
          this.type = t, this.index = n, this.input = o;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const o = n.parse(t[1], 1, ct), u = n.parse(t[2], 2, $(n.expectedType || Et));
          return o && u ? new Ho(u.type.itemType, o, u) : null;
        }
        evaluate(t) {
          const n = this.index.evaluate(t), o = this.input.evaluate(t);
          if (n < 0) throw new nr(`Array index out of bounds: ${n} < 0.`);
          if (n >= o.length) throw new nr(`Array index out of bounds: ${n} > ${o.length - 1}.`);
          if (n !== Math.floor(n)) throw new nr(`Array index must be an integer, but found ${n} instead.`);
          return o[n];
        }
        eachChild(t) {
          t(this.index), t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ba {
        constructor(t, n) {
          this.type = kt, this.needle = t, this.haystack = n;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const o = n.parse(t[1], 1, Et), u = n.parse(t[2], 2, Et);
          return o && u ? Pe(o.type, [kt, si, ct, cr, Et]) ? new Ba(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${W(o.type)} instead`) : null;
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), o = this.haystack.evaluate(t);
          if (!o) return !1;
          if (!Ee(n, ["boolean", "string", "number", "null"])) throw new nr(`Expected first argument to be of type boolean, string, number or null, but found ${W(mr(n))} instead.`);
          if (!Ee(o, ["string", "array"])) throw new nr(`Expected second argument to be of type array or string, but found ${W(mr(o))} instead.`);
          return o.indexOf(n) >= 0;
        }
        eachChild(t) {
          t(this.needle), t(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class Fs {
        constructor(t, n, o) {
          this.type = ct, this.needle = t, this.haystack = n, this.fromIndex = o;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const o = n.parse(t[1], 1, Et), u = n.parse(t[2], 2, Et);
          if (!o || !u) return null;
          if (!Pe(o.type, [kt, si, ct, cr, Et])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${W(o.type)} instead`);
          if (t.length === 4) {
            const f = n.parse(t[3], 3, ct);
            return f ? new Fs(o, u, f) : null;
          }
          return new Fs(o, u);
        }
        evaluate(t) {
          const n = this.needle.evaluate(t), o = this.haystack.evaluate(t);
          if (!Ee(n, ["boolean", "string", "number", "null"])) throw new nr(`Expected first argument to be of type boolean, string, number or null, but found ${W(mr(n))} instead.`);
          let u;
          if (this.fromIndex && (u = this.fromIndex.evaluate(t)), Ee(o, ["string"])) {
            const f = o.indexOf(n, u);
            return f === -1 ? -1 : [...o.slice(0, f)].length;
          }
          if (Ee(o, ["array"])) return o.indexOf(n, u);
          throw new nr(`Expected second argument to be of type array or string, but found ${W(mr(o))} instead.`);
        }
        eachChild(t) {
          t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Oa {
        constructor(t, n, o, u, f, g) {
          this.inputType = t, this.type = n, this.input = o, this.cases = u, this.outputs = f, this.otherwise = g;
        }
        static parse(t, n) {
          if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
          let o, u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const f = {}, g = [];
          for (let E = 2; E < t.length - 1; E += 2) {
            let D = t[E];
            const R = t[E + 1];
            Array.isArray(D) || (D = [D]);
            const Z = n.concat(E);
            if (D.length === 0) return Z.error("Expected at least one branch label.");
            for (const K of D) {
              if (typeof K != "number" && typeof K != "string") return Z.error("Branch labels must be numbers or strings.");
              if (typeof K == "number" && Math.abs(K) > Number.MAX_SAFE_INTEGER) return Z.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof K == "number" && Math.floor(K) !== K) return Z.error("Numeric branch labels must be integer values.");
              if (o) {
                if (Z.checkSubtype(o, mr(K))) return null;
              } else o = mr(K);
              if (f[String(K)] !== void 0) return Z.error("Branch labels must be unique.");
              f[String(K)] = g.length;
            }
            const H = n.parse(R, E, u);
            if (!H) return null;
            u = u || H.type, g.push(H);
          }
          const P = n.parse(t[1], 1, Et);
          if (!P) return null;
          const L = n.parse(t[t.length - 1], t.length - 1, u);
          return L ? P.type.kind !== "value" && n.concat(1).checkSubtype(o, P.type) ? null : new Oa(o, u, P, f, g, L) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          return (mr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
        }
        eachChild(t) {
          t(this.input), this.outputs.forEach(t), t(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class io {
        constructor(t, n, o) {
          this.type = t, this.branches = n, this.otherwise = o;
        }
        static parse(t, n) {
          if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
          let o;
          n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
          const u = [];
          for (let g = 1; g < t.length - 1; g += 2) {
            const P = n.parse(t[g], g, kt);
            if (!P) return null;
            const L = n.parse(t[g + 1], g + 1, o);
            if (!L) return null;
            u.push([P, L]), o = o || L.type;
          }
          const f = n.parse(t[t.length - 1], t.length - 1, o);
          if (!f) return null;
          if (!o) throw new Error("Can't infer output type");
          return new io(o, u, f);
        }
        evaluate(t) {
          for (const [n, o] of this.branches) if (n.evaluate(t)) return o.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [n, o] of this.branches) t(n), t(o);
          t(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Ao {
        constructor(t, n, o, u) {
          this.type = t, this.input = n, this.beginIndex = o, this.endIndex = u;
        }
        static parse(t, n) {
          if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const o = n.parse(t[1], 1, Et), u = n.parse(t[2], 2, ct);
          if (!o || !u) return null;
          if (!Pe(o.type, [$(Et), si, Et])) return n.error(`Expected first argument to be of type array or string, but found ${W(o.type)} instead`);
          if (t.length === 4) {
            const f = n.parse(t[3], 3, ct);
            return f ? new Ao(o.type, o, u, f) : null;
          }
          return new Ao(o.type, o, u);
        }
        evaluate(t) {
          const n = this.input.evaluate(t), o = this.beginIndex.evaluate(t);
          let u;
          if (this.endIndex && (u = this.endIndex.evaluate(t)), Ee(n, ["string"])) return [...n].slice(o, u).join("");
          if (Ee(n, ["array"])) return n.slice(o, u);
          throw new nr(`Expected first argument to be of type array or string, but found ${W(mr(n))} instead.`);
        }
        eachChild(t) {
          t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Xo(i, t) {
        const n = i.length - 1;
        let o, u, f = 0, g = n, P = 0;
        for (; f <= g; ) if (P = Math.floor((f + g) / 2), o = i[P], u = i[P + 1], o <= t) {
          if (P === n || t < u) return P;
          f = P + 1;
        } else {
          if (!(o > t)) throw new nr("Input is not a number.");
          g = P - 1;
        }
        return 0;
      }
      class ro {
        constructor(t, n, o) {
          this.type = t, this.input = n, this.labels = [], this.outputs = [];
          for (const [u, f] of o) this.labels.push(u), this.outputs.push(f);
        }
        static parse(t, n) {
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          const o = n.parse(t[1], 1, ct);
          if (!o) return null;
          const u = [];
          let f = null;
          n.expectedType && n.expectedType.kind !== "value" && (f = n.expectedType);
          for (let g = 1; g < t.length; g += 2) {
            const P = g === 1 ? -1 / 0 : t[g], L = t[g + 1], E = g, D = g + 1;
            if (typeof P != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', E);
            if (u.length && u[u.length - 1][0] >= P) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', E);
            const R = n.parse(L, D, f);
            if (!R) return null;
            f = f || R.type, u.push([P, R]);
          }
          return new ro(f, o, u);
        }
        evaluate(t) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1) return o[0].evaluate(t);
          const u = this.input.evaluate(t);
          if (u <= n[0]) return o[0].evaluate(t);
          const f = n.length;
          return u >= n[f - 1] ? o[f - 1].evaluate(t) : o[Xo(n, u)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function ys(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var Yo = Po;
      function Po(i, t, n, o) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (o - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = t, this.p2x = n, this.p2y = o;
      }
      Po.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, t) {
        if (t === void 0 && (t = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, o = 0; o < 8; o++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < t) return n;
          var f = this.sampleCurveDerivativeX(n);
          if (Math.abs(f) < 1e-6) break;
          n -= u / f;
        }
        var g = 0, P = 1;
        for (n = i, o = 0; o < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < t)); o++) i > u ? g = n : P = n, n = 0.5 * (P - g) + g;
        return n;
      }, solve: function(i, t) {
        return this.sampleCurveY(this.solveCurveX(i, t));
      } };
      var hl = ys(Yo);
      function gr(i, t, n) {
        return i + n * (t - i);
      }
      function Io(i, t, n) {
        return i.map((o, u) => gr(o, t[u], n));
      }
      const Rr = { number: gr, color: function(i, t, n, o = "rgb") {
        switch (o) {
          case "rgb": {
            const [u, f, g, P] = Io(i.rgb, t.rgb, n);
            return new Ri(u, f, g, P, !1);
          }
          case "hcl": {
            const [u, f, g, P] = i.hcl, [L, E, D, R] = t.hcl;
            let Z, H;
            if (isNaN(u) || isNaN(L)) isNaN(u) ? isNaN(L) ? Z = NaN : (Z = L, g !== 1 && g !== 0 || (H = E)) : (Z = u, D !== 1 && D !== 0 || (H = f));
            else {
              let Ne = L - u;
              L > u && Ne > 180 ? Ne -= 360 : L < u && u - L > 180 && (Ne += 360), Z = u + n * Ne;
            }
            const [K, re, pe, xe] = function([Ne, Te, ze, Ge]) {
              return Ne = isNaN(Ne) ? 0 : Ne * Zt, Fi([ze, Math.cos(Ne) * Te, Math.sin(Ne) * Te, Ge]);
            }([Z, H ?? gr(f, E, n), gr(g, D, n), gr(P, R, n)]);
            return new Ri(K, re, pe, xe, !1);
          }
          case "lab": {
            const [u, f, g, P] = Fi(Io(i.lab, t.lab, n));
            return new Ri(u, f, g, P, !1);
          }
        }
      }, array: Io, padding: function(i, t, n) {
        return new nn(Io(i.values, t.values, n));
      }, variableAnchorOffsetCollection: function(i, t, n) {
        const o = i.values, u = t.values;
        if (o.length !== u.length) throw new nr(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${t.toString()}`);
        const f = [];
        for (let g = 0; g < o.length; g += 2) {
          if (o[g] !== u[g]) throw new nr(`Cannot interpolate values containing mismatched anchors. from[${g}]: ${o[g]}, to[${g}]: ${u[g]}`);
          f.push(o[g]);
          const [P, L] = o[g + 1], [E, D] = u[g + 1];
          f.push([gr(P, E, n), gr(L, D, n)]);
        }
        return new pn(f);
      } };
      class Xt {
        constructor(t, n, o, u, f) {
          this.type = t, this.operator = n, this.interpolation = o, this.input = u, this.labels = [], this.outputs = [];
          for (const [g, P] of f) this.labels.push(g), this.outputs.push(P);
        }
        static interpolationFactor(t, n, o, u) {
          let f = 0;
          if (t.name === "exponential") f = Jo(n, t.base, o, u);
          else if (t.name === "linear") f = Jo(n, 1, o, u);
          else if (t.name === "cubic-bezier") {
            const g = t.controlPoints;
            f = new hl(g[0], g[1], g[2], g[3]).solve(Jo(n, 1, o, u));
          }
          return f;
        }
        static parse(t, n) {
          let [o, u, f, ...g] = t;
          if (!Array.isArray(u) || u.length === 0) return n.error("Expected an interpolation type expression.", 1);
          if (u[0] === "linear") u = { name: "linear" };
          else if (u[0] === "exponential") {
            const E = u[1];
            if (typeof E != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            u = { name: "exponential", base: E };
          } else {
            if (u[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
            {
              const E = u.slice(1);
              if (E.length !== 4 || E.some((D) => typeof D != "number" || D < 0 || D > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              u = { name: "cubic-bezier", controlPoints: E };
            }
          }
          if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          if (f = n.parse(f, 2, ct), !f) return null;
          const P = [];
          let L = null;
          o === "interpolate-hcl" || o === "interpolate-lab" ? L = Ei : n.expectedType && n.expectedType.kind !== "value" && (L = n.expectedType);
          for (let E = 0; E < g.length; E += 2) {
            const D = g[E], R = g[E + 1], Z = E + 3, H = E + 4;
            if (typeof D != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Z);
            if (P.length && P[P.length - 1][0] >= D) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Z);
            const K = n.parse(R, H, L);
            if (!K) return null;
            L = L || K.type, P.push([D, K]);
          }
          return Ae(L, ct) || Ae(L, Ei) || Ae(L, Cr) || Ae(L, ue) || Ae(L, $(ct)) ? new Xt(L, o, u, f, P) : n.error(`Type ${W(L)} is not interpolatable.`);
        }
        evaluate(t) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1) return o[0].evaluate(t);
          const u = this.input.evaluate(t);
          if (u <= n[0]) return o[0].evaluate(t);
          const f = n.length;
          if (u >= n[f - 1]) return o[f - 1].evaluate(t);
          const g = Xo(n, u), P = Xt.interpolationFactor(this.interpolation, u, n[g], n[g + 1]), L = o[g].evaluate(t), E = o[g + 1].evaluate(t);
          switch (this.operator) {
            case "interpolate":
              return Rr[this.type.kind](L, E, P);
            case "interpolate-hcl":
              return Rr.color(L, E, P, "hcl");
            case "interpolate-lab":
              return Rr.color(L, E, P, "lab");
          }
        }
        eachChild(t) {
          t(this.input);
          for (const n of this.outputs) t(n);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
      }
      function Jo(i, t, n, o) {
        const u = o - n, f = i - n;
        return u === 0 ? 0 : t === 1 ? f / u : (Math.pow(t, f) - 1) / (Math.pow(t, u) - 1);
      }
      class Ko {
        constructor(t, n) {
          this.type = t, this.args = n;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expectected at least one argument.");
          let o = null;
          const u = n.expectedType;
          u && u.kind !== "value" && (o = u);
          const f = [];
          for (const P of t.slice(1)) {
            const L = n.parse(P, 1 + f.length, o, void 0, { typeAnnotation: "omit" });
            if (!L) return null;
            o = o || L.type, f.push(L);
          }
          if (!o) throw new Error("No output type");
          const g = u && f.some((P) => ce(u, P.type));
          return new Ko(g ? Et : o, f);
        }
        evaluate(t) {
          let n, o = null, u = 0;
          for (const f of this.args) if (u++, o = f.evaluate(t), o && o instanceof Gr && !o.available && (n || (n = o.name), o = null, u === this.args.length && (o = n)), o !== null) break;
          return o;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
      }
      function Sn(i, t) {
        return i === "==" || i === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
      }
      function ja(i, t, n, o) {
        return o.compare(t, n) === 0;
      }
      function Rs(i, t, n) {
        const o = i !== "==" && i !== "!=";
        return class bf {
          constructor(f, g, P) {
            this.type = kt, this.lhs = f, this.rhs = g, this.collator = P, this.hasUntypedArgument = f.type.kind === "value" || g.type.kind === "value";
          }
          static parse(f, g) {
            if (f.length !== 3 && f.length !== 4) return g.error("Expected two or three arguments.");
            const P = f[0];
            let L = g.parse(f[1], 1, Et);
            if (!L) return null;
            if (!Sn(P, L.type)) return g.concat(1).error(`"${P}" comparisons are not supported for type '${W(L.type)}'.`);
            let E = g.parse(f[2], 2, Et);
            if (!E) return null;
            if (!Sn(P, E.type)) return g.concat(2).error(`"${P}" comparisons are not supported for type '${W(E.type)}'.`);
            if (L.type.kind !== E.type.kind && L.type.kind !== "value" && E.type.kind !== "value") return g.error(`Cannot compare types '${W(L.type)}' and '${W(E.type)}'.`);
            o && (L.type.kind === "value" && E.type.kind !== "value" ? L = new sn(E.type, [L]) : L.type.kind !== "value" && E.type.kind === "value" && (E = new sn(L.type, [E])));
            let D = null;
            if (f.length === 4) {
              if (L.type.kind !== "string" && E.type.kind !== "string" && L.type.kind !== "value" && E.type.kind !== "value") return g.error("Cannot use collator to compare non-string types.");
              if (D = g.parse(f[3], 3, $r), !D) return null;
            }
            return new bf(L, E, D);
          }
          evaluate(f) {
            const g = this.lhs.evaluate(f), P = this.rhs.evaluate(f);
            if (o && this.hasUntypedArgument) {
              const L = mr(g), E = mr(P);
              if (L.kind !== E.kind || L.kind !== "string" && L.kind !== "number") throw new nr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${L.kind}, ${E.kind}) instead.`);
            }
            if (this.collator && !o && this.hasUntypedArgument) {
              const L = mr(g), E = mr(P);
              if (L.kind !== "string" || E.kind !== "string") return t(f, g, P);
            }
            return this.collator ? n(f, g, P, this.collator.evaluate(f)) : t(f, g, P);
          }
          eachChild(f) {
            f(this.lhs), f(this.rhs), this.collator && f(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const Qo = Rs("==", function(i, t, n) {
        return t === n;
      }, ja), ea = Rs("!=", function(i, t, n) {
        return t !== n;
      }, function(i, t, n, o) {
        return !ja(0, t, n, o);
      }), ul = Rs("<", function(i, t, n) {
        return t < n;
      }, function(i, t, n, o) {
        return o.compare(t, n) < 0;
      }), Nl = Rs(">", function(i, t, n) {
        return t > n;
      }, function(i, t, n, o) {
        return o.compare(t, n) > 0;
      }), Fl = Rs("<=", function(i, t, n) {
        return t <= n;
      }, function(i, t, n, o) {
        return o.compare(t, n) <= 0;
      }), ta = Rs(">=", function(i, t, n) {
        return t >= n;
      }, function(i, t, n, o) {
        return o.compare(t, n) >= 0;
      });
      class rs {
        constructor(t, n, o) {
          this.type = $r, this.locale = o, this.caseSensitive = t, this.diacriticSensitive = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected one argument.");
          const o = t[1];
          if (typeof o != "object" || Array.isArray(o)) return n.error("Collator options argument must be an object.");
          const u = n.parse(o["case-sensitive"] !== void 0 && o["case-sensitive"], 1, kt);
          if (!u) return null;
          const f = n.parse(o["diacritic-sensitive"] !== void 0 && o["diacritic-sensitive"], 1, kt);
          if (!f) return null;
          let g = null;
          return o.locale && (g = n.parse(o.locale, 1, si), !g) ? null : new rs(u, f, g);
        }
        evaluate(t) {
          return new Na(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
        }
        eachChild(t) {
          t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class _s {
        constructor(t, n, o, u, f) {
          this.type = si, this.number = t, this.locale = n, this.currency = o, this.minFractionDigits = u, this.maxFractionDigits = f;
        }
        static parse(t, n) {
          if (t.length !== 3) return n.error("Expected two arguments.");
          const o = n.parse(t[1], 1, ct);
          if (!o) return null;
          const u = t[2];
          if (typeof u != "object" || Array.isArray(u)) return n.error("NumberFormat options argument must be an object.");
          let f = null;
          if (u.locale && (f = n.parse(u.locale, 1, si), !f)) return null;
          let g = null;
          if (u.currency && (g = n.parse(u.currency, 1, si), !g)) return null;
          let P = null;
          if (u["min-fraction-digits"] && (P = n.parse(u["min-fraction-digits"], 1, ct), !P)) return null;
          let L = null;
          return u["max-fraction-digits"] && (L = n.parse(u["max-fraction-digits"], 1, ct), !L) ? null : new _s(o, f, g, P, L);
        }
        evaluate(t) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
        }
        eachChild(t) {
          t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class ia {
        constructor(t) {
          this.type = qi, this.sections = t;
        }
        static parse(t, n) {
          if (t.length < 2) return n.error("Expected at least one argument.");
          const o = t[1];
          if (!Array.isArray(o) && typeof o == "object") return n.error("First argument must be an image or text section.");
          const u = [];
          let f = !1;
          for (let g = 1; g <= t.length - 1; ++g) {
            const P = t[g];
            if (f && typeof P == "object" && !Array.isArray(P)) {
              f = !1;
              let L = null;
              if (P["font-scale"] && (L = n.parse(P["font-scale"], 1, ct), !L)) return null;
              let E = null;
              if (P["text-font"] && (E = n.parse(P["text-font"], 1, $(si)), !E)) return null;
              let D = null;
              if (P["text-color"] && (D = n.parse(P["text-color"], 1, Ei), !D)) return null;
              const R = u[u.length - 1];
              R.scale = L, R.font = E, R.textColor = D;
            } else {
              const L = n.parse(t[g], 1, Et);
              if (!L) return null;
              const E = L.type.kind;
              if (E !== "string" && E !== "value" && E !== "null" && E !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              f = !0, u.push({ content: L, scale: null, font: null, textColor: null });
            }
          }
          return new ia(u);
        }
        evaluate(t) {
          return new Zr(this.sections.map((n) => {
            const o = n.content.evaluate(t);
            return mr(o) === Er ? new eo("", o, null, null, null) : new eo(Ji(o), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null);
          }));
        }
        eachChild(t) {
          for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Bs {
        constructor(t) {
          this.type = Er, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error("Expected two arguments.");
          const o = n.parse(t[1], 1, si);
          return o ? new Bs(o) : n.error("No image name provided.");
        }
        evaluate(t) {
          const n = this.input.evaluate(t), o = Gr.fromString(n);
          return o && t.availableImages && (o.available = t.availableImages.indexOf(n) > -1), o;
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Lo {
        constructor(t) {
          this.type = ct, this.input = t;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
          const o = n.parse(t[1], 1);
          return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${W(o.type)} instead.`) : new Lo(o) : null;
        }
        evaluate(t) {
          const n = this.input.evaluate(t);
          if (typeof n == "string") return [...n].length;
          if (Array.isArray(n)) return n.length;
          throw new nr(`Expected value to be of type string or array, but found ${W(mr(n))} instead.`);
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const on = 8192;
      function dl(i, t) {
        const n = (180 + i[0]) / 360, o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, u = Math.pow(2, t.z);
        return [Math.round(n * u * on), Math.round(o * u * on)];
      }
      function ra(i, t) {
        const n = Math.pow(2, t.z);
        return [(u = (i[0] / on + t.x) / n, 360 * u - 180), (o = (i[1] / on + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90)];
        var o, u;
      }
      function vs(i, t) {
        i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.max(i[2], t[0]), i[3] = Math.max(i[3], t[1]);
      }
      function ns(i, t) {
        return !(i[0] <= t[0] || i[2] >= t[2] || i[1] <= t[1] || i[3] >= t[3]);
      }
      function Pi(i, t, n) {
        const o = i[0] - t[0], u = i[1] - t[1], f = i[0] - n[0], g = i[1] - n[1];
        return o * g - f * u == 0 && o * f <= 0 && u * g <= 0;
      }
      function ss(i, t, n, o) {
        return (u = [o[0] - n[0], o[1] - n[1]])[0] * (f = [t[0] - i[0], t[1] - i[1]])[1] - u[1] * f[0] != 0 && !(!pl(i, t, n, o) || !pl(n, o, i, t));
        var u, f;
      }
      function Rl(i, t, n) {
        for (const o of n) for (let u = 0; u < o.length - 1; ++u) if (ss(i, t, o[u], o[u + 1])) return !0;
        return !1;
      }
      function An(i, t, n = !1) {
        let o = !1;
        for (const P of t) for (let L = 0; L < P.length - 1; L++) {
          if (Pi(i, P[L], P[L + 1])) return n;
          (f = P[L])[1] > (u = i)[1] != (g = P[L + 1])[1] > u[1] && u[0] < (g[0] - f[0]) * (u[1] - f[1]) / (g[1] - f[1]) + f[0] && (o = !o);
        }
        var u, f, g;
        return o;
      }
      function os(i, t) {
        for (const n of t) if (An(i, n)) return !0;
        return !1;
      }
      function na(i, t) {
        for (const n of i) if (!An(n, t)) return !1;
        for (let n = 0; n < i.length - 1; ++n) if (Rl(i[n], i[n + 1], t)) return !1;
        return !0;
      }
      function To(i, t) {
        for (const n of t) if (na(i, n)) return !0;
        return !1;
      }
      function pl(i, t, n, o) {
        const u = o[0] - n[0], f = o[1] - n[1], g = (i[0] - n[0]) * f - u * (i[1] - n[1]), P = (t[0] - n[0]) * f - u * (t[1] - n[1]);
        return g > 0 && P < 0 || g < 0 && P > 0;
      }
      function no(i, t, n) {
        const o = [];
        for (let u = 0; u < i.length; u++) {
          const f = [];
          for (let g = 0; g < i[u].length; g++) {
            const P = dl(i[u][g], n);
            vs(t, P), f.push(P);
          }
          o.push(f);
        }
        return o;
      }
      function fl(i, t, n) {
        const o = [];
        for (let u = 0; u < i.length; u++) {
          const f = no(i[u], t, n);
          o.push(f);
        }
        return o;
      }
      function sa(i, t, n, o) {
        if (i[0] < n[0] || i[0] > n[2]) {
          const u = 0.5 * o;
          let f = i[0] - n[0] > u ? -o : n[0] - i[0] > u ? o : 0;
          f === 0 && (f = i[0] - n[2] > u ? -o : n[2] - i[0] > u ? o : 0), i[0] += f;
        }
        vs(t, i);
      }
      function oa(i, t, n, o) {
        const u = Math.pow(2, o.z) * on, f = [o.x * on, o.y * on], g = [];
        for (const P of i) for (const L of P) {
          const E = [L.x + f[0], L.y + f[1]];
          sa(E, t, n, u), g.push(E);
        }
        return g;
      }
      function qa(i, t, n, o) {
        const u = Math.pow(2, o.z) * on, f = [o.x * on, o.y * on], g = [];
        for (const L of i) {
          const E = [];
          for (const D of L) {
            const R = [D.x + f[0], D.y + f[1]];
            vs(t, R), E.push(R);
          }
          g.push(E);
        }
        if (t[2] - t[0] <= u / 2) {
          (P = t)[0] = P[1] = 1 / 0, P[2] = P[3] = -1 / 0;
          for (const L of g) for (const E of L) sa(E, t, n, u);
        }
        var P;
        return g;
      }
      class Nn {
        constructor(t, n) {
          this.type = kt, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (Dn(t[1])) {
            const o = t[1];
            if (o.type === "FeatureCollection") {
              const u = [];
              for (const f of o.features) {
                const { type: g, coordinates: P } = f.geometry;
                g === "Polygon" && u.push(P), g === "MultiPolygon" && u.push(...P);
              }
              if (u.length) return new Nn(o, { type: "MultiPolygon", coordinates: u });
            } else if (o.type === "Feature") {
              const u = o.geometry.type;
              if (u === "Polygon" || u === "MultiPolygon") return new Nn(o, o.geometry);
            } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new Nn(o, o);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, o) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], g = n.canonicalID();
              if (o.type === "Polygon") {
                const P = no(o.coordinates, f, g), L = oa(n.geometry(), u, f, g);
                if (!ns(u, f)) return !1;
                for (const E of L) if (!An(E, P)) return !1;
              }
              if (o.type === "MultiPolygon") {
                const P = fl(o.coordinates, f, g), L = oa(n.geometry(), u, f, g);
                if (!ns(u, f)) return !1;
                for (const E of L) if (!os(E, P)) return !1;
              }
              return !0;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, o) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = [1 / 0, 1 / 0, -1 / 0, -1 / 0], g = n.canonicalID();
              if (o.type === "Polygon") {
                const P = no(o.coordinates, f, g), L = qa(n.geometry(), u, f, g);
                if (!ns(u, f)) return !1;
                for (const E of L) if (!na(E, P)) return !1;
              }
              if (o.type === "MultiPolygon") {
                const P = fl(o.coordinates, f, g), L = qa(n.geometry(), u, f, g);
                if (!ns(u, f)) return !1;
                for (const E of L) if (!To(E, P)) return !1;
              }
              return !0;
            }(t, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let aa = class {
        constructor(i = [], t = (n, o) => n < o ? -1 : n > o ? 1 : 0) {
          if (this.data = i, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(i) {
          this.data.push(i), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], t = this.data.pop();
          return --this.length > 0 && (this.data[0] = t, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: t, compare: n } = this, o = t[i];
          for (; i > 0; ) {
            const u = i - 1 >> 1, f = t[u];
            if (n(o, f) >= 0) break;
            t[i] = f, i = u;
          }
          t[i] = o;
        }
        _down(i) {
          const { data: t, compare: n } = this, o = this.length >> 1, u = t[i];
          for (; i < o; ) {
            let f = 1 + (i << 1);
            const g = f + 1;
            if (g < this.length && n(t[g], t[f]) < 0 && (f = g), n(t[f], u) >= 0) break;
            t[i] = t[f], i = f;
          }
          t[i] = u;
        }
      };
      function Va(i, t, n, o, u) {
        Ua(i, t, n, o || i.length - 1, u || la);
      }
      function Ua(i, t, n, o, u) {
        for (; o > n; ) {
          if (o - n > 600) {
            var f = o - n + 1, g = t - n + 1, P = Math.log(f), L = 0.5 * Math.exp(2 * P / 3), E = 0.5 * Math.sqrt(P * L * (f - L) / f) * (g - f / 2 < 0 ? -1 : 1);
            Ua(i, t, Math.max(n, Math.floor(t - g * L / f + E)), Math.min(o, Math.floor(t + (f - g) * L / f + E)), u);
          }
          var D = i[t], R = n, Z = o;
          for (ko(i, n, t), u(i[o], D) > 0 && ko(i, n, o); R < Z; ) {
            for (ko(i, R, Z), R++, Z--; u(i[R], D) < 0; ) R++;
            for (; u(i[Z], D) > 0; ) Z--;
          }
          u(i[n], D) === 0 ? ko(i, n, Z) : ko(i, ++Z, o), Z <= t && (n = Z + 1), t <= Z && (o = Z - 1);
        }
      }
      function ko(i, t, n) {
        var o = i[t];
        i[t] = i[n], i[n] = o;
      }
      function la(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function xs(i, t) {
        if (i.length <= 1) return [i];
        const n = [];
        let o, u;
        for (const f of i) {
          const g = so(f);
          g !== 0 && (f.area = Math.abs(g), u === void 0 && (u = g < 0), u === g < 0 ? (o && n.push(o), o = [f]) : o.push(f));
        }
        if (o && n.push(o), t > 1) for (let f = 0; f < n.length; f++) n[f].length <= t || (Va(n[f], t, 1, n[f].length - 1, $a), n[f] = n[f].slice(0, t));
        return n;
      }
      function $a(i, t) {
        return t.area - i.area;
      }
      function so(i) {
        let t = 0;
        for (let n, o, u = 0, f = i.length, g = f - 1; u < f; g = u++) n = i[u], o = i[g], t += (o.x - n.x) * (n.y + o.y);
        return t;
      }
      const ca = 1 / 298.257223563, T = ca * (2 - ca), X = Math.PI / 180;
      class me {
        constructor(t) {
          const n = 6378.137 * X * 1e3, o = Math.cos(t * X), u = 1 / (1 - T * (1 - o * o)), f = Math.sqrt(u);
          this.kx = n * f * o, this.ky = n * f * u * (1 - T);
        }
        distance(t, n) {
          const o = this.wrap(t[0] - n[0]) * this.kx, u = (t[1] - n[1]) * this.ky;
          return Math.sqrt(o * o + u * u);
        }
        pointOnLine(t, n) {
          let o, u, f, g, P = 1 / 0;
          for (let L = 0; L < t.length - 1; L++) {
            let E = t[L][0], D = t[L][1], R = this.wrap(t[L + 1][0] - E) * this.kx, Z = (t[L + 1][1] - D) * this.ky, H = 0;
            R === 0 && Z === 0 || (H = (this.wrap(n[0] - E) * this.kx * R + (n[1] - D) * this.ky * Z) / (R * R + Z * Z), H > 1 ? (E = t[L + 1][0], D = t[L + 1][1]) : H > 0 && (E += R / this.kx * H, D += Z / this.ky * H)), R = this.wrap(n[0] - E) * this.kx, Z = (n[1] - D) * this.ky;
            const K = R * R + Z * Z;
            K < P && (P = K, o = E, u = D, f = L, g = H);
          }
          return { point: [o, u], index: f, t: Math.max(0, Math.min(1, g)) };
        }
        wrap(t) {
          for (; t < -180; ) t += 360;
          for (; t > 180; ) t -= 360;
          return t;
        }
      }
      function ke(i, t) {
        return t[0] - i[0];
      }
      function Fe(i) {
        return i[1] - i[0] + 1;
      }
      function Xe(i, t) {
        return i[1] >= i[0] && i[1] < t;
      }
      function xt(i, t) {
        if (i[0] > i[1]) return [null, null];
        const n = Fe(i);
        if (t) {
          if (n === 2) return [i, null];
          const u = Math.floor(n / 2);
          return [[i[0], i[0] + u], [i[0] + u, i[1]]];
        }
        if (n === 1) return [i, null];
        const o = Math.floor(n / 2) - 1;
        return [[i[0], i[0] + o], [i[0] + o + 1, i[1]]];
      }
      function Rt(i, t) {
        if (!Xe(t, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let o = t[0]; o <= t[1]; ++o) vs(n, i[o]);
        return n;
      }
      function ti(i) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const n of i) for (const o of n) vs(t, o);
        return t;
      }
      function mi(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function wi(i, t, n) {
        if (!mi(i) || !mi(t)) return NaN;
        let o = 0, u = 0;
        return i[2] < t[0] && (o = t[0] - i[2]), i[0] > t[2] && (o = i[0] - t[2]), i[1] > t[3] && (u = i[1] - t[3]), i[3] < t[1] && (u = t[1] - i[3]), n.distance([0, 0], [o, u]);
      }
      function Ii(i, t, n) {
        const o = n.pointOnLine(t, i);
        return n.distance(i, o.point);
      }
      function Ki(i, t, n, o, u) {
        const f = Math.min(Ii(i, [n, o], u), Ii(t, [n, o], u)), g = Math.min(Ii(n, [i, t], u), Ii(o, [i, t], u));
        return Math.min(f, g);
      }
      function vr(i, t, n, o, u) {
        if (!Xe(t, i.length) || !Xe(o, n.length)) return 1 / 0;
        let f = 1 / 0;
        for (let g = t[0]; g < t[1]; ++g) {
          const P = i[g], L = i[g + 1];
          for (let E = o[0]; E < o[1]; ++E) {
            const D = n[E], R = n[E + 1];
            if (ss(P, L, D, R)) return 0;
            f = Math.min(f, Ki(P, L, D, R, u));
          }
        }
        return f;
      }
      function Si(i, t, n, o, u) {
        if (!Xe(t, i.length) || !Xe(o, n.length)) return NaN;
        let f = 1 / 0;
        for (let g = t[0]; g <= t[1]; ++g) for (let P = o[0]; P <= o[1]; ++P) if (f = Math.min(f, u.distance(i[g], n[P])), f === 0) return f;
        return f;
      }
      function Wr(i, t, n) {
        if (An(i, t, !0)) return 0;
        let o = 1 / 0;
        for (const u of t) {
          const f = u[0], g = u[u.length - 1];
          if (f !== g && (o = Math.min(o, Ii(i, [g, f], n)), o === 0)) return o;
          const P = n.pointOnLine(u, i);
          if (o = Math.min(o, n.distance(i, P.point)), o === 0) return o;
        }
        return o;
      }
      function Yt(i, t, n, o) {
        if (!Xe(t, i.length)) return NaN;
        for (let f = t[0]; f <= t[1]; ++f) if (An(i[f], n, !0)) return 0;
        let u = 1 / 0;
        for (let f = t[0]; f < t[1]; ++f) {
          const g = i[f], P = i[f + 1];
          for (const L of n) for (let E = 0, D = L.length, R = D - 1; E < D; R = E++) {
            const Z = L[R], H = L[E];
            if (ss(g, P, Z, H)) return 0;
            u = Math.min(u, Ki(g, P, Z, H, o));
          }
        }
        return u;
      }
      function mn(i, t) {
        for (const n of i) for (const o of n) if (An(o, t, !0)) return !0;
        return !1;
      }
      function ki(i, t, n, o = 1 / 0) {
        const u = ti(i), f = ti(t);
        if (o !== 1 / 0 && wi(u, f, n) >= o) return o;
        if (ns(u, f)) {
          if (mn(i, t)) return 0;
        } else if (mn(t, i)) return 0;
        let g = 1 / 0;
        for (const P of i) for (let L = 0, E = P.length, D = E - 1; L < E; D = L++) {
          const R = P[D], Z = P[L];
          for (const H of t) for (let K = 0, re = H.length, pe = re - 1; K < re; pe = K++) {
            const xe = H[pe], Ne = H[K];
            if (ss(R, Z, xe, Ne)) return 0;
            g = Math.min(g, Ki(R, Z, xe, Ne, n));
          }
        }
        return g;
      }
      function Mi(i, t, n, o, u, f) {
        if (!f) return;
        const g = wi(Rt(o, f), u, n);
        g < t && i.push([g, f, [0, 0]]);
      }
      function bs(i, t, n, o, u, f, g) {
        if (!f || !g) return;
        const P = wi(Rt(o, f), Rt(u, g), n);
        P < t && i.push([P, f, g]);
      }
      function Os(i, t, n, o, u = 1 / 0) {
        let f = Math.min(o.distance(i[0], n[0][0]), u);
        if (f === 0) return f;
        const g = new aa([[0, [0, i.length - 1], [0, 0]]], ke), P = ti(n);
        for (; g.length > 0; ) {
          const L = g.pop();
          if (L[0] >= f) continue;
          const E = L[1], D = t ? 50 : 100;
          if (Fe(E) <= D) {
            if (!Xe(E, i.length)) return NaN;
            if (t) {
              const R = Yt(i, E, n, o);
              if (isNaN(R) || R === 0) return R;
              f = Math.min(f, R);
            } else for (let R = E[0]; R <= E[1]; ++R) {
              const Z = Wr(i[R], n, o);
              if (f = Math.min(f, Z), f === 0) return 0;
            }
          } else {
            const R = xt(E, t);
            Mi(g, f, o, i, P, R[0]), Mi(g, f, o, i, P, R[1]);
          }
        }
        return f;
      }
      function js(i, t, n, o, u, f = 1 / 0) {
        let g = Math.min(f, u.distance(i[0], n[0]));
        if (g === 0) return g;
        const P = new aa([[0, [0, i.length - 1], [0, n.length - 1]]], ke);
        for (; P.length > 0; ) {
          const L = P.pop();
          if (L[0] >= g) continue;
          const E = L[1], D = L[2], R = t ? 50 : 100, Z = o ? 50 : 100;
          if (Fe(E) <= R && Fe(D) <= Z) {
            if (!Xe(E, i.length) && Xe(D, n.length)) return NaN;
            let H;
            if (t && o) H = vr(i, E, n, D, u), g = Math.min(g, H);
            else if (t && !o) {
              const K = i.slice(E[0], E[1] + 1);
              for (let re = D[0]; re <= D[1]; ++re) if (H = Ii(n[re], K, u), g = Math.min(g, H), g === 0) return g;
            } else if (!t && o) {
              const K = n.slice(D[0], D[1] + 1);
              for (let re = E[0]; re <= E[1]; ++re) if (H = Ii(i[re], K, u), g = Math.min(g, H), g === 0) return g;
            } else H = Si(i, E, n, D, u), g = Math.min(g, H);
          } else {
            const H = xt(E, t), K = xt(D, o);
            bs(P, g, u, i, n, H[0], K[0]), bs(P, g, u, i, n, H[0], K[1]), bs(P, g, u, i, n, H[1], K[0]), bs(P, g, u, i, n, H[1], K[1]);
          }
        }
        return g;
      }
      function oo(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((t) => ({ type: "Polygon", coordinates: t })) : i.type === "MultiLineString" ? i.coordinates.map((t) => ({ type: "LineString", coordinates: t })) : i.type === "MultiPoint" ? i.coordinates.map((t) => ({ type: "Point", coordinates: t })) : [i];
      }
      class as {
        constructor(t, n) {
          this.type = ct, this.geojson = t, this.geometries = n;
        }
        static parse(t, n) {
          if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (Dn(t[1])) {
            const o = t[1];
            if (o.type === "FeatureCollection") return new as(o, o.features.map((u) => oo(u.geometry)).flat());
            if (o.type === "Feature") return new as(o, oo(o.geometry));
            if ("type" in o && "coordinates" in o) return new as(o, oo(o));
          }
          return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === "Point") return function(n, o) {
              const u = n.geometry(), f = u.flat().map((L) => ra([L.x, L.y], n.canonical));
              if (u.length === 0) return NaN;
              const g = new me(f[0][1]);
              let P = 1 / 0;
              for (const L of o) {
                switch (L.type) {
                  case "Point":
                    P = Math.min(P, js(f, !1, [L.coordinates], !1, g, P));
                    break;
                  case "LineString":
                    P = Math.min(P, js(f, !1, L.coordinates, !0, g, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, Os(f, !1, L.coordinates, g, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(t, this.geometries);
            if (t.geometryType() === "LineString") return function(n, o) {
              const u = n.geometry(), f = u.flat().map((L) => ra([L.x, L.y], n.canonical));
              if (u.length === 0) return NaN;
              const g = new me(f[0][1]);
              let P = 1 / 0;
              for (const L of o) {
                switch (L.type) {
                  case "Point":
                    P = Math.min(P, js(f, !0, [L.coordinates], !1, g, P));
                    break;
                  case "LineString":
                    P = Math.min(P, js(f, !0, L.coordinates, !0, g, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, Os(f, !0, L.coordinates, g, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(t, this.geometries);
            if (t.geometryType() === "Polygon") return function(n, o) {
              const u = n.geometry();
              if (u.length === 0 || u[0].length === 0) return NaN;
              const f = xs(u, 0).map((L) => L.map((E) => E.map((D) => ra([D.x, D.y], n.canonical)))), g = new me(f[0][0][0][1]);
              let P = 1 / 0;
              for (const L of o) for (const E of f) {
                switch (L.type) {
                  case "Point":
                    P = Math.min(P, Os([L.coordinates], !1, E, g, P));
                    break;
                  case "LineString":
                    P = Math.min(P, Os(L.coordinates, !0, E, g, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, ki(E, L.coordinates, g, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(t, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const ws = { "==": Qo, "!=": ea, ">": Nl, "<": ul, ">=": ta, "<=": Fl, array: sn, at: Ho, boolean: sn, case: io, coalesce: Ko, collator: rs, format: ia, image: Bs, in: Ba, "index-of": Fs, interpolate: Xt, "interpolate-hcl": Xt, "interpolate-lab": Xt, length: Lo, let: is, literal: fn, match: Oa, number: sn, "number-format": _s, object: sn, slice: Ao, step: ro, string: sn, "to-boolean": _r, "to-color": _r, "to-number": _r, "to-string": _r, var: Ni, within: Nn, distance: as };
      class Br {
        constructor(t, n, o, u) {
          this.name = t, this.type = n, this._evaluate = o, this.args = u;
        }
        evaluate(t) {
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        static parse(t, n) {
          const o = t[0], u = Br.definitions[o];
          if (!u) return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const f = Array.isArray(u) ? u[0] : u.type, g = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, P = g.filter(([E]) => !Array.isArray(E) || E.length === t.length - 1);
          let L = null;
          for (const [E, D] of P) {
            L = new ts(n.registry, qs, n.path, null, n.scope);
            const R = [];
            let Z = !1;
            for (let H = 1; H < t.length; H++) {
              const K = t[H], re = Array.isArray(E) ? E[H - 1] : E.type, pe = L.parse(K, 1 + R.length, re);
              if (!pe) {
                Z = !0;
                break;
              }
              R.push(pe);
            }
            if (!Z) if (Array.isArray(E) && E.length !== R.length) L.error(`Expected ${E.length} arguments, but found ${R.length} instead.`);
            else {
              for (let H = 0; H < R.length; H++) {
                const K = Array.isArray(E) ? E[H] : E.type, re = R[H];
                L.concat(H + 1).checkSubtype(K, re.type);
              }
              if (L.errors.length === 0) return new Br(o, f, D, R);
            }
          }
          if (P.length === 1) n.errors.push(...L.errors);
          else {
            const E = (P.length ? P : g).map(([R]) => {
              return Z = R, Array.isArray(Z) ? `(${Z.map(W).join(", ")})` : `(${W(Z.type)}...)`;
              var Z;
            }).join(" | "), D = [];
            for (let R = 1; R < t.length; R++) {
              const Z = n.parse(t[R], 1 + D.length);
              if (!Z) return null;
              D.push(W(Z.type));
            }
            n.error(`Expected arguments of type ${E}, but found (${D.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t, n) {
          Br.definitions = n;
          for (const o in n) t[o] = Br;
        }
      }
      function Hr(i, [t, n, o, u]) {
        t = t.evaluate(i), n = n.evaluate(i), o = o.evaluate(i);
        const f = u ? u.evaluate(i) : 1, g = to(t, n, o, f);
        if (g) throw new nr(g);
        return new Ri(t / 255, n / 255, o / 255, f, !1);
      }
      function ao(i, t) {
        return i in t;
      }
      function lo(i, t) {
        const n = t[i];
        return n === void 0 ? null : n;
      }
      function Fn(i) {
        return { type: i };
      }
      function qs(i) {
        if (i instanceof Ni) return qs(i.boundExpression);
        if (i instanceof Br && i.name === "error" || i instanceof rs || i instanceof Nn || i instanceof as) return !1;
        const t = i instanceof _r || i instanceof sn;
        let n = !0;
        return i.eachChild((o) => {
          n = t ? n && qs(o) : n && o instanceof fn;
        }), !!n && Mr(i) && Vs(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function Mr(i) {
        if (i instanceof Br && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Nn || i instanceof as) return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !Mr(n) && (t = !1);
        }), t;
      }
      function co(i) {
        if (i instanceof Br && i.name === "feature-state") return !1;
        let t = !0;
        return i.eachChild((n) => {
          t && !co(n) && (t = !1);
        }), t;
      }
      function Vs(i, t) {
        if (i instanceof Br && t.indexOf(i.name) >= 0) return !1;
        let n = !0;
        return i.eachChild((o) => {
          n && !Vs(o, t) && (n = !1);
        }), n;
      }
      function Co(i) {
        return { result: "success", value: i };
      }
      function Xr(i) {
        return { result: "error", value: i };
      }
      function Ss(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function ml(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function Za(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function Ai(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function an(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function ls(i) {
        return i;
      }
      function Us(i, t) {
        const n = t.type === "color", o = i.stops && typeof i.stops[0][0] == "object", u = o || !(o || i.property !== void 0), f = i.type || (Za(t) ? "exponential" : "interval");
        if (n || t.type === "padding") {
          const D = n ? Ri.parse : nn.parse;
          (i = ei({}, i)).stops && (i.stops = i.stops.map((R) => [R[0], D(R[1])])), i.default = D(i.default ? i.default : t.default);
        }
        if (i.colorSpace && (g = i.colorSpace) !== "rgb" && g !== "hcl" && g !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var g;
        let P, L, E;
        if (f === "exponential") P = Rn;
        else if (f === "interval") P = $s;
        else if (f === "categorical") {
          P = As, L = /* @__PURE__ */ Object.create(null);
          for (const D of i.stops) L[D[0]] = D[1];
          E = typeof i.stops[0][0];
        } else {
          if (f !== "identity") throw new Error(`Unknown function type "${f}"`);
          P = Eo;
        }
        if (o) {
          const D = {}, R = [];
          for (let K = 0; K < i.stops.length; K++) {
            const re = i.stops[K], pe = re[0].zoom;
            D[pe] === void 0 && (D[pe] = { zoom: pe, type: i.type, property: i.property, default: i.default, stops: [] }, R.push(pe)), D[pe].stops.push([re[0].value, re[1]]);
          }
          const Z = [];
          for (const K of R) Z.push([D[K].zoom, Us(D[K], t)]);
          const H = { name: "linear" };
          return { kind: "composite", interpolationType: H, interpolationFactor: Xt.interpolationFactor.bind(void 0, H), zoomStops: Z.map((K) => K[0]), evaluate: ({ zoom: K }, re) => Rn({ stops: Z, base: i.base }, t, K).evaluate(K, re) };
        }
        if (u) {
          const D = f === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: D, interpolationFactor: Xt.interpolationFactor.bind(void 0, D), zoomStops: i.stops.map((R) => R[0]), evaluate: ({ zoom: R }) => P(i, t, R, L, E) };
        }
        return { kind: "source", evaluate(D, R) {
          const Z = R && R.properties ? R.properties[i.property] : void 0;
          return Z === void 0 ? ln(i.default, t.default) : P(i, t, Z, L, E);
        } };
      }
      function ln(i, t, n) {
        return i !== void 0 ? i : t !== void 0 ? t : n !== void 0 ? n : void 0;
      }
      function As(i, t, n, o, u) {
        return ln(typeof n === u ? o[n] : void 0, i.default, t.default);
      }
      function $s(i, t, n) {
        if (Ai(n) !== "number") return ln(i.default, t.default);
        const o = i.stops.length;
        if (o === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[o - 1][0]) return i.stops[o - 1][1];
        const u = Xo(i.stops.map((f) => f[0]), n);
        return i.stops[u][1];
      }
      function Rn(i, t, n) {
        const o = i.base !== void 0 ? i.base : 1;
        if (Ai(n) !== "number") return ln(i.default, t.default);
        const u = i.stops.length;
        if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
        const f = Xo(i.stops.map((D) => D[0]), n), g = function(D, R, Z, H) {
          const K = H - Z, re = D - Z;
          return K === 0 ? 0 : R === 1 ? re / K : (Math.pow(R, re) - 1) / (Math.pow(R, K) - 1);
        }(n, o, i.stops[f][0], i.stops[f + 1][0]), P = i.stops[f][1], L = i.stops[f + 1][1], E = Rr[t.type] || ls;
        return typeof P.evaluate == "function" ? { evaluate(...D) {
          const R = P.evaluate.apply(void 0, D), Z = L.evaluate.apply(void 0, D);
          if (R !== void 0 && Z !== void 0) return E(R, Z, g, i.colorSpace);
        } } : E(P, L, g, i.colorSpace);
      }
      function Eo(i, t, n) {
        switch (t.type) {
          case "color":
            n = Ri.parse(n);
            break;
          case "formatted":
            n = Zr.fromString(n.toString());
            break;
          case "resolvedImage":
            n = Gr.fromString(n.toString());
            break;
          case "padding":
            n = nn.parse(n);
            break;
          default:
            Ai(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
        }
        return ln(n, i.default, t.default);
      }
      Br.register(ws, { error: [{ kind: "error" }, [si], (i, [t]) => {
        throw new nr(t.evaluate(i));
      }], typeof: [si, [Et], (i, [t]) => W(mr(t.evaluate(i)))], "to-rgba": [$(ct, 4), [Ei], (i, [t]) => {
        const [n, o, u, f] = t.evaluate(i).rgb;
        return [255 * n, 255 * o, 255 * u, f];
      }], rgb: [Ei, [ct, ct, ct], Hr], rgba: [Ei, [ct, ct, ct, ct], Hr], has: { type: kt, overloads: [[[si], (i, [t]) => ao(t.evaluate(i), i.properties())], [[si, Pr], (i, [t, n]) => ao(t.evaluate(i), n.evaluate(i))]] }, get: { type: Et, overloads: [[[si], (i, [t]) => lo(t.evaluate(i), i.properties())], [[si, Pr], (i, [t, n]) => lo(t.evaluate(i), n.evaluate(i))]] }, "feature-state": [Et, [si], (i, [t]) => lo(t.evaluate(i), i.featureState || {})], properties: [Pr, [], (i) => i.properties()], "geometry-type": [si, [], (i) => i.geometryType()], id: [Et, [], (i) => i.id()], zoom: [ct, [], (i) => i.globals.zoom], "heatmap-density": [ct, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [ct, [], (i) => i.globals.lineProgress || 0], accumulated: [Et, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [ct, Fn(ct), (i, t) => {
        let n = 0;
        for (const o of t) n += o.evaluate(i);
        return n;
      }], "*": [ct, Fn(ct), (i, t) => {
        let n = 1;
        for (const o of t) n *= o.evaluate(i);
        return n;
      }], "-": { type: ct, overloads: [[[ct, ct], (i, [t, n]) => t.evaluate(i) - n.evaluate(i)], [[ct], (i, [t]) => -t.evaluate(i)]] }, "/": [ct, [ct, ct], (i, [t, n]) => t.evaluate(i) / n.evaluate(i)], "%": [ct, [ct, ct], (i, [t, n]) => t.evaluate(i) % n.evaluate(i)], ln2: [ct, [], () => Math.LN2], pi: [ct, [], () => Math.PI], e: [ct, [], () => Math.E], "^": [ct, [ct, ct], (i, [t, n]) => Math.pow(t.evaluate(i), n.evaluate(i))], sqrt: [ct, [ct], (i, [t]) => Math.sqrt(t.evaluate(i))], log10: [ct, [ct], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN10], ln: [ct, [ct], (i, [t]) => Math.log(t.evaluate(i))], log2: [ct, [ct], (i, [t]) => Math.log(t.evaluate(i)) / Math.LN2], sin: [ct, [ct], (i, [t]) => Math.sin(t.evaluate(i))], cos: [ct, [ct], (i, [t]) => Math.cos(t.evaluate(i))], tan: [ct, [ct], (i, [t]) => Math.tan(t.evaluate(i))], asin: [ct, [ct], (i, [t]) => Math.asin(t.evaluate(i))], acos: [ct, [ct], (i, [t]) => Math.acos(t.evaluate(i))], atan: [ct, [ct], (i, [t]) => Math.atan(t.evaluate(i))], min: [ct, Fn(ct), (i, t) => Math.min(...t.map((n) => n.evaluate(i)))], max: [ct, Fn(ct), (i, t) => Math.max(...t.map((n) => n.evaluate(i)))], abs: [ct, [ct], (i, [t]) => Math.abs(t.evaluate(i))], round: [ct, [ct], (i, [t]) => {
        const n = t.evaluate(i);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [ct, [ct], (i, [t]) => Math.floor(t.evaluate(i))], ceil: [ct, [ct], (i, [t]) => Math.ceil(t.evaluate(i))], "filter-==": [kt, [si, Et], (i, [t, n]) => i.properties()[t.value] === n.value], "filter-id-==": [kt, [Et], (i, [t]) => i.id() === t.value], "filter-type-==": [kt, [si], (i, [t]) => i.geometryType() === t.value], "filter-<": [kt, [si, Et], (i, [t, n]) => {
        const o = i.properties()[t.value], u = n.value;
        return typeof o == typeof u && o < u;
      }], "filter-id-<": [kt, [Et], (i, [t]) => {
        const n = i.id(), o = t.value;
        return typeof n == typeof o && n < o;
      }], "filter->": [kt, [si, Et], (i, [t, n]) => {
        const o = i.properties()[t.value], u = n.value;
        return typeof o == typeof u && o > u;
      }], "filter-id->": [kt, [Et], (i, [t]) => {
        const n = i.id(), o = t.value;
        return typeof n == typeof o && n > o;
      }], "filter-<=": [kt, [si, Et], (i, [t, n]) => {
        const o = i.properties()[t.value], u = n.value;
        return typeof o == typeof u && o <= u;
      }], "filter-id-<=": [kt, [Et], (i, [t]) => {
        const n = i.id(), o = t.value;
        return typeof n == typeof o && n <= o;
      }], "filter->=": [kt, [si, Et], (i, [t, n]) => {
        const o = i.properties()[t.value], u = n.value;
        return typeof o == typeof u && o >= u;
      }], "filter-id->=": [kt, [Et], (i, [t]) => {
        const n = i.id(), o = t.value;
        return typeof n == typeof o && n >= o;
      }], "filter-has": [kt, [Et], (i, [t]) => t.value in i.properties()], "filter-has-id": [kt, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [kt, [$(si)], (i, [t]) => t.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [kt, [$(Et)], (i, [t]) => t.value.indexOf(i.id()) >= 0], "filter-in-small": [kt, [si, $(Et)], (i, [t, n]) => n.value.indexOf(i.properties()[t.value]) >= 0], "filter-in-large": [kt, [si, $(Et)], (i, [t, n]) => function(o, u, f, g) {
        for (; f <= g; ) {
          const P = f + g >> 1;
          if (u[P] === o) return !0;
          u[P] > o ? g = P - 1 : f = P + 1;
        }
        return !1;
      }(i.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: kt, overloads: [[[kt, kt], (i, [t, n]) => t.evaluate(i) && n.evaluate(i)], [Fn(kt), (i, t) => {
        for (const n of t) if (!n.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: kt, overloads: [[[kt, kt], (i, [t, n]) => t.evaluate(i) || n.evaluate(i)], [Fn(kt), (i, t) => {
        for (const n of t) if (n.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [kt, [kt], (i, [t]) => !t.evaluate(i)], "is-supported-script": [kt, [si], (i, [t]) => {
        const n = i.globals && i.globals.isSupportedScript;
        return !n || n(t.evaluate(i));
      }], upcase: [si, [si], (i, [t]) => t.evaluate(i).toUpperCase()], downcase: [si, [si], (i, [t]) => t.evaluate(i).toLowerCase()], concat: [si, Fn(Et), (i, t) => t.map((n) => Ji(n.evaluate(i))).join("")], "resolved-locale": [si, [$r], (i, [t]) => t.evaluate(i).resolvedLocale()] });
      class ho {
        constructor(t, n) {
          var o;
          this.expression = t, this._warningHistory = {}, this._evaluator = new Fr(), this._defaultValue = n ? (o = n).type === "color" && an(o.default) ? new Ri(0, 0, 0, 0) : o.type === "color" ? Ri.parse(o.default) || null : o.type === "padding" ? nn.parse(o.default) || null : o.type === "variableAnchorOffsetCollection" ? pn.parse(o.default) || null : o.default === void 0 ? null : o.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
        }
        evaluateWithoutErrorHandling(t, n, o, u, f, g) {
          return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = g, this.expression.evaluate(this._evaluator);
        }
        evaluate(t, n, o, u, f, g) {
          this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u, this._evaluator.availableImages = f || null, this._evaluator.formattedSection = g || null;
          try {
            const P = this.expression.evaluate(this._evaluator);
            if (P == null || typeof P == "number" && P != P) return this._defaultValue;
            if (this._enumValues && !(P in this._enumValues)) throw new nr(`Expected value to be one of ${Object.keys(this._enumValues).map((L) => JSON.stringify(L)).join(", ")}, but found ${JSON.stringify(P)} instead.`);
            return P;
          } catch (P) {
            return this._warningHistory[P.message] || (this._warningHistory[P.message] = !0, typeof console < "u" && console.warn(P.message)), this._defaultValue;
          }
        }
      }
      function cs(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in ws;
      }
      function Yr(i, t) {
        const n = new ts(ws, qs, [], t ? function(u) {
          const f = { color: Ei, string: si, number: ct, enum: si, boolean: kt, formatted: qi, padding: Cr, resolvedImage: Er, variableAnchorOffsetCollection: ue };
          return u.type === "array" ? $(f[u.value] || Et, u.length) : f[u.type];
        }(t) : void 0), o = n.parse(i, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return o ? Co(new ho(o, t)) : Xr(n.errors);
      }
      class gn {
        constructor(t, n) {
          this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !co(n.expression);
        }
        evaluateWithoutErrorHandling(t, n, o, u, f, g) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, f, g);
        }
        evaluate(t, n, o, u, f, g) {
          return this._styleExpression.evaluate(t, n, o, u, f, g);
        }
      }
      class Bn {
        constructor(t, n, o, u) {
          this.kind = t, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = t !== "camera" && !co(n.expression), this.interpolationType = u;
        }
        evaluateWithoutErrorHandling(t, n, o, u, f, g) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, n, o, u, f, g);
        }
        evaluate(t, n, o, u, f, g) {
          return this._styleExpression.evaluate(t, n, o, u, f, g);
        }
        interpolationFactor(t, n, o) {
          return this.interpolationType ? Xt.interpolationFactor(this.interpolationType, t, n, o) : 0;
        }
      }
      function uo(i, t) {
        const n = Yr(i, t);
        if (n.result === "error") return n;
        const o = n.value.expression, u = Mr(o);
        if (!u && !Ss(t)) return Xr([new ai("", "data expressions not supported")]);
        const f = Vs(o, ["zoom"]);
        if (!f && !ml(t)) return Xr([new ai("", "zoom expressions not supported")]);
        const g = jn(o);
        return g || f ? g instanceof ai ? Xr([g]) : g instanceof Xt && !Za(t) ? Xr([new ai("", '"interpolate" expressions cannot be used with this property')]) : Co(g ? new Bn(u ? "camera" : "composite", n.value, g.labels, g instanceof Xt ? g.interpolation : void 0) : new gn(u ? "constant" : "source", n.value)) : Xr([new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class On {
        constructor(t, n) {
          this._parameters = t, this._specification = n, ei(this, Us(this._parameters, this._specification));
        }
        static deserialize(t) {
          return new On(t._parameters, t._specification);
        }
        static serialize(t) {
          return { _parameters: t._parameters, _specification: t._specification };
        }
      }
      function jn(i) {
        let t = null;
        if (i instanceof is) t = jn(i.result);
        else if (i instanceof Ko) {
          for (const n of i.args) if (t = jn(n), t) break;
        } else (i instanceof ro || i instanceof Xt) && i.input instanceof Br && i.input.name === "zoom" && (t = i);
        return t instanceof ai || i.eachChild((n) => {
          const o = jn(n);
          o instanceof ai ? t = o : !t && o ? t = new ai("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && o && t !== o && (t = new ai("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), t;
      }
      function po(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const t of i.slice(1)) if (!po(t) && typeof t != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const cn = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function hs(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        po(i) || (i = sr(i));
        const t = Yr(i, cn);
        if (t.result === "error") throw new Error(t.value.map((n) => `${n.key}: ${n.message}`).join(", "));
        return { filter: (n, o, u) => t.value.evaluate(n, o, {}, u), needGeometry: Zi(i) };
      }
      function Xi(i, t) {
        return i < t ? -1 : i > t ? 1 : 0;
      }
      function Zi(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let t = 1; t < i.length; t++) if (Zi(i[t])) return !0;
        return !1;
      }
      function sr(i) {
        if (!i) return !0;
        const t = i[0];
        return i.length <= 1 ? t !== "any" : t === "==" ? xr(i[1], i[2], "==") : t === "!=" ? br(xr(i[1], i[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? xr(i[1], i[2], t) : t === "any" ? (n = i.slice(1), ["any"].concat(n.map(sr))) : t === "all" ? ["all"].concat(i.slice(1).map(sr)) : t === "none" ? ["all"].concat(i.slice(1).map(sr).map(br)) : t === "in" ? Pn(i[1], i.slice(2)) : t === "!in" ? br(Pn(i[1], i.slice(2))) : t === "has" ? qn(i[1]) : t !== "!has" || br(qn(i[1]));
        var n;
      }
      function xr(i, t, n) {
        switch (i) {
          case "$type":
            return [`filter-type-${n}`, t];
          case "$id":
            return [`filter-id-${n}`, t];
          default:
            return [`filter-${n}`, i, t];
        }
      }
      function Pn(i, t) {
        if (t.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", t]];
          case "$id":
            return ["filter-id-in", ["literal", t]];
          default:
            return t.length > 200 && !t.some((n) => typeof n != typeof t[0]) ? ["filter-in-large", i, ["literal", t.sort(Xi)]] : ["filter-in-small", i, ["literal", t]];
        }
      }
      function qn(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function br(i) {
        return ["!", i];
      }
      function Ps(i) {
        const t = typeof i;
        if (t === "number" || t === "boolean" || t === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let u = "[";
          for (const f of i) u += `${Ps(f)},`;
          return `${u}]`;
        }
        const n = Object.keys(i).sort();
        let o = "{";
        for (let u = 0; u < n.length; u++) o += `${JSON.stringify(n[u])}:${Ps(i[n[u]])},`;
        return `${o}}`;
      }
      function Bl(i) {
        let t = "";
        for (const n of ui) t += `/${Ps(i[n])}`;
        return t;
      }
      function Ol(i) {
        const t = i.value;
        return t ? [new lt(i.key, t, "constants have been deprecated as of v8")] : [];
      }
      function ur(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function Vn(i) {
        if (Array.isArray(i)) return i.map(Vn);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const t = {};
          for (const n in i) t[n] = Vn(i[n]);
          return t;
        }
        return ur(i);
      }
      function yn(i) {
        const t = i.key, n = i.value, o = i.valueSpec || {}, u = i.objectElementValidators || {}, f = i.style, g = i.styleSpec, P = i.validateSpec;
        let L = [];
        const E = Ai(n);
        if (E !== "object") return [new lt(t, n, `object expected, ${E} found`)];
        for (const D in n) {
          const R = D.split(".")[0], Z = o[R] || o["*"];
          let H;
          if (u[R]) H = u[R];
          else if (o[R]) H = P;
          else if (u["*"]) H = u["*"];
          else {
            if (!o["*"]) {
              L.push(new lt(t, n[D], `unknown property "${D}"`));
              continue;
            }
            H = P;
          }
          L = L.concat(H({ key: (t && `${t}.`) + D, value: n[D], valueSpec: Z, style: f, styleSpec: g, object: n, objectKey: D, validateSpec: P }, n));
        }
        for (const D in o) u[D] || o[D].required && o[D].default === void 0 && n[D] === void 0 && L.push(new lt(t, n, `missing required property "${D}"`));
        return L;
      }
      function ha(i) {
        const t = i.value, n = i.valueSpec, o = i.style, u = i.styleSpec, f = i.key, g = i.arrayElementValidator || i.validateSpec;
        if (Ai(t) !== "array") return [new lt(f, t, `array expected, ${Ai(t)} found`)];
        if (n.length && t.length !== n.length) return [new lt(f, t, `array length ${n.length} expected, length ${t.length} found`)];
        if (n["min-length"] && t.length < n["min-length"]) return [new lt(f, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
        let P = { type: n.value, values: n.values };
        u.$version < 7 && (P.function = n.function), Ai(n.value) === "object" && (P = n.value);
        let L = [];
        for (let E = 0; E < t.length; E++) L = L.concat(g({ array: t, arrayIndex: E, value: t[E], valueSpec: P, validateSpec: i.validateSpec, style: o, styleSpec: u, key: `${f}[${E}]` }));
        return L;
      }
      function Ga(i) {
        const t = i.key, n = i.value, o = i.valueSpec;
        let u = Ai(n);
        return u === "number" && n != n && (u = "NaN"), u !== "number" ? [new lt(t, n, `number expected, ${u} found`)] : "minimum" in o && n < o.minimum ? [new lt(t, n, `${n} is less than the minimum value ${o.minimum}`)] : "maximum" in o && n > o.maximum ? [new lt(t, n, `${n} is greater than the maximum value ${o.maximum}`)] : [];
      }
      function Mo(i) {
        const t = i.valueSpec, n = ur(i.value.type);
        let o, u, f, g = {};
        const P = n !== "categorical" && i.value.property === void 0, L = !P, E = Ai(i.value.stops) === "array" && Ai(i.value.stops[0]) === "array" && Ai(i.value.stops[0][0]) === "object", D = yn({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(H) {
          if (n === "identity") return [new lt(H.key, H.value, 'identity function may not have a "stops" property')];
          let K = [];
          const re = H.value;
          return K = K.concat(ha({ key: H.key, value: re, valueSpec: H.valueSpec, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, arrayElementValidator: R })), Ai(re) === "array" && re.length === 0 && K.push(new lt(H.key, re, "array must have at least one stop")), K;
        }, default: function(H) {
          return H.validateSpec({ key: H.key, value: H.value, valueSpec: t, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec });
        } } });
        return n === "identity" && P && D.push(new lt(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || D.push(new lt(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !Za(i.valueSpec) && D.push(new lt(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (L && !Ss(i.valueSpec) ? D.push(new lt(i.key, i.value, "property functions not supported")) : P && !ml(i.valueSpec) && D.push(new lt(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !E || i.value.property !== void 0 || D.push(new lt(i.key, i.value, '"property" property is required')), D;
        function R(H) {
          let K = [];
          const re = H.value, pe = H.key;
          if (Ai(re) !== "array") return [new lt(pe, re, `array expected, ${Ai(re)} found`)];
          if (re.length !== 2) return [new lt(pe, re, `array length 2 expected, length ${re.length} found`)];
          if (E) {
            if (Ai(re[0]) !== "object") return [new lt(pe, re, `object expected, ${Ai(re[0])} found`)];
            if (re[0].zoom === void 0) return [new lt(pe, re, "object stop key must have zoom")];
            if (re[0].value === void 0) return [new lt(pe, re, "object stop key must have value")];
            if (f && f > ur(re[0].zoom)) return [new lt(pe, re[0].zoom, "stop zoom values must appear in ascending order")];
            ur(re[0].zoom) !== f && (f = ur(re[0].zoom), u = void 0, g = {}), K = K.concat(yn({ key: `${pe}[0]`, value: re[0], valueSpec: { zoom: {} }, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec, objectElementValidators: { zoom: Ga, value: Z } }));
          } else K = K.concat(Z({ key: `${pe}[0]`, value: re[0], valueSpec: {}, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }, re));
          return cs(Vn(re[1])) ? K.concat([new lt(`${pe}[1]`, re[1], "expressions are not allowed in function stops.")]) : K.concat(H.validateSpec({ key: `${pe}[1]`, value: re[1], valueSpec: t, validateSpec: H.validateSpec, style: H.style, styleSpec: H.styleSpec }));
        }
        function Z(H, K) {
          const re = Ai(H.value), pe = ur(H.value), xe = H.value !== null ? H.value : K;
          if (o) {
            if (re !== o) return [new lt(H.key, xe, `${re} stop domain type must match previous stop domain type ${o}`)];
          } else o = re;
          if (re !== "number" && re !== "string" && re !== "boolean") return [new lt(H.key, xe, "stop domain value must be a number, string, or boolean")];
          if (re !== "number" && n !== "categorical") {
            let Ne = `number expected, ${re} found`;
            return Ss(t) && n === void 0 && (Ne += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new lt(H.key, xe, Ne)];
          }
          return n !== "categorical" || re !== "number" || isFinite(pe) && Math.floor(pe) === pe ? n !== "categorical" && re === "number" && u !== void 0 && pe < u ? [new lt(H.key, xe, "stop domain values must appear in ascending order")] : (u = pe, n === "categorical" && pe in g ? [new lt(H.key, xe, "stop domain values must be unique")] : (g[pe] = !0, [])) : [new lt(H.key, xe, `integer expected, found ${pe}`)];
        }
      }
      function zr(i) {
        const t = (i.expressionContext === "property" ? uo : Yr)(Vn(i.value), i.valueSpec);
        if (t.result === "error") return t.value.map((o) => new lt(`${i.key}${o.key}`, i.value, o.message));
        const n = t.value.expression || t.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new lt(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !co(n)) return [new lt(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !co(n)) return [new lt(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!Vs(n, ["zoom", "feature-state"])) return [new lt(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !Mr(n)) return [new lt(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Lr(i) {
        const t = i.key, n = i.value, o = i.valueSpec, u = [];
        return Array.isArray(o.values) ? o.values.indexOf(ur(n)) === -1 && u.push(new lt(t, n, `expected one of [${o.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(o.values).indexOf(ur(n)) === -1 && u.push(new lt(t, n, `expected one of [${Object.keys(o.values).join(", ")}], ${JSON.stringify(n)} found`)), u;
      }
      function ua(i) {
        return po(Vn(i.value)) ? zr(ei({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : zo(i);
      }
      function zo(i) {
        const t = i.value, n = i.key;
        if (Ai(t) !== "array") return [new lt(n, t, `array expected, ${Ai(t)} found`)];
        const o = i.styleSpec;
        let u, f = [];
        if (t.length < 1) return [new lt(n, t, "filter array must have at least 1 element")];
        switch (f = f.concat(Lr({ key: `${n}[0]`, value: t[0], valueSpec: o.filter_operator, style: i.style, styleSpec: i.styleSpec })), ur(t[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 && ur(t[1]) === "$type" && f.push(new lt(n, t, `"$type" cannot be use with operator "${t[0]}"`));
          case "==":
          case "!=":
            t.length !== 3 && f.push(new lt(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t.length >= 2 && (u = Ai(t[1]), u !== "string" && f.push(new lt(`${n}[1]`, t[1], `string expected, ${u} found`)));
            for (let g = 2; g < t.length; g++) u = Ai(t[g]), ur(t[1]) === "$type" ? f = f.concat(Lr({ key: `${n}[${g}]`, value: t[g], valueSpec: o.geometry_type, style: i.style, styleSpec: i.styleSpec })) : u !== "string" && u !== "number" && u !== "boolean" && f.push(new lt(`${n}[${g}]`, t[g], `string, number, or boolean expected, ${u} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let g = 1; g < t.length; g++) f = f.concat(zo({ key: `${n}[${g}]`, value: t[g], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            u = Ai(t[1]), t.length !== 2 ? f.push(new lt(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : u !== "string" && f.push(new lt(`${n}[1]`, t[1], `string expected, ${u} found`));
        }
        return f;
      }
      function gl(i, t) {
        const n = i.key, o = i.validateSpec, u = i.style, f = i.styleSpec, g = i.value, P = i.objectKey, L = f[`${t}_${i.layerType}`];
        if (!L) return [];
        const E = P.match(/^(.*)-transition$/);
        if (t === "paint" && E && L[E[1]] && L[E[1]].transition) return o({ key: n, value: g, valueSpec: f.transition, style: u, styleSpec: f });
        const D = i.valueSpec || L[P];
        if (!D) return [new lt(n, g, `unknown property "${P}"`)];
        let R;
        if (Ai(g) === "string" && Ss(D) && !D.tokens && (R = /^{([^}]+)}$/.exec(g))) return [new lt(n, g, `"${P}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(R[1])} }\`.`)];
        const Z = [];
        return i.layerType === "symbol" && (P === "text-field" && u && !u.glyphs && Z.push(new lt(n, g, 'use of "text-field" requires a style "glyphs" property')), P === "text-font" && an(Vn(g)) && ur(g.type) === "identity" && Z.push(new lt(n, g, '"text-font" does not support identity functions'))), Z.concat(o({ key: i.key, value: g, valueSpec: D, style: u, styleSpec: f, expressionContext: "property", propertyType: t, propertyKey: P }));
      }
      function Do(i) {
        return gl(i, "paint");
      }
      function da(i) {
        return gl(i, "layout");
      }
      function Wa(i) {
        let t = [];
        const n = i.value, o = i.key, u = i.style, f = i.styleSpec;
        n.type || n.ref || t.push(new lt(o, n, 'either "type" or "ref" is required'));
        let g = ur(n.type);
        const P = ur(n.ref);
        if (n.id) {
          const L = ur(n.id);
          for (let E = 0; E < i.arrayIndex; E++) {
            const D = u.layers[E];
            ur(D.id) === L && t.push(new lt(o, n.id, `duplicate layer id "${n.id}", previously used at line ${D.id.__line__}`));
          }
        }
        if ("ref" in n) {
          let L;
          ["type", "source", "source-layer", "filter", "layout"].forEach((E) => {
            E in n && t.push(new lt(o, n[E], `"${E}" is prohibited for ref layers`));
          }), u.layers.forEach((E) => {
            ur(E.id) === P && (L = E);
          }), L ? L.ref ? t.push(new lt(o, n.ref, "ref cannot reference another ref layer")) : g = ur(L.type) : t.push(new lt(o, n.ref, `ref layer "${P}" not found`));
        } else if (g !== "background") if (n.source) {
          const L = u.sources && u.sources[n.source], E = L && ur(L.type);
          L ? E === "vector" && g === "raster" ? t.push(new lt(o, n.source, `layer "${n.id}" requires a raster source`)) : E !== "raster-dem" && g === "hillshade" ? t.push(new lt(o, n.source, `layer "${n.id}" requires a raster-dem source`)) : E === "raster" && g !== "raster" ? t.push(new lt(o, n.source, `layer "${n.id}" requires a vector source`)) : E !== "vector" || n["source-layer"] ? E === "raster-dem" && g !== "hillshade" ? t.push(new lt(o, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : g !== "line" || !n.paint || !n.paint["line-gradient"] || E === "geojson" && L.lineMetrics || t.push(new lt(o, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new lt(o, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new lt(o, n.source, `source "${n.source}" not found`));
        } else t.push(new lt(o, n, 'missing required property "source"'));
        return t = t.concat(yn({ key: o, value: n, valueSpec: f.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${o}.type`, value: n.type, valueSpec: f.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: n, objectKey: "type" }), filter: ua, layout: (L) => yn({ layer: n, key: L.key, value: L.value, style: L.style, styleSpec: L.styleSpec, validateSpec: L.validateSpec, objectElementValidators: { "*": (E) => da(ei({ layerType: g }, E)) } }), paint: (L) => yn({ layer: n, key: L.key, value: L.value, style: L.style, styleSpec: L.styleSpec, validateSpec: L.validateSpec, objectElementValidators: { "*": (E) => Do(ei({ layerType: g }, E)) } }) } })), t;
      }
      function fo(i) {
        const t = i.value, n = i.key, o = Ai(t);
        return o !== "string" ? [new lt(n, t, `string expected, ${o} found`)] : [];
      }
      const pa = { promoteId: function({ key: i, value: t }) {
        if (Ai(t) === "string") return fo({ key: i, value: t });
        {
          const n = [];
          for (const o in t) n.push(...fo({ key: `${i}.${o}`, value: t[o] }));
          return n;
        }
      } };
      function No(i) {
        const t = i.value, n = i.key, o = i.styleSpec, u = i.style, f = i.validateSpec;
        if (!t.type) return [new lt(n, t, '"type" is required')];
        const g = ur(t.type);
        let P;
        switch (g) {
          case "vector":
          case "raster":
            return P = yn({ key: n, value: t, valueSpec: o[`source_${g.replace("-", "_")}`], style: i.style, styleSpec: o, objectElementValidators: pa, validateSpec: f }), P;
          case "raster-dem":
            return P = function(L) {
              var E;
              const D = (E = L.sourceName) !== null && E !== void 0 ? E : "", R = L.value, Z = L.styleSpec, H = Z.source_raster_dem, K = L.style;
              let re = [];
              const pe = Ai(R);
              if (R === void 0) return re;
              if (pe !== "object") return re.push(new lt("source_raster_dem", R, `object expected, ${pe} found`)), re;
              const xe = ur(R.encoding) === "custom", Ne = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Te = L.value.encoding ? `"${L.value.encoding}"` : "Default";
              for (const ze in R) !xe && Ne.includes(ze) ? re.push(new lt(ze, R[ze], `In "${D}": "${ze}" is only valid when "encoding" is set to "custom". ${Te} encoding found`)) : H[ze] ? re = re.concat(L.validateSpec({ key: ze, value: R[ze], valueSpec: H[ze], validateSpec: L.validateSpec, style: K, styleSpec: Z })) : re.push(new lt(ze, R[ze], `unknown property "${ze}"`));
              return re;
            }({ sourceName: n, value: t, style: i.style, styleSpec: o, validateSpec: f }), P;
          case "geojson":
            if (P = yn({ key: n, value: t, valueSpec: o.source_geojson, style: u, styleSpec: o, validateSpec: f, objectElementValidators: pa }), t.cluster) for (const L in t.clusterProperties) {
              const [E, D] = t.clusterProperties[L], R = typeof E == "string" ? [E, ["accumulated"], ["get", L]] : E;
              P.push(...zr({ key: `${n}.${L}.map`, value: D, validateSpec: f, expressionContext: "cluster-map" })), P.push(...zr({ key: `${n}.${L}.reduce`, value: R, validateSpec: f, expressionContext: "cluster-reduce" }));
            }
            return P;
          case "video":
            return yn({ key: n, value: t, valueSpec: o.source_video, style: u, validateSpec: f, styleSpec: o });
          case "image":
            return yn({ key: n, value: t, valueSpec: o.source_image, style: u, validateSpec: f, styleSpec: o });
          case "canvas":
            return [new lt(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Lr({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: u, validateSpec: f, styleSpec: o });
        }
      }
      function fa(i) {
        const t = i.value, n = i.styleSpec, o = n.light, u = i.style;
        let f = [];
        const g = Ai(t);
        if (t === void 0) return f;
        if (g !== "object") return f = f.concat([new lt("light", t, `object expected, ${g} found`)]), f;
        for (const P in t) {
          const L = P.match(/^(.*)-transition$/);
          f = f.concat(L && o[L[1]] && o[L[1]].transition ? i.validateSpec({ key: P, value: t[P], valueSpec: n.transition, validateSpec: i.validateSpec, style: u, styleSpec: n }) : o[P] ? i.validateSpec({ key: P, value: t[P], valueSpec: o[P], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new lt(P, t[P], `unknown property "${P}"`)]);
        }
        return f;
      }
      function Ha(i) {
        const t = i.value, n = i.styleSpec, o = n.sky, u = i.style, f = Ai(t);
        if (t === void 0) return [];
        if (f !== "object") return [new lt("sky", t, `object expected, ${f} found`)];
        let g = [];
        for (const P in t) g = g.concat(o[P] ? i.validateSpec({ key: P, value: t[P], valueSpec: o[P], style: u, styleSpec: n }) : [new lt(P, t[P], `unknown property "${P}"`)]);
        return g;
      }
      function jl(i) {
        const t = i.value, n = i.styleSpec, o = n.terrain, u = i.style;
        let f = [];
        const g = Ai(t);
        if (t === void 0) return f;
        if (g !== "object") return f = f.concat([new lt("terrain", t, `object expected, ${g} found`)]), f;
        for (const P in t) f = f.concat(o[P] ? i.validateSpec({ key: P, value: t[P], valueSpec: o[P], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new lt(P, t[P], `unknown property "${P}"`)]);
        return f;
      }
      function ql(i) {
        let t = [];
        const n = i.value, o = i.key;
        if (Array.isArray(n)) {
          const u = [], f = [];
          for (const g in n) n[g].id && u.includes(n[g].id) && t.push(new lt(o, n, `all the sprites' ids must be unique, but ${n[g].id} is duplicated`)), u.push(n[g].id), n[g].url && f.includes(n[g].url) && t.push(new lt(o, n, `all the sprites' URLs must be unique, but ${n[g].url} is duplicated`)), f.push(n[g].url), t = t.concat(yn({ key: `${o}[${g}]`, value: n[g], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return t;
        }
        return fo({ key: o, value: n });
      }
      const Xa = { "*": () => [], array: ha, boolean: function(i) {
        const t = i.value, n = i.key, o = Ai(t);
        return o !== "boolean" ? [new lt(n, t, `boolean expected, ${o} found`)] : [];
      }, number: Ga, color: function(i) {
        const t = i.key, n = i.value, o = Ai(n);
        return o !== "string" ? [new lt(t, n, `color expected, ${o} found`)] : Ri.parse(String(n)) ? [] : [new lt(t, n, `color expected, "${n}" found`)];
      }, constants: Ol, enum: Lr, filter: ua, function: Mo, layer: Wa, object: yn, source: No, light: fa, sky: Ha, terrain: jl, projection: function(i) {
        const t = i.value, n = i.styleSpec, o = n.projection, u = i.style, f = Ai(t);
        if (t === void 0) return [];
        if (f !== "object") return [new lt("projection", t, `object expected, ${f} found`)];
        let g = [];
        for (const P in t) g = g.concat(o[P] ? i.validateSpec({ key: P, value: t[P], valueSpec: o[P], style: u, styleSpec: n }) : [new lt(P, t[P], `unknown property "${P}"`)]);
        return g;
      }, string: fo, formatted: function(i) {
        return fo(i).length === 0 ? [] : zr(i);
      }, resolvedImage: function(i) {
        return fo(i).length === 0 ? [] : zr(i);
      }, padding: function(i) {
        const t = i.key, n = i.value;
        if (Ai(n) === "array") {
          if (n.length < 1 || n.length > 4) return [new lt(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
          const o = { type: "number" };
          let u = [];
          for (let f = 0; f < n.length; f++) u = u.concat(i.validateSpec({ key: `${t}[${f}]`, value: n[f], validateSpec: i.validateSpec, valueSpec: o }));
          return u;
        }
        return Ga({ key: t, value: n, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const t = i.key, n = i.value, o = Ai(n), u = i.styleSpec;
        if (o !== "array" || n.length < 1 || n.length % 2 != 0) return [new lt(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let f = [];
        for (let g = 0; g < n.length; g += 2) f = f.concat(Lr({ key: `${t}[${g}]`, value: n[g], valueSpec: u.layout_symbol["text-anchor"] })), f = f.concat(ha({ key: `${t}[${g + 1}]`, value: n[g + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: u }));
        return f;
      }, sprite: ql };
      function ma(i) {
        const t = i.value, n = i.valueSpec, o = i.styleSpec;
        return i.validateSpec = ma, n.expression && an(ur(t)) ? Mo(i) : n.expression && cs(Vn(t)) ? zr(i) : n.type && Xa[n.type] ? Xa[n.type](i) : yn(ei({}, i, { valueSpec: n.type ? o[n.type] : n }));
      }
      function ac(i) {
        const t = i.value, n = i.key, o = fo(i);
        return o.length || (t.indexOf("{fontstack}") === -1 && o.push(new lt(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && o.push(new lt(n, t, '"glyphs" url must include a "{range}" token'))), o;
      }
      function Un(i, t = Y) {
        let n = [];
        return n = n.concat(ma({ key: "", value: i, valueSpec: t.$root, styleSpec: t, style: i, validateSpec: ma, objectElementValidators: { glyphs: ac, "*": () => [] } })), i.constants && (n = n.concat(Ol({ key: "constants", value: i.constants, style: i, styleSpec: t, validateSpec: ma }))), Vl(n);
      }
      function Is(i) {
        return function(t) {
          return i({ ...t, validateSpec: ma });
        };
      }
      function Vl(i) {
        return [].concat(i).sort((t, n) => t.line - n.line);
      }
      function In(i) {
        return function(...t) {
          return Vl(i.apply(this, t));
        };
      }
      Un.source = In(Is(No)), Un.sprite = In(Is(ql)), Un.glyphs = In(Is(ac)), Un.light = In(Is(fa)), Un.sky = In(Is(Ha)), Un.terrain = In(Is(jl)), Un.layer = In(Is(Wa)), Un.filter = In(Is(ua)), Un.paintProperty = In(Is(Do)), Un.layoutProperty = In(Is(da));
      const Zs = Un, Ya = Zs.light, Vc = Zs.sky, lc = Zs.paintProperty, Ul = Zs.layoutProperty;
      function $l(i, t) {
        let n = !1;
        if (t && t.length) for (const o of t) i.fire(new Qt(new Error(o.message))), n = !0;
        return n;
      }
      class ga {
        constructor(t, n, o) {
          const u = this.cells = [];
          if (t instanceof ArrayBuffer) {
            this.arrayBuffer = t;
            const g = new Int32Array(this.arrayBuffer);
            t = g[0], this.d = (n = g[1]) + 2 * (o = g[2]);
            for (let L = 0; L < this.d * this.d; L++) {
              const E = g[3 + L], D = g[3 + L + 1];
              u.push(E === D ? null : g.subarray(E, D));
            }
            const P = g[3 + u.length + 1];
            this.keys = g.subarray(g[3 + u.length], P), this.bboxes = g.subarray(P), this.insert = this._insertReadonly;
          } else {
            this.d = n + 2 * o;
            for (let g = 0; g < this.d * this.d; g++) u.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = n, this.extent = t, this.padding = o, this.scale = n / t, this.uid = 0;
          const f = o / n * t;
          this.min = -f, this.max = t + f;
        }
        insert(t, n, o, u, f) {
          this._forEachCell(n, o, u, f, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(f);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t, n, o, u, f, g) {
          this.cells[f].push(g);
        }
        query(t, n, o, u, f) {
          const g = this.min, P = this.max;
          if (t <= g && n <= g && P <= o && P <= u && !f) return Array.prototype.slice.call(this.keys);
          {
            const L = [];
            return this._forEachCell(t, n, o, u, this._queryCell, L, {}, f), L;
          }
        }
        _queryCell(t, n, o, u, f, g, P, L) {
          const E = this.cells[f];
          if (E !== null) {
            const D = this.keys, R = this.bboxes;
            for (let Z = 0; Z < E.length; Z++) {
              const H = E[Z];
              if (P[H] === void 0) {
                const K = 4 * H;
                (L ? L(R[K + 0], R[K + 1], R[K + 2], R[K + 3]) : t <= R[K + 2] && n <= R[K + 3] && o >= R[K + 0] && u >= R[K + 1]) ? (P[H] = !0, g.push(D[H])) : P[H] = !1;
              }
            }
          }
        }
        _forEachCell(t, n, o, u, f, g, P, L) {
          const E = this._convertToCellCoord(t), D = this._convertToCellCoord(n), R = this._convertToCellCoord(o), Z = this._convertToCellCoord(u);
          for (let H = E; H <= R; H++) for (let K = D; K <= Z; K++) {
            const re = this.d * K + H;
            if ((!L || L(this._convertFromCellCoord(H), this._convertFromCellCoord(K), this._convertFromCellCoord(H + 1), this._convertFromCellCoord(K + 1))) && f.call(this, t, n, o, u, re, g, P, L)) return;
          }
        }
        _convertFromCellCoord(t) {
          return (t - this.padding) / this.scale;
        }
        _convertToCellCoord(t) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const t = this.cells, n = 3 + this.cells.length + 1 + 1;
          let o = 0;
          for (let g = 0; g < this.cells.length; g++) o += this.cells[g].length;
          const u = new Int32Array(n + o + this.keys.length + this.bboxes.length);
          u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
          let f = n;
          for (let g = 0; g < t.length; g++) {
            const P = t[g];
            u[3 + g] = f, u.set(P, f), f += P.length;
          }
          return u[3 + t.length] = f, u.set(this.keys, f), f += this.keys.length, u[3 + t.length + 1] = f, u.set(this.bboxes, f), f += this.bboxes.length, u.buffer;
        }
        static serialize(t, n) {
          const o = t.toArrayBuffer();
          return n && n.push(o), { buffer: o };
        }
        static deserialize(t) {
          return new ga(t.buffer);
        }
      }
      const $n = {};
      function Nt(i, t, n = {}) {
        if ($n[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(t, "_classRegistryKey", { value: i, writeable: !1 }), $n[i] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
      }
      Nt("Object", Object), Nt("TransferableGridIndex", ga), Nt("Color", Ri), Nt("Error", Error), Nt("AJAXError", Oe), Nt("ResolvedImage", Gr), Nt("StylePropertyFunction", On), Nt("StyleExpression", ho, { omit: ["_evaluator"] }), Nt("ZoomDependentExpression", Bn), Nt("ZoomConstantExpression", gn), Nt("CompoundExpression", Br, { omit: ["_evaluate"] });
      for (const i in ws) ws[i]._classRegistryKey || Nt(`Expression_${i}`, ws[i]);
      function us(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function Ln(i) {
        return i.$name || i.constructor._classRegistryKey;
      }
      function Ls(i) {
        return !function(t) {
          if (t === null || typeof t != "object") return !1;
          const n = Ln(t);
          return !(!n || n === "Object");
        }(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || us(i) || Je(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
      }
      function ya(i, t) {
        if (Ls(i)) return (us(i) || Je(i)) && t && t.push(i), ArrayBuffer.isView(i) && t && t.push(i.buffer), i instanceof ImageData && t && t.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const f = [];
          for (const g of i) f.push(ya(g, t));
          return f;
        }
        if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
        const n = Ln(i);
        if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
        if (!$n[n]) throw new Error(`${n} is not registered.`);
        const { klass: o } = $n[n], u = o.serialize ? o.serialize(i, t) : {};
        if (o.serialize) {
          if (t && u === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const f in i) {
            if (!i.hasOwnProperty(f) || $n[n].omit.indexOf(f) >= 0) continue;
            const g = i[f];
            u[f] = $n[n].shallow.indexOf(f) >= 0 ? g : ya(g, t);
          }
          i instanceof Error && (u.message = i.message);
        }
        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return n !== "Object" && (u.$name = n), u;
      }
      function Fo(i) {
        if (Ls(i)) return i;
        if (Array.isArray(i)) return i.map(Fo);
        if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
        const t = Ln(i) || "Object";
        if (!$n[t]) throw new Error(`can't deserialize unregistered class ${t}`);
        const { klass: n } = $n[t];
        if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
        if (n.deserialize) return n.deserialize(i);
        const o = Object.create(n.prototype);
        for (const u of Object.keys(i)) {
          if (u === "$name") continue;
          const f = i[u];
          o[u] = $n[t].shallow.indexOf(u) >= 0 ? f : Fo(f);
        }
        return o;
      }
      class Ts {
        constructor() {
          this.first = !0;
        }
        update(t, n) {
          const o = Math.floor(t);
          return this.first ? (this.first = !1, this.lastIntegerZoom = o, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = o, !0) : (this.lastFloorZoom > o ? (this.lastIntegerZoom = o + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < o && (this.lastIntegerZoom = o, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = o, !0));
        }
      }
      const fi = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, Khmer: (i) => i >= 6016 && i <= 6143, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Katakana: (i) => i >= 12448 && i <= 12543, Kanbun: (i) => i >= 12688 && i <= 12703, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "Private Use Area": (i) => i >= 57344 && i <= 63743, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function Zl(i) {
        for (const t of i) if (Wl(t.charCodeAt(0))) return !0;
        return !1;
      }
      function Uc(i) {
        for (const t of i) if (!Ro(t.charCodeAt(0))) return !1;
        return !0;
      }
      function yl(i) {
        const t = i.map((n) => {
          try {
            return new RegExp(`\\p{sc=${n}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((n) => n);
        return new RegExp(t.join("|"), "u");
      }
      const cc = yl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Ro(i) {
        return !cc.test(String.fromCodePoint(i));
      }
      const Gl = yl(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function Wl(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(fi["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || fi["CJK Compatibility"](i) || fi["CJK Strokes"](i) || !(!fi["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || fi["Enclosed CJK Letters and Months"](i) || fi["Ideographic Description Characters"](i) || fi.Kanbun(i) || fi.Katakana(i) && i !== 12540 || !(!fi["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!fi["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || fi["Vertical Forms"](i) || fi["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || Gl.test(String.fromCodePoint(i)))));
      }
      function Ja(i) {
        return !(Wl(i) || function(t) {
          return !!(fi["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || fi["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || fi["Letterlike Symbols"](t) || fi["Number Forms"](t) || fi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || fi["Control Pictures"](t) && t !== 9251 || fi["Optical Character Recognition"](t) || fi["Enclosed Alphanumerics"](t) || fi["Geometric Shapes"](t) || fi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || fi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || fi["CJK Symbols and Punctuation"](t) || fi.Katakana(t) || fi["Private Use Area"](t) || fi["CJK Compatibility Forms"](t) || fi["Small Form Variants"](t) || fi["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
        }(i));
      }
      const _l = yl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Bo(i) {
        return _l.test(String.fromCodePoint(i));
      }
      function Hl(i, t) {
        return !(!t && Bo(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || fi.Khmer(i));
      }
      function hc(i) {
        for (const t of i) if (Bo(t.charCodeAt(0))) return !0;
        return !1;
      }
      const Tn = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class Gi {
        constructor(t, n) {
          this.zoom = t, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ts(), this.transition = {});
        }
        isSupportedScript(t) {
          return function(n, o) {
            for (const u of n) if (!Hl(u.charCodeAt(0), o)) return !1;
            return !0;
          }(t, Tn.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t = this.zoom, n = t - Math.floor(t), o = this.crossFadingFactor();
          return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * o } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - o) * n };
        }
      }
      class _a {
        constructor(t, n) {
          this.property = t, this.value = n, this.expression = function(o, u) {
            if (an(o)) return new On(o, u);
            if (cs(o)) {
              const f = uo(o, u);
              if (f.result === "error") throw new Error(f.value.map((g) => `${g.key}: ${g.message}`).join(", "));
              return f.value;
            }
            {
              let f = o;
              return u.type === "color" && typeof o == "string" ? f = Ri.parse(o) : u.type !== "padding" || typeof o != "number" && !Array.isArray(o) ? u.type === "variableAnchorOffsetCollection" && Array.isArray(o) && (f = pn.parse(o)) : f = nn.parse(o), { kind: "constant", evaluate: () => f };
            }
          }(n === void 0 ? t.specification.default : n, t.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t, n, o) {
          return this.property.possiblyEvaluate(this, t, n, o);
        }
      }
      class vl {
        constructor(t) {
          this.property = t, this.value = new _a(t, void 0);
        }
        transitioned(t, n) {
          return new uc(this.property, this.value, n, Be({}, t.transition, this.transition), t.now);
        }
        untransitioned() {
          return new uc(this.property, this.value, null, {}, 0);
        }
      }
      class xl {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
        }
        getValue(t) {
          return oe(this._values[t].value.value);
        }
        setValue(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vl(this._values[t].property)), this._values[t].value = new _a(this._values[t].property, n === null ? void 0 : oe(n));
        }
        getTransition(t) {
          return oe(this._values[t].transition);
        }
        setTransition(t, n) {
          Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new vl(this._values[t].property)), this._values[t].transition = oe(n) || void 0;
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (t[n] = o);
            const u = this.getTransition(n);
            u !== void 0 && (t[`${n}-transition`] = u);
          }
          return t;
        }
        transitioned(t, n) {
          const o = new Ka(this._properties);
          for (const u of Object.keys(this._values)) o._values[u] = this._values[u].transitioned(t, n._values[u]);
          return o;
        }
        untransitioned() {
          const t = new Ka(this._properties);
          for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
          return t;
        }
      }
      class uc {
        constructor(t, n, o, u, f) {
          this.property = t, this.value = n, this.begin = f + u.delay || 0, this.end = this.begin + u.duration || 0, t.specification.transition && (u.delay || u.duration) && (this.prior = o);
        }
        possiblyEvaluate(t, n, o) {
          const u = t.now || 0, f = this.value.possiblyEvaluate(t, n, o), g = this.prior;
          if (g) {
            if (u > this.end) return this.prior = null, f;
            if (this.value.isDataDriven()) return this.prior = null, f;
            if (u < this.begin) return g.possiblyEvaluate(t, n, o);
            {
              const P = (u - this.begin) / (this.end - this.begin);
              return this.property.interpolate(g.possiblyEvaluate(t, n, o), f, function(L) {
                if (L <= 0) return 0;
                if (L >= 1) return 1;
                const E = L * L, D = E * L;
                return 4 * (L < 0.5 ? D : 3 * (L - E) + D - 0.75);
              }(P));
            }
          }
          return f;
        }
      }
      class Ka {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t, n, o) {
          const u = new mo(this._properties);
          for (const f of Object.keys(this._values)) u._values[f] = this._values[f].possiblyEvaluate(t, n, o);
          return u;
        }
        hasTransition() {
          for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class Qa {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPropertyValues);
        }
        hasValue(t) {
          return this._values[t].value !== void 0;
        }
        getValue(t) {
          return oe(this._values[t].value);
        }
        setValue(t, n) {
          this._values[t] = new _a(this._values[t].property, n === null ? void 0 : oe(n));
        }
        serialize() {
          const t = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (t[n] = o);
          }
          return t;
        }
        possiblyEvaluate(t, n, o) {
          const u = new mo(this._properties);
          for (const f of Object.keys(this._values)) u._values[f] = this._values[f].possiblyEvaluate(t, n, o);
          return u;
        }
      }
      class ds {
        constructor(t, n, o) {
          this.property = t, this.value = n, this.parameters = o;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t) {
          return this.value.kind === "constant" ? this.value.value : t;
        }
        evaluate(t, n, o, u) {
          return this.property.evaluate(this.value, this.parameters, t, n, o, u);
        }
      }
      class mo {
        constructor(t) {
          this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
        }
        get(t) {
          return this._values[t];
        }
      }
      class jt {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n) {
          if (t.isDataDriven()) throw new Error("Value should not be data driven");
          return t.expression.evaluate(n);
        }
        interpolate(t, n, o) {
          const u = Rr[this.specification.type];
          return u ? u(t, n, o) : t;
        }
      }
      class Kt {
        constructor(t, n) {
          this.specification = t, this.overrides = n;
        }
        possiblyEvaluate(t, n, o, u) {
          return new ds(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, o, u) } : t.expression, n);
        }
        interpolate(t, n, o) {
          if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
          if (t.value.value === void 0 || n.value.value === void 0) return new ds(this, { kind: "constant", value: void 0 }, t.parameters);
          const u = Rr[this.specification.type];
          if (u) {
            const f = u(t.value.value, n.value.value, o);
            return new ds(this, { kind: "constant", value: f }, t.parameters);
          }
          return t;
        }
        evaluate(t, n, o, u, f, g) {
          return t.kind === "constant" ? t.value : t.evaluate(n, o, u, f, g);
        }
      }
      class el extends Kt {
        possiblyEvaluate(t, n, o, u) {
          if (t.value === void 0) return new ds(this, { kind: "constant", value: void 0 }, n);
          if (t.expression.kind === "constant") {
            const f = t.expression.evaluate(n, null, {}, o, u), g = t.property.specification.type === "resolvedImage" && typeof f != "string" ? f.name : f, P = this._calculate(g, g, g, n);
            return new ds(this, { kind: "constant", value: P }, n);
          }
          if (t.expression.kind === "camera") {
            const f = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
            return new ds(this, { kind: "constant", value: f }, n);
          }
          return new ds(this, t.expression, n);
        }
        evaluate(t, n, o, u, f, g) {
          if (t.kind === "source") {
            const P = t.evaluate(n, o, u, f, g);
            return this._calculate(P, P, P, n);
          }
          return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, o, u), t.evaluate({ zoom: Math.floor(n.zoom) }, o, u), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, o, u), n) : t.value;
        }
        _calculate(t, n, o, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: o, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class m {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, o, u) {
          if (t.value !== void 0) {
            if (t.expression.kind === "constant") {
              const f = t.expression.evaluate(n, null, {}, o, u);
              return this._calculate(f, f, f, n);
            }
            return this._calculate(t.expression.evaluate(new Gi(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Gi(Math.floor(n.zoom), n)), t.expression.evaluate(new Gi(Math.floor(n.zoom + 1), n)), n);
          }
        }
        _calculate(t, n, o, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: o, to: n };
        }
        interpolate(t) {
          return t;
        }
      }
      class A {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, n, o, u) {
          return !!t.expression.evaluate(n, null, {}, o, u);
        }
        interpolate() {
          return !1;
        }
      }
      class a {
        constructor(t) {
          this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const n in t) {
            const o = t[n];
            o.specification.overridable && this.overridableProperties.push(n);
            const u = this.defaultPropertyValues[n] = new _a(o, void 0), f = this.defaultTransitionablePropertyValues[n] = new vl(o);
            this.defaultTransitioningPropertyValues[n] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = u.possiblyEvaluate({});
          }
        }
      }
      Nt("DataDrivenProperty", Kt), Nt("DataConstantProperty", jt), Nt("CrossFadedDataDrivenProperty", el), Nt("CrossFadedProperty", m), Nt("ColorRampProperty", A);
      const e = "-transition";
      class r extends Qe {
        constructor(t, n) {
          if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), n.layout && (this._unevaluatedLayout = new Qa(n.layout)), n.paint)) {
            this._transitionablePaint = new xl(n.paint);
            for (const o in t.paint) this.setPaintProperty(o, t.paint[o], { validate: !1 });
            for (const o in t.layout) this.setLayoutProperty(o, t.layout[o], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mo(n.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t) {
          return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
        }
        setLayoutProperty(t, n, o = {}) {
          n != null && this._validate(Ul, `layers.${this.id}.layout.${t}`, t, n, o) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
        }
        getPaintProperty(t) {
          return t.endsWith(e) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, n, o = {}) {
          if (n != null && this._validate(lc, `layers.${this.id}.paint.${t}`, t, n, o)) return !1;
          if (t.endsWith(e)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1;
          {
            const u = this._transitionablePaint._values[t], f = u.property.specification["property-type"] === "cross-faded-data-driven", g = u.value.isDataDriven(), P = u.value;
            this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
            const L = this._transitionablePaint._values[t].value;
            return L.isDataDriven() || g || f || this._handleOverridablePaintPropertyUpdate(t, P, L);
          }
        }
        _handleSpecialPaintPropertyUpdate(t) {
        }
        _handleOverridablePaintPropertyUpdate(t, n, o) {
          return !1;
        }
        isHidden(t) {
          return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, n) {
          t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
        }
        serialize() {
          const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), it(t, (n, o) => !(n === void 0 || o === "layout" && !Object.keys(n).length || o === "paint" && !Object.keys(n).length));
        }
        _validate(t, n, o, u, f = {}) {
          return (!f || f.validate !== !1) && $l(this, t.call(Zs, { key: n, layerType: this.type, objectKey: o, value: u, styleSpec: Y, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const t in this.paint._values) {
            const n = this.paint.get(t);
            if (n instanceof ds && Ss(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const s = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class l {
        constructor(t, n) {
          this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class h {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(t, n) {
          return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
        }
        static deserialize(t) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          this.reserve(t), this.length = t;
        }
        reserve(t) {
          if (t > this.capacity) {
            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function y(i, t = 1) {
        let n = 0, o = 0;
        return { members: i.map((u) => {
          const f = s[u.type].BYTES_PER_ELEMENT, g = n = b(n, Math.max(t, f)), P = u.components || 1;
          return o = Math.max(o, f), n += f * P, { name: u.name, type: u.type, components: P, offset: g };
        }), size: b(n, Math.max(o, t)), alignment: t };
      }
      function b(i, t) {
        return Math.ceil(i / t) * t;
      }
      class I extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, n);
        }
        emplace(t, n, o) {
          const u = 2 * t;
          return this.int16[u + 0] = n, this.int16[u + 1] = o, t;
        }
      }
      I.prototype.bytesPerElement = 4, Nt("StructArrayLayout2i4", I);
      class k extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n, o);
        }
        emplace(t, n, o, u) {
          const f = 3 * t;
          return this.int16[f + 0] = n, this.int16[f + 1] = o, this.int16[f + 2] = u, t;
        }
      }
      k.prototype.bytesPerElement = 6, Nt("StructArrayLayout3i6", k);
      class z extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, o, u);
        }
        emplace(t, n, o, u, f) {
          const g = 4 * t;
          return this.int16[g + 0] = n, this.int16[g + 1] = o, this.int16[g + 2] = u, this.int16[g + 3] = f, t;
        }
      }
      z.prototype.bytesPerElement = 8, Nt("StructArrayLayout4i8", z);
      class M extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, t, n, o, u, f, g);
        }
        emplace(t, n, o, u, f, g, P) {
          const L = 6 * t;
          return this.int16[L + 0] = n, this.int16[L + 1] = o, this.int16[L + 2] = u, this.int16[L + 3] = f, this.int16[L + 4] = g, this.int16[L + 5] = P, t;
        }
      }
      M.prototype.bytesPerElement = 12, Nt("StructArrayLayout2i4i12", M);
      class O extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, t, n, o, u, f, g);
        }
        emplace(t, n, o, u, f, g, P) {
          const L = 4 * t, E = 8 * t;
          return this.int16[L + 0] = n, this.int16[L + 1] = o, this.uint8[E + 4] = u, this.uint8[E + 5] = f, this.uint8[E + 6] = g, this.uint8[E + 7] = P, t;
        }
      }
      O.prototype.bytesPerElement = 8, Nt("StructArrayLayout2i4ub8", O);
      class U extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, n);
        }
        emplace(t, n, o) {
          const u = 2 * t;
          return this.float32[u + 0] = n, this.float32[u + 1] = o, t;
        }
      }
      U.prototype.bytesPerElement = 8, Nt("StructArrayLayout2f8", U);
      class B extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g, P, L, E, D) {
          const R = this.length;
          return this.resize(R + 1), this.emplace(R, t, n, o, u, f, g, P, L, E, D);
        }
        emplace(t, n, o, u, f, g, P, L, E, D, R) {
          const Z = 10 * t;
          return this.uint16[Z + 0] = n, this.uint16[Z + 1] = o, this.uint16[Z + 2] = u, this.uint16[Z + 3] = f, this.uint16[Z + 4] = g, this.uint16[Z + 5] = P, this.uint16[Z + 6] = L, this.uint16[Z + 7] = E, this.uint16[Z + 8] = D, this.uint16[Z + 9] = R, t;
        }
      }
      B.prototype.bytesPerElement = 20, Nt("StructArrayLayout10ui20", B);
      class G extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g, P, L, E, D, R, Z) {
          const H = this.length;
          return this.resize(H + 1), this.emplace(H, t, n, o, u, f, g, P, L, E, D, R, Z);
        }
        emplace(t, n, o, u, f, g, P, L, E, D, R, Z, H) {
          const K = 12 * t;
          return this.int16[K + 0] = n, this.int16[K + 1] = o, this.int16[K + 2] = u, this.int16[K + 3] = f, this.uint16[K + 4] = g, this.uint16[K + 5] = P, this.uint16[K + 6] = L, this.uint16[K + 7] = E, this.int16[K + 8] = D, this.int16[K + 9] = R, this.int16[K + 10] = Z, this.int16[K + 11] = H, t;
        }
      }
      G.prototype.bytesPerElement = 24, Nt("StructArrayLayout4i4ui4i24", G);
      class Q extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n, o);
        }
        emplace(t, n, o, u) {
          const f = 3 * t;
          return this.float32[f + 0] = n, this.float32[f + 1] = o, this.float32[f + 2] = u, t;
        }
      }
      Q.prototype.bytesPerElement = 12, Nt("StructArrayLayout3f12", Q);
      class ee extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint32[1 * t + 0] = n, t;
        }
      }
      ee.prototype.bytesPerElement = 4, Nt("StructArrayLayout1ul4", ee);
      class ne extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g, P, L, E) {
          const D = this.length;
          return this.resize(D + 1), this.emplace(D, t, n, o, u, f, g, P, L, E);
        }
        emplace(t, n, o, u, f, g, P, L, E, D) {
          const R = 10 * t, Z = 5 * t;
          return this.int16[R + 0] = n, this.int16[R + 1] = o, this.int16[R + 2] = u, this.int16[R + 3] = f, this.int16[R + 4] = g, this.int16[R + 5] = P, this.uint32[Z + 3] = L, this.uint16[R + 8] = E, this.uint16[R + 9] = D, t;
        }
      }
      ne.prototype.bytesPerElement = 20, Nt("StructArrayLayout6i1ul2ui20", ne);
      class ie extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, t, n, o, u, f, g);
        }
        emplace(t, n, o, u, f, g, P) {
          const L = 6 * t;
          return this.int16[L + 0] = n, this.int16[L + 1] = o, this.int16[L + 2] = u, this.int16[L + 3] = f, this.int16[L + 4] = g, this.int16[L + 5] = P, t;
        }
      }
      ie.prototype.bytesPerElement = 12, Nt("StructArrayLayout2i2i2i12", ie);
      class he extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f) {
          const g = this.length;
          return this.resize(g + 1), this.emplace(g, t, n, o, u, f);
        }
        emplace(t, n, o, u, f, g) {
          const P = 4 * t, L = 8 * t;
          return this.float32[P + 0] = n, this.float32[P + 1] = o, this.float32[P + 2] = u, this.int16[L + 6] = f, this.int16[L + 7] = g, t;
        }
      }
      he.prototype.bytesPerElement = 16, Nt("StructArrayLayout2f1f2i16", he);
      class we extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, t, n, o, u, f, g);
        }
        emplace(t, n, o, u, f, g, P) {
          const L = 16 * t, E = 4 * t, D = 8 * t;
          return this.uint8[L + 0] = n, this.uint8[L + 1] = o, this.float32[E + 1] = u, this.float32[E + 2] = f, this.int16[D + 6] = g, this.int16[D + 7] = P, t;
        }
      }
      we.prototype.bytesPerElement = 16, Nt("StructArrayLayout2ub2f2i16", we);
      class ve extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n, o);
        }
        emplace(t, n, o, u) {
          const f = 3 * t;
          return this.uint16[f + 0] = n, this.uint16[f + 1] = o, this.uint16[f + 2] = u, t;
        }
      }
      ve.prototype.bytesPerElement = 6, Nt("StructArrayLayout3ui6", ve);
      class Ue extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe) {
          const Ne = this.length;
          return this.resize(Ne + 1), this.emplace(Ne, t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe);
        }
        emplace(t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe, Ne) {
          const Te = 24 * t, ze = 12 * t, Ge = 48 * t;
          return this.int16[Te + 0] = n, this.int16[Te + 1] = o, this.uint16[Te + 2] = u, this.uint16[Te + 3] = f, this.uint32[ze + 2] = g, this.uint32[ze + 3] = P, this.uint32[ze + 4] = L, this.uint16[Te + 10] = E, this.uint16[Te + 11] = D, this.uint16[Te + 12] = R, this.float32[ze + 7] = Z, this.float32[ze + 8] = H, this.uint8[Ge + 36] = K, this.uint8[Ge + 37] = re, this.uint8[Ge + 38] = pe, this.uint32[ze + 10] = xe, this.int16[Te + 22] = Ne, t;
        }
      }
      Ue.prototype.bytesPerElement = 48, Nt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ue);
      class nt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe, Ne, Te, ze, Ge, gt, Ct, ri, Lt, At, Ut, Bt) {
          const Ft = this.length;
          return this.resize(Ft + 1), this.emplace(Ft, t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe, Ne, Te, ze, Ge, gt, Ct, ri, Lt, At, Ut, Bt);
        }
        emplace(t, n, o, u, f, g, P, L, E, D, R, Z, H, K, re, pe, xe, Ne, Te, ze, Ge, gt, Ct, ri, Lt, At, Ut, Bt, Ft) {
          const st = 32 * t, Wt = 16 * t;
          return this.int16[st + 0] = n, this.int16[st + 1] = o, this.int16[st + 2] = u, this.int16[st + 3] = f, this.int16[st + 4] = g, this.int16[st + 5] = P, this.int16[st + 6] = L, this.int16[st + 7] = E, this.uint16[st + 8] = D, this.uint16[st + 9] = R, this.uint16[st + 10] = Z, this.uint16[st + 11] = H, this.uint16[st + 12] = K, this.uint16[st + 13] = re, this.uint16[st + 14] = pe, this.uint16[st + 15] = xe, this.uint16[st + 16] = Ne, this.uint16[st + 17] = Te, this.uint16[st + 18] = ze, this.uint16[st + 19] = Ge, this.uint16[st + 20] = gt, this.uint16[st + 21] = Ct, this.uint16[st + 22] = ri, this.uint32[Wt + 12] = Lt, this.float32[Wt + 13] = At, this.float32[Wt + 14] = Ut, this.uint16[st + 30] = Bt, this.uint16[st + 31] = Ft, t;
        }
      }
      nt.prototype.bytesPerElement = 64, Nt("StructArrayLayout8i15ui1ul2f2ui64", nt);
      class ht extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.float32[1 * t + 0] = n, t;
        }
      }
      ht.prototype.bytesPerElement = 4, Nt("StructArrayLayout1f4", ht);
      class pt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n, o);
        }
        emplace(t, n, o, u) {
          const f = 3 * t;
          return this.uint16[6 * t + 0] = n, this.float32[f + 1] = o, this.float32[f + 2] = u, t;
        }
      }
      pt.prototype.bytesPerElement = 12, Nt("StructArrayLayout1ui2f12", pt);
      class dt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, t, n, o);
        }
        emplace(t, n, o, u) {
          const f = 4 * t;
          return this.uint32[2 * t + 0] = n, this.uint16[f + 2] = o, this.uint16[f + 3] = u, t;
        }
      }
      dt.prototype.bytesPerElement = 8, Nt("StructArrayLayout1ul2ui8", dt);
      class ut extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, n);
        }
        emplace(t, n, o) {
          const u = 2 * t;
          return this.uint16[u + 0] = n, this.uint16[u + 1] = o, t;
        }
      }
      ut.prototype.bytesPerElement = 4, Nt("StructArrayLayout2ui4", ut);
      class ft extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t);
        }
        emplace(t, n) {
          return this.uint16[1 * t + 0] = n, t;
        }
      }
      ft.prototype.bytesPerElement = 2, Nt("StructArrayLayout1ui2", ft);
      class Ot extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t, n, o, u) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, n, o, u);
        }
        emplace(t, n, o, u, f) {
          const g = 4 * t;
          return this.float32[g + 0] = n, this.float32[g + 1] = o, this.float32[g + 2] = u, this.float32[g + 3] = f, t;
        }
      }
      Ot.prototype.bytesPerElement = 16, Nt("StructArrayLayout4f16", Ot);
      class _t extends l {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new j(this.anchorPointX, this.anchorPointY);
        }
      }
      _t.prototype.size = 20;
      class vt extends ne {
        get(t) {
          return new _t(this, t);
        }
      }
      Nt("CollisionBoxArray", vt);
      class Vt extends l {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 37] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 38] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 10] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Vt.prototype.size = 48;
      class ni extends Ue {
        get(t) {
          return new Vt(this, t);
        }
      }
      Nt("PlacedSymbolArray", ni);
      class ii extends l {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 12] = t;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      ii.prototype.size = 64;
      class ci extends nt {
        get(t) {
          return new ii(this, t);
        }
      }
      Nt("SymbolInstanceArray", ci);
      class xi extends ht {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      Nt("GlyphOffsetArray", xi);
      class Bi extends k {
        getx(t) {
          return this.int16[3 * t + 0];
        }
        gety(t) {
          return this.int16[3 * t + 1];
        }
        gettileUnitDistanceFromAnchor(t) {
          return this.int16[3 * t + 2];
        }
      }
      Nt("SymbolLineVertexArray", Bi);
      class Qi extends l {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Qi.prototype.size = 12;
      class zi extends pt {
        get(t) {
          return new Qi(this, t);
        }
      }
      Nt("TextAnchorOffsetArray", zi);
      class dr extends l {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      dr.prototype.size = 8;
      class Oi extends dt {
        get(t) {
          return new dr(this, t);
        }
      }
      Nt("FeatureIndexArray", Oi);
      class or extends I {
      }
      class wr extends I {
      }
      class hn extends I {
      }
      class kn extends M {
      }
      class er extends O {
      }
      class go extends U {
      }
      class Cn extends B {
      }
      class tl extends G {
      }
      class va extends Q {
      }
      class Jr extends ee {
      }
      class un extends ie {
      }
      class Dr extends we {
      }
      class Kr extends ve {
      }
      class yr extends ut {
      }
      const Or = y([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Qr } = Or;
      class Ti {
        constructor(t = []) {
          this.segments = t;
        }
        prepareSegment(t, n, o, u) {
          let f = this.segments[this.segments.length - 1];
          return t > Ti.MAX_VERTEX_ARRAY_LENGTH && Le(`Max vertices per segment is ${Ti.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!f || f.vertexLength + t > Ti.MAX_VERTEX_ARRAY_LENGTH || f.sortKey !== u) && (f = { vertexOffset: n.length, primitiveOffset: o.length, vertexLength: 0, primitiveLength: 0 }, u !== void 0 && (f.sortKey = u), this.segments.push(f)), f;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
        }
        static simpleSegment(t, n, o, u) {
          return new Ti([{ vertexOffset: t, primitiveOffset: n, vertexLength: o, primitiveLength: u, vaos: {}, sortKey: 0 }]);
        }
      }
      function ks(i, t) {
        return 256 * (i = $e(Math.floor(i), 0, 255)) + $e(Math.floor(t), 0, 255);
      }
      Ti.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Nt("SegmentVector", Ti);
      const yo = y([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Gs = { exports: {} }, xa = { exports: {} };
      xa.exports = function(i, t) {
        var n, o, u, f, g, P, L, E;
        for (o = i.length - (n = 3 & i.length), u = t, g = 3432918353, P = 461845907, E = 0; E < o; ) L = 255 & i.charCodeAt(E) | (255 & i.charCodeAt(++E)) << 8 | (255 & i.charCodeAt(++E)) << 16 | (255 & i.charCodeAt(++E)) << 24, ++E, u = 27492 + (65535 & (f = 5 * (65535 & (u = (u ^= L = (65535 & (L = (L = (65535 & L) * g + (((L >>> 16) * g & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295) << 13 | u >>> 19)) + ((5 * (u >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (f >>> 16) & 65535) << 16);
        switch (L = 0, n) {
          case 3:
            L ^= (255 & i.charCodeAt(E + 2)) << 16;
          case 2:
            L ^= (255 & i.charCodeAt(E + 1)) << 8;
          case 1:
            u ^= L = (65535 & (L = (L = (65535 & (L ^= 255 & i.charCodeAt(E))) * g + (((L >>> 16) * g & 65535) << 16) & 4294967295) << 15 | L >>> 17)) * P + (((L >>> 16) * P & 65535) << 16) & 4294967295;
        }
        return u ^= i.length, u = 2246822507 * (65535 & (u ^= u >>> 16)) + ((2246822507 * (u >>> 16) & 65535) << 16) & 4294967295, u = 3266489909 * (65535 & (u ^= u >>> 13)) + ((3266489909 * (u >>> 16) & 65535) << 16) & 4294967295, (u ^= u >>> 16) >>> 0;
      };
      var $c = xa.exports, dc = { exports: {} };
      dc.exports = function(i, t) {
        for (var n, o = i.length, u = t ^ o, f = 0; o >= 4; ) n = 1540483477 * (65535 & (n = 255 & i.charCodeAt(f) | (255 & i.charCodeAt(++f)) << 8 | (255 & i.charCodeAt(++f)) << 16 | (255 & i.charCodeAt(++f)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), u = 1540483477 * (65535 & u) + ((1540483477 * (u >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), o -= 4, ++f;
        switch (o) {
          case 3:
            u ^= (255 & i.charCodeAt(f + 2)) << 16;
          case 2:
            u ^= (255 & i.charCodeAt(f + 1)) << 8;
          case 1:
            u = 1540483477 * (65535 & (u ^= 255 & i.charCodeAt(f))) + ((1540483477 * (u >>> 16) & 65535) << 16);
        }
        return u = 1540483477 * (65535 & (u ^= u >>> 13)) + ((1540483477 * (u >>> 16) & 65535) << 16), (u ^= u >>> 15) >>> 0;
      };
      var Cs = $c, Ws = dc.exports;
      Gs.exports = Cs, Gs.exports.murmur3 = Cs, Gs.exports.murmur2 = Ws;
      var bl = C(Gs.exports);
      class il {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(t, n, o, u) {
          this.ids.push(wl(t)), this.positions.push(n, o, u);
        }
        getPositions(t) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const n = wl(t);
          let o = 0, u = this.ids.length - 1;
          for (; o < u; ) {
            const g = o + u >> 1;
            this.ids[g] >= n ? u = g : o = g + 1;
          }
          const f = [];
          for (; this.ids[o] === n; ) f.push({ index: this.positions[3 * o], start: this.positions[3 * o + 1], end: this.positions[3 * o + 2] }), o++;
          return f;
        }
        static serialize(t, n) {
          const o = new Float64Array(t.ids), u = new Uint32Array(t.positions);
          return rl(o, u, 0, o.length - 1), n && n.push(o.buffer, u.buffer), { ids: o, positions: u };
        }
        static deserialize(t) {
          const n = new il();
          return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n;
        }
      }
      function wl(i) {
        const t = +i;
        return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : bl(String(i));
      }
      function rl(i, t, n, o) {
        for (; n < o; ) {
          const u = i[n + o >> 1];
          let f = n - 1, g = o + 1;
          for (; ; ) {
            do
              f++;
            while (i[f] < u);
            do
              g--;
            while (i[g] > u);
            if (f >= g) break;
            Hs(i, f, g), Hs(t, 3 * f, 3 * g), Hs(t, 3 * f + 1, 3 * g + 1), Hs(t, 3 * f + 2, 3 * g + 2);
          }
          g - n < o - g ? (rl(i, t, n, g), n = g + 1) : (rl(i, t, g + 1, o), o = g);
        }
      }
      function Hs(i, t, n) {
        const o = i[t];
        i[t] = i[n], i[n] = o;
      }
      Nt("FeaturePositionMap", il);
      class ba {
        constructor(t, n) {
          this.gl = t.gl, this.location = n;
        }
      }
      class Xl extends ba {
        constructor(t, n) {
          super(t, n), this.current = 0;
        }
        set(t) {
          this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
        }
      }
      class Yl extends ba {
        constructor(t, n) {
          super(t, n), this.current = [0, 0, 0, 0];
        }
        set(t) {
          t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
        }
      }
      class pc extends ba {
        constructor(t, n) {
          super(t, n), this.current = Ri.transparent;
        }
        set(t) {
          t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
        }
      }
      const Jl = new Float32Array(16);
      function fc(i) {
        return [ks(255 * i.r, 255 * i.g), ks(255 * i.b, 255 * i.a)];
      }
      class Kl {
        constructor(t, n, o) {
          this.value = t, this.uniformNames = n.map((u) => `u_${u}`), this.type = o;
        }
        setUniform(t, n, o) {
          t.set(o.constantOr(this.value));
        }
        getBinding(t, n, o) {
          return this.type === "color" ? new pc(t, n) : new Xl(t, n);
        }
      }
      class Oo {
        constructor(t, n) {
          this.uniformNames = n.map((o) => `u_${o}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t, n) {
          this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
        }
        setUniform(t, n, o, u) {
          const f = u === "u_pattern_to" ? this.patternTo : u === "u_pattern_from" ? this.patternFrom : u === "u_pixel_ratio_to" ? this.pixelRatioTo : u === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          f && t.set(f);
        }
        getBinding(t, n, o) {
          return o.substr(0, 9) === "u_pattern" ? new Yl(t, n) : new Xl(t, n);
        }
      }
      class _o {
        constructor(t, n, o, u) {
          this.expression = t, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((f) => ({ name: `a_${f}`, type: "Float32", components: o === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u();
        }
        populatePaintArray(t, n, o, u, f) {
          const g = this.paintVertexArray.length, P = this.expression.evaluate(new Gi(0), n, {}, u, [], f);
          this.paintVertexArray.resize(t), this._setPaintValue(g, t, P);
        }
        updatePaintArray(t, n, o, u) {
          const f = this.expression.evaluate({ zoom: 0 }, o, u);
          this._setPaintValue(t, n, f);
        }
        _setPaintValue(t, n, o) {
          if (this.type === "color") {
            const u = fc(o);
            for (let f = t; f < n; f++) this.paintVertexArray.emplace(f, u[0], u[1]);
          } else {
            for (let u = t; u < n; u++) this.paintVertexArray.emplace(u, o);
            this.maxValue = Math.max(this.maxValue, Math.abs(o));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class ps {
        constructor(t, n, o, u, f, g) {
          this.expression = t, this.uniformNames = n.map((P) => `u_${P}_t`), this.type = o, this.useIntegerZoom = u, this.zoom = f, this.maxValue = 0, this.paintVertexAttributes = n.map((P) => ({ name: `a_${P}`, type: "Float32", components: o === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new g();
        }
        populatePaintArray(t, n, o, u, f) {
          const g = this.expression.evaluate(new Gi(this.zoom), n, {}, u, [], f), P = this.expression.evaluate(new Gi(this.zoom + 1), n, {}, u, [], f), L = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValue(L, t, g, P);
        }
        updatePaintArray(t, n, o, u) {
          const f = this.expression.evaluate({ zoom: this.zoom }, o, u), g = this.expression.evaluate({ zoom: this.zoom + 1 }, o, u);
          this._setPaintValue(t, n, f, g);
        }
        _setPaintValue(t, n, o, u) {
          if (this.type === "color") {
            const f = fc(o), g = fc(u);
            for (let P = t; P < n; P++) this.paintVertexArray.emplace(P, f[0], f[1], g[0], g[1]);
          } else {
            for (let f = t; f < n; f++) this.paintVertexArray.emplace(f, o, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, n) {
          const o = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, u = $e(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
          t.set(u);
        }
        getBinding(t, n, o) {
          return new Xl(t, n);
        }
      }
      class En {
        constructor(t, n, o, u, f, g) {
          this.expression = t, this.type = n, this.useIntegerZoom = o, this.zoom = u, this.layerId = g, this.zoomInPaintVertexArray = new f(), this.zoomOutPaintVertexArray = new f();
        }
        populatePaintArray(t, n, o) {
          const u = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(u, t, n.patterns && n.patterns[this.layerId], o);
        }
        updatePaintArray(t, n, o, u, f) {
          this._setPaintValues(t, n, o.patterns && o.patterns[this.layerId], f);
        }
        _setPaintValues(t, n, o, u) {
          if (!u || !o) return;
          const { min: f, mid: g, max: P } = o, L = u[f], E = u[g], D = u[P];
          if (L && E && D) for (let R = t; R < n; R++) this.zoomInPaintVertexArray.emplace(R, E.tl[0], E.tl[1], E.br[0], E.br[1], L.tl[0], L.tl[1], L.br[0], L.br[1], E.pixelRatio, L.pixelRatio), this.zoomOutPaintVertexArray.emplace(R, E.tl[0], E.tl[1], E.br[0], E.br[1], D.tl[0], D.tl[1], D.br[0], D.br[1], E.pixelRatio, D.pixelRatio);
        }
        upload(t) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, yo.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, yo.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Zc {
        constructor(t, n, o) {
          this.binders = {}, this._buffers = [];
          const u = [];
          for (const f in t.paint._values) {
            if (!o(f)) continue;
            const g = t.paint.get(f);
            if (!(g instanceof ds && Ss(g.property.specification))) continue;
            const P = au(f, t.type), L = g.value, E = g.property.specification.type, D = g.property.useIntegerZoom, R = g.property.specification["property-type"], Z = R === "cross-faded" || R === "cross-faded-data-driven";
            if (L.kind === "constant") this.binders[f] = Z ? new Oo(L.value, P) : new Kl(L.value, P, E), u.push(`/u_${f}`);
            else if (L.kind === "source" || Z) {
              const H = Gc(f, E, "source");
              this.binders[f] = Z ? new En(L, E, D, n, H, t.id) : new _o(L, P, E, H), u.push(`/a_${f}`);
            } else {
              const H = Gc(f, E, "composite");
              this.binders[f] = new ps(L, P, E, D, n, H), u.push(`/z_${f}`);
            }
          }
          this.cacheKey = u.sort().join("");
        }
        getMaxValue(t) {
          const n = this.binders[t];
          return n instanceof _o || n instanceof ps ? n.maxValue : 0;
        }
        populatePaintArrays(t, n, o, u, f) {
          for (const g in this.binders) {
            const P = this.binders[g];
            (P instanceof _o || P instanceof ps || P instanceof En) && P.populatePaintArray(t, n, o, u, f);
          }
        }
        setConstantPatternPositions(t, n) {
          for (const o in this.binders) {
            const u = this.binders[o];
            u instanceof Oo && u.setConstantPatternPositions(t, n);
          }
        }
        updatePaintArrays(t, n, o, u, f) {
          let g = !1;
          for (const P in t) {
            const L = n.getPositions(P);
            for (const E of L) {
              const D = o.feature(E.index);
              for (const R in this.binders) {
                const Z = this.binders[R];
                if ((Z instanceof _o || Z instanceof ps || Z instanceof En) && Z.expression.isStateDependent === !0) {
                  const H = u.paint.get(R);
                  Z.expression = H.value, Z.updatePaintArray(E.start, E.end, D, t[P], f), g = !0;
                }
              }
            }
          }
          return g;
        }
        defines() {
          const t = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof Kl || o instanceof Oo) && t.push(...o.uniformNames.map((u) => `#define HAS_UNIFORM_${u}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof _o || o instanceof ps) for (let u = 0; u < o.paintVertexAttributes.length; u++) t.push(o.paintVertexAttributes[u].name);
            else if (o instanceof En) for (let u = 0; u < yo.members.length; u++) t.push(yo.members[u].name);
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof Kl || o instanceof Oo || o instanceof ps) for (const u of o.uniformNames) t.push(u);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t, n) {
          const o = [];
          for (const u in this.binders) {
            const f = this.binders[u];
            if (f instanceof Kl || f instanceof Oo || f instanceof ps) {
              for (const g of f.uniformNames) if (n[g]) {
                const P = f.getBinding(t, n[g], g);
                o.push({ name: g, property: u, binding: P });
              }
            }
          }
          return o;
        }
        setUniforms(t, n, o, u) {
          for (const { name: f, property: g, binding: P } of n) this.binders[g].setUniform(P, u, o.get(g), f);
        }
        updatePaintBuffers(t) {
          this._buffers = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (t && o instanceof En) {
              const u = t.fromScale === 2 ? o.zoomInPaintVertexBuffer : o.zoomOutPaintVertexBuffer;
              u && this._buffers.push(u);
            } else (o instanceof _o || o instanceof ps) && o.paintVertexBuffer && this._buffers.push(o.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof _o || o instanceof ps || o instanceof En) && o.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const n = this.binders[t];
            (n instanceof _o || n instanceof ps || n instanceof En) && n.destroy();
          }
        }
      }
      class wa {
        constructor(t, n, o = () => !0) {
          this.programConfigurations = {};
          for (const u of t) this.programConfigurations[u.id] = new Zc(u, n, o);
          this.needsUpload = !1, this._featureMap = new il(), this._bufferOffset = 0;
        }
        populatePaintArrays(t, n, o, u, f, g) {
          for (const P in this.programConfigurations) this.programConfigurations[P].populatePaintArrays(t, n, u, f, g);
          n.id !== void 0 && this._featureMap.add(n.id, o, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
        }
        updatePaintArrays(t, n, o, u) {
          for (const f of o) this.needsUpload = this.programConfigurations[f.id].updatePaintArrays(t, this._featureMap, n, f, u) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
        }
      }
      function au(i, t) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${t}-`, "").replace(/-/g, "_")];
      }
      function Gc(i, t, n) {
        const o = { color: { source: U, composite: Ot }, number: { source: ht, composite: U } }, u = function(f) {
          return { "line-pattern": { source: Cn, composite: Cn }, "fill-pattern": { source: Cn, composite: Cn }, "fill-extrusion-pattern": { source: Cn, composite: Cn } }[f];
        }(i);
        return u && u[n] || o[t][n];
      }
      Nt("ConstantBinder", Kl), Nt("CrossFadedConstantBinder", Oo), Nt("SourceExpressionBinder", _o), Nt("CrossFadedCompositeBinder", En), Nt("CompositeExpressionBinder", ps), Nt("ProgramConfiguration", Zc, { omit: ["_buffers"] }), Nt("ProgramConfigurationSet", wa);
      const tr = 8192, Wc = Math.pow(2, 14) - 1, Hc = -Wc - 1;
      function nl(i) {
        const t = tr / i.extent, n = i.loadGeometry();
        for (let o = 0; o < n.length; o++) {
          const u = n[o];
          for (let f = 0; f < u.length; f++) {
            const g = u[f], P = Math.round(g.x * t), L = Math.round(g.y * t);
            g.x = $e(P, Hc, Wc), g.y = $e(L, Hc, Wc), (P < g.x || P > g.x + 1 || L < g.y || L > g.y + 1) && Le("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return n;
      }
      function Sa(i, t) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: t ? nl(i) : [] };
      }
      function mc(i, t, n, o, u) {
        i.emplaceBack(2 * t + (o + 1) / 2, 2 * n + (u + 1) / 2);
      }
      class sl {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new wr(), this.indexArray = new Kr(), this.segments = new Ti(), this.programConfigurations = new wa(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, o) {
          const u = this.layers[0], f = [];
          let g = null, P = !1;
          u.type === "circle" && (g = u.layout.get("circle-sort-key"), P = !g.isConstant());
          for (const { feature: L, id: E, index: D, sourceLayerIndex: R } of t) {
            const Z = this.layers[0]._featureFilter.needGeometry, H = Sa(L, Z);
            if (!this.layers[0]._featureFilter.filter(new Gi(this.zoom), H, o)) continue;
            const K = P ? g.evaluate(H, {}, o) : void 0, re = { id: E, properties: L.properties, type: L.type, sourceLayerIndex: R, index: D, geometry: Z ? H.geometry : nl(L), patterns: {}, sortKey: K };
            f.push(re);
          }
          P && f.sort((L, E) => L.sortKey - E.sortKey);
          for (const L of f) {
            const { geometry: E, index: D, sourceLayerIndex: R } = L, Z = t[D].feature;
            this.addFeature(L, E, D, o), n.featureIndex.insert(Z, E, D, R, this.index);
          }
        }
        update(t, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Qr), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t, n, o, u) {
          for (const f of n) for (const g of f) {
            const P = g.x, L = g.y;
            if (P < 0 || P >= tr || L < 0 || L >= tr) continue;
            const E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), D = E.vertexLength;
            mc(this.layoutVertexArray, P, L, -1, -1), mc(this.layoutVertexArray, P, L, 1, -1), mc(this.layoutVertexArray, P, L, 1, 1), mc(this.layoutVertexArray, P, L, -1, 1), this.indexArray.emplaceBack(D, D + 1, D + 2), this.indexArray.emplaceBack(D, D + 3, D + 2), E.vertexLength += 4, E.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, {}, u);
        }
      }
      function gc(i, t) {
        for (let n = 0; n < i.length; n++) if (Pa(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (Pa(i, t[n])) return !0;
        return !!xo(i, t);
      }
      function yc(i, t, n) {
        return !!Pa(i, t) || !!Ql(t, i, n);
      }
      function vo(i, t) {
        if (i.length === 1) return xh(t, i[0]);
        for (let n = 0; n < t.length; n++) {
          const o = t[n];
          for (let u = 0; u < o.length; u++) if (Pa(i, o[u])) return !0;
        }
        for (let n = 0; n < i.length; n++) if (xh(t, i[n])) return !0;
        for (let n = 0; n < t.length; n++) if (xo(i, t[n])) return !0;
        return !1;
      }
      function Aa(i, t, n) {
        if (i.length > 1) {
          if (xo(i, t)) return !0;
          for (let o = 0; o < t.length; o++) if (Ql(t[o], i, n)) return !0;
        }
        for (let o = 0; o < i.length; o++) if (Ql(i[o], t, n)) return !0;
        return !1;
      }
      function xo(i, t) {
        if (i.length === 0 || t.length === 0) return !1;
        for (let n = 0; n < i.length - 1; n++) {
          const o = i[n], u = i[n + 1];
          for (let f = 0; f < t.length - 1; f++) if (_c(o, u, t[f], t[f + 1])) return !0;
        }
        return !1;
      }
      function _c(i, t, n, o) {
        return Se(i, n, o) !== Se(t, n, o) && Se(i, t, n) !== Se(i, t, o);
      }
      function Ql(i, t, n) {
        const o = n * n;
        if (t.length === 1) return i.distSqr(t[0]) < o;
        for (let u = 1; u < t.length; u++) if (Xc(i, t[u - 1], t[u]) < o) return !0;
        return !1;
      }
      function Xc(i, t, n) {
        const o = t.distSqr(n);
        if (o === 0) return i.distSqr(t);
        const u = ((i.x - t.x) * (n.x - t.x) + (i.y - t.y) * (n.y - t.y)) / o;
        return i.distSqr(u < 0 ? t : u > 1 ? n : n.sub(t)._mult(u)._add(t));
      }
      function xh(i, t) {
        let n, o, u, f = !1;
        for (let g = 0; g < i.length; g++) {
          n = i[g];
          for (let P = 0, L = n.length - 1; P < n.length; L = P++) o = n[P], u = n[L], o.y > t.y != u.y > t.y && t.x < (u.x - o.x) * (t.y - o.y) / (u.y - o.y) + o.x && (f = !f);
        }
        return f;
      }
      function Pa(i, t) {
        let n = !1;
        for (let o = 0, u = i.length - 1; o < i.length; u = o++) {
          const f = i[o], g = i[u];
          f.y > t.y != g.y > t.y && t.x < (g.x - f.x) * (t.y - f.y) / (g.y - f.y) + f.x && (n = !n);
        }
        return n;
      }
      function Yc(i, t, n) {
        const o = n[0], u = n[2];
        if (i.x < o.x && t.x < o.x || i.x > u.x && t.x > u.x || i.y < o.y && t.y < o.y || i.y > u.y && t.y > u.y) return !1;
        const f = Se(i, t, n[0]);
        return f !== Se(i, t, n[1]) || f !== Se(i, t, n[2]) || f !== Se(i, t, n[3]);
      }
      function Jc(i, t, n) {
        const o = t.paint.get(i).value;
        return o.kind === "constant" ? o.value : n.programConfigurations.get(t.id).getMaxValue(i);
      }
      function bh(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function wh(i, t, n, o, u) {
        if (!t[0] && !t[1]) return i;
        const f = j.convert(t)._mult(u);
        n === "viewport" && f._rotate(-o);
        const g = [];
        for (let P = 0; P < i.length; P++) g.push(i[P].sub(f));
        return g;
      }
      let vd, xd;
      Nt("CircleBucket", sl, { omit: ["layers"] });
      var em = { get paint() {
        return xd = xd || new a({ "circle-radius": new Kt(Y.paint_circle["circle-radius"]), "circle-color": new Kt(Y.paint_circle["circle-color"]), "circle-blur": new Kt(Y.paint_circle["circle-blur"]), "circle-opacity": new Kt(Y.paint_circle["circle-opacity"]), "circle-translate": new jt(Y.paint_circle["circle-translate"]), "circle-translate-anchor": new jt(Y.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new jt(Y.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new jt(Y.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Kt(Y.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Kt(Y.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Kt(Y.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return vd = vd || new a({ "circle-sort-key": new Kt(Y.layout_circle["circle-sort-key"]) });
      } }, Zn = 1e-6, vc = typeof Float32Array < "u" ? Float32Array : Array;
      function lu(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function bd(i, t, n) {
        var o = t[0], u = t[1], f = t[2], g = t[3], P = t[4], L = t[5], E = t[6], D = t[7], R = t[8], Z = t[9], H = t[10], K = t[11], re = t[12], pe = t[13], xe = t[14], Ne = t[15], Te = n[0], ze = n[1], Ge = n[2], gt = n[3];
        return i[0] = Te * o + ze * P + Ge * R + gt * re, i[1] = Te * u + ze * L + Ge * Z + gt * pe, i[2] = Te * f + ze * E + Ge * H + gt * xe, i[3] = Te * g + ze * D + Ge * K + gt * Ne, i[4] = (Te = n[4]) * o + (ze = n[5]) * P + (Ge = n[6]) * R + (gt = n[7]) * re, i[5] = Te * u + ze * L + Ge * Z + gt * pe, i[6] = Te * f + ze * E + Ge * H + gt * xe, i[7] = Te * g + ze * D + Ge * K + gt * Ne, i[8] = (Te = n[8]) * o + (ze = n[9]) * P + (Ge = n[10]) * R + (gt = n[11]) * re, i[9] = Te * u + ze * L + Ge * Z + gt * pe, i[10] = Te * f + ze * E + Ge * H + gt * xe, i[11] = Te * g + ze * D + Ge * K + gt * Ne, i[12] = (Te = n[12]) * o + (ze = n[13]) * P + (Ge = n[14]) * R + (gt = n[15]) * re, i[13] = Te * u + ze * L + Ge * Z + gt * pe, i[14] = Te * f + ze * E + Ge * H + gt * xe, i[15] = Te * g + ze * D + Ge * K + gt * Ne, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, t = arguments.length; t--; ) i += arguments[t] * arguments[t];
        return Math.sqrt(i);
      });
      var Kc, tm = bd;
      function Sh(i, t, n) {
        var o = t[0], u = t[1], f = t[2], g = t[3];
        return i[0] = n[0] * o + n[4] * u + n[8] * f + n[12] * g, i[1] = n[1] * o + n[5] * u + n[9] * f + n[13] * g, i[2] = n[2] * o + n[6] * u + n[10] * f + n[14] * g, i[3] = n[3] * o + n[7] * u + n[11] * f + n[15] * g, i;
      }
      Kc = new vc(4), vc != Float32Array && (Kc[0] = 0, Kc[1] = 0, Kc[2] = 0, Kc[3] = 0);
      class im extends r {
        constructor(t) {
          super(t, em);
        }
        createBucket(t) {
          return new sl(t);
        }
        queryRadius(t) {
          const n = t;
          return Jc("circle-radius", this, n) + Jc("circle-stroke-width", this, n) + bh(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t, n, o, u, f, g, P, L) {
          const E = wh(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), g.angle, P), D = this.paint.get("circle-radius").evaluate(n, o) + this.paint.get("circle-stroke-width").evaluate(n, o), R = this.paint.get("circle-pitch-alignment") === "map", Z = R ? E : function(K, re) {
            return K.map((pe) => wd(pe, re));
          }(E, L), H = R ? D * P : D;
          for (const K of u) for (const re of K) {
            const pe = R ? re : wd(re, L);
            let xe = H;
            const Ne = Sh([], [re.x, re.y, 0, 1], L);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? xe *= Ne[3] / g.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (xe *= g.cameraToCenterDistance / Ne[3]), yc(Z, pe, xe)) return !0;
          }
          return !1;
        }
      }
      function wd(i, t) {
        const n = Sh([], [i.x, i.y, 0, 1], t);
        return new j(n[0] / n[3], n[1] / n[3]);
      }
      class Sd extends sl {
      }
      let Ad;
      Nt("HeatmapBucket", Sd, { omit: ["layers"] });
      var rm = { get paint() {
        return Ad = Ad || new a({ "heatmap-radius": new Kt(Y.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Kt(Y.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new jt(Y.paint_heatmap["heatmap-intensity"]), "heatmap-color": new A(Y.paint_heatmap["heatmap-color"]), "heatmap-opacity": new jt(Y.paint_heatmap["heatmap-opacity"]) });
      } };
      function cu(i, { width: t, height: n }, o, u) {
        if (u) {
          if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
          else if (u.length !== t * n * o) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${t * n * o}`);
        } else u = new Uint8Array(t * n * o);
        return i.width = t, i.height = n, i.data = u, i;
      }
      function Pd(i, { width: t, height: n }, o) {
        if (t === i.width && n === i.height) return;
        const u = cu({}, { width: t, height: n }, o);
        hu(i, u, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, t), height: Math.min(i.height, n) }, o), i.width = t, i.height = n, i.data = u.data;
      }
      function hu(i, t, n, o, u, f) {
        if (u.width === 0 || u.height === 0) return t;
        if (u.width > i.width || u.height > i.height || n.x > i.width - u.width || n.y > i.height - u.height) throw new RangeError("out of range source coordinates for image copy");
        if (u.width > t.width || u.height > t.height || o.x > t.width - u.width || o.y > t.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
        const g = i.data, P = t.data;
        if (g === P) throw new Error("srcData equals dstData, so image is already copied");
        for (let L = 0; L < u.height; L++) {
          const E = ((n.y + L) * i.width + n.x) * f, D = ((o.y + L) * t.width + o.x) * f;
          for (let R = 0; R < u.width * f; R++) P[D + R] = g[E + R];
        }
        return t;
      }
      class Qc {
        constructor(t, n) {
          cu(this, t, 1, n);
        }
        resize(t) {
          Pd(this, t, 1);
        }
        clone() {
          return new Qc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, o, u, f) {
          hu(t, n, o, u, f, 1);
        }
      }
      class Xs {
        constructor(t, n) {
          cu(this, t, 4, n);
        }
        resize(t) {
          Pd(this, t, 4);
        }
        replace(t, n) {
          n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
        }
        clone() {
          return new Xs({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, n, o, u, f) {
          hu(t, n, o, u, f, 4);
        }
      }
      function Id(i) {
        const t = {}, n = i.resolution || 256, o = i.clips ? i.clips.length : 1, u = i.image || new Xs({ width: n, height: o });
        if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
        const f = (g, P, L) => {
          t[i.evaluationKey] = L;
          const E = i.expression.evaluate(t);
          u.data[g + P + 0] = Math.floor(255 * E.r / E.a), u.data[g + P + 1] = Math.floor(255 * E.g / E.a), u.data[g + P + 2] = Math.floor(255 * E.b / E.a), u.data[g + P + 3] = Math.floor(255 * E.a);
        };
        if (i.clips) for (let g = 0, P = 0; g < o; ++g, P += 4 * n) for (let L = 0, E = 0; L < n; L++, E += 4) {
          const D = L / (n - 1), { start: R, end: Z } = i.clips[g];
          f(P, E, R * (1 - D) + Z * D);
        }
        else for (let g = 0, P = 0; g < n; g++, P += 4) f(0, P, g / (n - 1));
        return u;
      }
      Nt("AlphaImage", Qc), Nt("RGBAImage", Xs);
      const uu = "big-fb";
      class nm extends r {
        createBucket(t) {
          return new Sd(t);
        }
        constructor(t) {
          super(t, rm), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          t === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Id({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(uu) && this.heatmapFbos.delete(uu);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let Ld;
      var sm = { get paint() {
        return Ld = Ld || new a({ "hillshade-illumination-direction": new jt(Y.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new jt(Y.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new jt(Y.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new jt(Y.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new jt(Y.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new jt(Y.paint_hillshade["hillshade-accent-color"]) });
      } };
      class om extends r {
        constructor(t) {
          super(t, sm);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const am = y([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: lm } = am;
      function Td(i, t, n = 2) {
        const o = t && t.length, u = o ? t[0] * n : i.length;
        let f = kd(i, 0, u, n, !0);
        const g = [];
        if (!f || f.next === f.prev) return g;
        let P, L, E;
        if (o && (f = function(D, R, Z, H) {
          const K = [];
          for (let re = 0, pe = R.length; re < pe; re++) {
            const xe = kd(D, R[re] * H, re < pe - 1 ? R[re + 1] * H : D.length, H, !1);
            xe === xe.next && (xe.steiner = !0), K.push(gm(xe));
          }
          K.sort(pm);
          for (let re = 0; re < K.length; re++) Z = fm(K[re], Z);
          return Z;
        }(i, t, f, n)), i.length > 80 * n) {
          P = 1 / 0, L = 1 / 0;
          let D = -1 / 0, R = -1 / 0;
          for (let Z = n; Z < u; Z += n) {
            const H = i[Z], K = i[Z + 1];
            H < P && (P = H), K < L && (L = K), H > D && (D = H), K > R && (R = K);
          }
          E = Math.max(D - P, R - L), E = E !== 0 ? 32767 / E : 0;
        }
        return eh(f, g, n, P, L, E, 0), g;
      }
      function kd(i, t, n, o, u) {
        let f;
        if (u === function(g, P, L, E) {
          let D = 0;
          for (let R = P, Z = L - E; R < L; R += E) D += (g[Z] - g[R]) * (g[R + 1] + g[Z + 1]), Z = R;
          return D;
        }(i, t, n, o) > 0) for (let g = t; g < n; g += o) f = Md(g / o | 0, i[g], i[g + 1], f);
        else for (let g = n - o; g >= t; g -= o) f = Md(g / o | 0, i[g], i[g + 1], f);
        return f && Ah(f, f.next) && (ih(f), f = f.next), f;
      }
      function ec(i, t) {
        if (!i) return i;
        t || (t = i);
        let n, o = i;
        do
          if (n = !1, o.steiner || !Ah(o, o.next) && kr(o.prev, o, o.next) !== 0) o = o.next;
          else {
            if (ih(o), o = t = o.prev, o === o.next) break;
            n = !0;
          }
        while (n || o !== t);
        return t;
      }
      function eh(i, t, n, o, u, f, g) {
        if (!i) return;
        !g && f && function(L, E, D, R) {
          let Z = L;
          do
            Z.z === 0 && (Z.z = du(Z.x, Z.y, E, D, R)), Z.prevZ = Z.prev, Z.nextZ = Z.next, Z = Z.next;
          while (Z !== L);
          Z.prevZ.nextZ = null, Z.prevZ = null, function(H) {
            let K, re = 1;
            do {
              let pe, xe = H;
              H = null;
              let Ne = null;
              for (K = 0; xe; ) {
                K++;
                let Te = xe, ze = 0;
                for (let gt = 0; gt < re && (ze++, Te = Te.nextZ, Te); gt++) ;
                let Ge = re;
                for (; ze > 0 || Ge > 0 && Te; ) ze !== 0 && (Ge === 0 || !Te || xe.z <= Te.z) ? (pe = xe, xe = xe.nextZ, ze--) : (pe = Te, Te = Te.nextZ, Ge--), Ne ? Ne.nextZ = pe : H = pe, pe.prevZ = Ne, Ne = pe;
                xe = Te;
              }
              Ne.nextZ = null, re *= 2;
            } while (K > 1);
          }(Z);
        }(i, o, u, f);
        let P = i;
        for (; i.prev !== i.next; ) {
          const L = i.prev, E = i.next;
          if (f ? hm(i, o, u, f) : cm(i)) t.push(L.i, i.i, E.i), ih(i), i = E.next, P = E.next;
          else if ((i = E) === P) {
            g ? g === 1 ? eh(i = um(ec(i), t), t, n, o, u, f, 2) : g === 2 && dm(i, t, n, o, u, f) : eh(ec(i), t, n, o, u, f, 1);
            break;
          }
        }
      }
      function cm(i) {
        const t = i.prev, n = i, o = i.next;
        if (kr(t, n, o) >= 0) return !1;
        const u = t.x, f = n.x, g = o.x, P = t.y, L = n.y, E = o.y, D = u < f ? u < g ? u : g : f < g ? f : g, R = P < L ? P < E ? P : E : L < E ? L : E, Z = u > f ? u > g ? u : g : f > g ? f : g, H = P > L ? P > E ? P : E : L > E ? L : E;
        let K = o.next;
        for (; K !== t; ) {
          if (K.x >= D && K.x <= Z && K.y >= R && K.y <= H && xc(u, P, f, L, g, E, K.x, K.y) && kr(K.prev, K, K.next) >= 0) return !1;
          K = K.next;
        }
        return !0;
      }
      function hm(i, t, n, o) {
        const u = i.prev, f = i, g = i.next;
        if (kr(u, f, g) >= 0) return !1;
        const P = u.x, L = f.x, E = g.x, D = u.y, R = f.y, Z = g.y, H = P < L ? P < E ? P : E : L < E ? L : E, K = D < R ? D < Z ? D : Z : R < Z ? R : Z, re = P > L ? P > E ? P : E : L > E ? L : E, pe = D > R ? D > Z ? D : Z : R > Z ? R : Z, xe = du(H, K, t, n, o), Ne = du(re, pe, t, n, o);
        let Te = i.prevZ, ze = i.nextZ;
        for (; Te && Te.z >= xe && ze && ze.z <= Ne; ) {
          if (Te.x >= H && Te.x <= re && Te.y >= K && Te.y <= pe && Te !== u && Te !== g && xc(P, D, L, R, E, Z, Te.x, Te.y) && kr(Te.prev, Te, Te.next) >= 0 || (Te = Te.prevZ, ze.x >= H && ze.x <= re && ze.y >= K && ze.y <= pe && ze !== u && ze !== g && xc(P, D, L, R, E, Z, ze.x, ze.y) && kr(ze.prev, ze, ze.next) >= 0)) return !1;
          ze = ze.nextZ;
        }
        for (; Te && Te.z >= xe; ) {
          if (Te.x >= H && Te.x <= re && Te.y >= K && Te.y <= pe && Te !== u && Te !== g && xc(P, D, L, R, E, Z, Te.x, Te.y) && kr(Te.prev, Te, Te.next) >= 0) return !1;
          Te = Te.prevZ;
        }
        for (; ze && ze.z <= Ne; ) {
          if (ze.x >= H && ze.x <= re && ze.y >= K && ze.y <= pe && ze !== u && ze !== g && xc(P, D, L, R, E, Z, ze.x, ze.y) && kr(ze.prev, ze, ze.next) >= 0) return !1;
          ze = ze.nextZ;
        }
        return !0;
      }
      function um(i, t) {
        let n = i;
        do {
          const o = n.prev, u = n.next.next;
          !Ah(o, u) && Cd(o, n, n.next, u) && th(o, u) && th(u, o) && (t.push(o.i, n.i, u.i), ih(n), ih(n.next), n = i = u), n = n.next;
        } while (n !== i);
        return ec(n);
      }
      function dm(i, t, n, o, u, f) {
        let g = i;
        do {
          let P = g.next.next;
          for (; P !== g.prev; ) {
            if (g.i !== P.i && ym(g, P)) {
              let L = Ed(g, P);
              return g = ec(g, g.next), L = ec(L, L.next), eh(g, t, n, o, u, f, 0), void eh(L, t, n, o, u, f, 0);
            }
            P = P.next;
          }
          g = g.next;
        } while (g !== i);
      }
      function pm(i, t) {
        return i.x - t.x;
      }
      function fm(i, t) {
        const n = function(u, f) {
          let g = f;
          const P = u.x, L = u.y;
          let E, D = -1 / 0;
          do {
            if (L <= g.y && L >= g.next.y && g.next.y !== g.y) {
              const re = g.x + (L - g.y) * (g.next.x - g.x) / (g.next.y - g.y);
              if (re <= P && re > D && (D = re, E = g.x < g.next.x ? g : g.next, re === P)) return E;
            }
            g = g.next;
          } while (g !== f);
          if (!E) return null;
          const R = E, Z = E.x, H = E.y;
          let K = 1 / 0;
          g = E;
          do {
            if (P >= g.x && g.x >= Z && P !== g.x && xc(L < H ? P : D, L, Z, H, L < H ? D : P, L, g.x, g.y)) {
              const re = Math.abs(L - g.y) / (P - g.x);
              th(g, u) && (re < K || re === K && (g.x > E.x || g.x === E.x && mm(E, g))) && (E = g, K = re);
            }
            g = g.next;
          } while (g !== R);
          return E;
        }(i, t);
        if (!n) return t;
        const o = Ed(n, i);
        return ec(o, o.next), ec(n, n.next);
      }
      function mm(i, t) {
        return kr(i.prev, i, t.prev) < 0 && kr(t.next, i, i.next) < 0;
      }
      function du(i, t, n, o, u) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * u | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - o) * u | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
      }
      function gm(i) {
        let t = i, n = i;
        do
          (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
        while (t !== i);
        return n;
      }
      function xc(i, t, n, o, u, f, g, P) {
        return (u - g) * (t - P) >= (i - g) * (f - P) && (i - g) * (o - P) >= (n - g) * (t - P) && (n - g) * (f - P) >= (u - g) * (o - P);
      }
      function ym(i, t) {
        return i.next.i !== t.i && i.prev.i !== t.i && !function(n, o) {
          let u = n;
          do {
            if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && Cd(u, u.next, n, o)) return !0;
            u = u.next;
          } while (u !== n);
          return !1;
        }(i, t) && (th(i, t) && th(t, i) && function(n, o) {
          let u = n, f = !1;
          const g = (n.x + o.x) / 2, P = (n.y + o.y) / 2;
          do
            u.y > P != u.next.y > P && u.next.y !== u.y && g < (u.next.x - u.x) * (P - u.y) / (u.next.y - u.y) + u.x && (f = !f), u = u.next;
          while (u !== n);
          return f;
        }(i, t) && (kr(i.prev, i, t.prev) || kr(i, t.prev, t)) || Ah(i, t) && kr(i.prev, i, i.next) > 0 && kr(t.prev, t, t.next) > 0);
      }
      function kr(i, t, n) {
        return (t.y - i.y) * (n.x - t.x) - (t.x - i.x) * (n.y - t.y);
      }
      function Ah(i, t) {
        return i.x === t.x && i.y === t.y;
      }
      function Cd(i, t, n, o) {
        const u = Ih(kr(i, t, n)), f = Ih(kr(i, t, o)), g = Ih(kr(n, o, i)), P = Ih(kr(n, o, t));
        return u !== f && g !== P || !(u !== 0 || !Ph(i, n, t)) || !(f !== 0 || !Ph(i, o, t)) || !(g !== 0 || !Ph(n, i, o)) || !(P !== 0 || !Ph(n, t, o));
      }
      function Ph(i, t, n) {
        return t.x <= Math.max(i.x, n.x) && t.x >= Math.min(i.x, n.x) && t.y <= Math.max(i.y, n.y) && t.y >= Math.min(i.y, n.y);
      }
      function Ih(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function th(i, t) {
        return kr(i.prev, i, i.next) < 0 ? kr(i, t, i.next) >= 0 && kr(i, i.prev, t) >= 0 : kr(i, t, i.prev) < 0 || kr(i, i.next, t) < 0;
      }
      function Ed(i, t) {
        const n = pu(i.i, i.x, i.y), o = pu(t.i, t.x, t.y), u = i.next, f = t.prev;
        return i.next = t, t.prev = i, n.next = u, u.prev = n, o.next = n, n.prev = o, f.next = o, o.prev = f, o;
      }
      function Md(i, t, n, o) {
        const u = pu(i, t, n);
        return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u;
      }
      function ih(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function pu(i, t, n) {
        return { i, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function fu(i, t, n) {
        const o = n.patternDependencies;
        let u = !1;
        for (const f of t) {
          const g = f.paint.get(`${i}-pattern`);
          g.isConstant() || (u = !0);
          const P = g.constantOr(null);
          P && (u = !0, o[P.to] = !0, o[P.from] = !0);
        }
        return u;
      }
      function mu(i, t, n, o, u) {
        const f = u.patternDependencies;
        for (const g of t) {
          const P = g.paint.get(`${i}-pattern`).value;
          if (P.kind !== "constant") {
            let L = P.evaluate({ zoom: o - 1 }, n, {}, u.availableImages), E = P.evaluate({ zoom: o }, n, {}, u.availableImages), D = P.evaluate({ zoom: o + 1 }, n, {}, u.availableImages);
            L = L && L.name ? L.name : L, E = E && E.name ? E.name : E, D = D && D.name ? D.name : D, f[L] = !0, f[E] = !0, f[D] = !0, n.patterns[g.id] = { min: L, mid: E, max: D };
          }
        }
        return n;
      }
      class gu {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new hn(), this.indexArray = new Kr(), this.indexArray2 = new yr(), this.programConfigurations = new wa(t.layers, t.zoom), this.segments = new Ti(), this.segments2 = new Ti(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, o) {
          this.hasPattern = fu("fill", this.layers, n);
          const u = this.layers[0].layout.get("fill-sort-key"), f = !u.isConstant(), g = [];
          for (const { feature: P, id: L, index: E, sourceLayerIndex: D } of t) {
            const R = this.layers[0]._featureFilter.needGeometry, Z = Sa(P, R);
            if (!this.layers[0]._featureFilter.filter(new Gi(this.zoom), Z, o)) continue;
            const H = f ? u.evaluate(Z, {}, o, n.availableImages) : void 0, K = { id: L, properties: P.properties, type: P.type, sourceLayerIndex: D, index: E, geometry: R ? Z.geometry : nl(P), patterns: {}, sortKey: H };
            g.push(K);
          }
          f && g.sort((P, L) => P.sortKey - L.sortKey);
          for (const P of g) {
            const { geometry: L, index: E, sourceLayerIndex: D } = P;
            if (this.hasPattern) {
              const R = mu("fill", this.layers, P, this.zoom, n);
              this.patternFeatures.push(R);
            } else this.addFeature(P, L, E, o, {});
            n.featureIndex.insert(t[E].feature, L, E, D, this.index);
          }
        }
        update(t, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, o);
        }
        addFeatures(t, n, o) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, lm), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t, n, o, u, f) {
          for (const g of xs(n, 500)) {
            let P = 0;
            for (const H of g) P += H.length;
            const L = this.segments.prepareSegment(P, this.layoutVertexArray, this.indexArray), E = L.vertexLength, D = [], R = [];
            for (const H of g) {
              if (H.length === 0) continue;
              H !== g[0] && R.push(D.length / 2);
              const K = this.segments2.prepareSegment(H.length, this.layoutVertexArray, this.indexArray2), re = K.vertexLength;
              this.layoutVertexArray.emplaceBack(H[0].x, H[0].y), this.indexArray2.emplaceBack(re + H.length - 1, re), D.push(H[0].x), D.push(H[0].y);
              for (let pe = 1; pe < H.length; pe++) this.layoutVertexArray.emplaceBack(H[pe].x, H[pe].y), this.indexArray2.emplaceBack(re + pe - 1, re + pe), D.push(H[pe].x), D.push(H[pe].y);
              K.vertexLength += H.length, K.primitiveLength += H.length;
            }
            const Z = Td(D, R);
            for (let H = 0; H < Z.length; H += 3) this.indexArray.emplaceBack(E + Z[H], E + Z[H + 1], E + Z[H + 2]);
            L.vertexLength += P, L.primitiveLength += Z.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, f, u);
        }
      }
      let zd, Dd;
      Nt("FillBucket", gu, { omit: ["layers", "patternFeatures"] });
      var _m = { get paint() {
        return Dd = Dd || new a({ "fill-antialias": new jt(Y.paint_fill["fill-antialias"]), "fill-opacity": new Kt(Y.paint_fill["fill-opacity"]), "fill-color": new Kt(Y.paint_fill["fill-color"]), "fill-outline-color": new Kt(Y.paint_fill["fill-outline-color"]), "fill-translate": new jt(Y.paint_fill["fill-translate"]), "fill-translate-anchor": new jt(Y.paint_fill["fill-translate-anchor"]), "fill-pattern": new el(Y.paint_fill["fill-pattern"]) });
      }, get layout() {
        return zd = zd || new a({ "fill-sort-key": new Kt(Y.layout_fill["fill-sort-key"]) });
      } };
      class vm extends r {
        constructor(t) {
          super(t, _m);
        }
        recalculate(t, n) {
          super.recalculate(t, n);
          const o = this.paint._values["fill-outline-color"];
          o.value.kind === "constant" && o.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new gu(t);
        }
        queryRadius() {
          return bh(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t, n, o, u, f, g, P) {
          return vo(wh(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), g.angle, P), u);
        }
        isTileClipped() {
          return !0;
        }
      }
      const xm = y([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), bm = y([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: wm } = xm;
      var Sl = {}, Sm = N, Nd = bc;
      function bc(i, t, n, o, u) {
        this.properties = {}, this.extent = n, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = o, this._values = u, i.readFields(Am, this, t);
      }
      function Am(i, t, n) {
        i == 1 ? t.id = n.readVarint() : i == 2 ? function(o, u) {
          for (var f = o.readVarint() + o.pos; o.pos < f; ) {
            var g = u._keys[o.readVarint()], P = u._values[o.readVarint()];
            u.properties[g] = P;
          }
        }(n, t) : i == 3 ? t.type = n.readVarint() : i == 4 && (t._geometry = n.pos);
      }
      function Pm(i) {
        for (var t, n, o = 0, u = 0, f = i.length, g = f - 1; u < f; g = u++) o += ((n = i[g]).x - (t = i[u]).x) * (t.y + n.y);
        return o;
      }
      bc.types = ["Unknown", "Point", "LineString", "Polygon"], bc.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t, n = i.readVarint() + i.pos, o = 1, u = 0, f = 0, g = 0, P = []; i.pos < n; ) {
          if (u <= 0) {
            var L = i.readVarint();
            o = 7 & L, u = L >> 3;
          }
          if (u--, o === 1 || o === 2) f += i.readSVarint(), g += i.readSVarint(), o === 1 && (t && P.push(t), t = []), t.push(new Sm(f, g));
          else {
            if (o !== 7) throw new Error("unknown command " + o);
            t && t.push(t[0].clone());
          }
        }
        return t && P.push(t), P;
      }, bc.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var t = i.readVarint() + i.pos, n = 1, o = 0, u = 0, f = 0, g = 1 / 0, P = -1 / 0, L = 1 / 0, E = -1 / 0; i.pos < t; ) {
          if (o <= 0) {
            var D = i.readVarint();
            n = 7 & D, o = D >> 3;
          }
          if (o--, n === 1 || n === 2) (u += i.readSVarint()) < g && (g = u), u > P && (P = u), (f += i.readSVarint()) < L && (L = f), f > E && (E = f);
          else if (n !== 7) throw new Error("unknown command " + n);
        }
        return [g, L, P, E];
      }, bc.prototype.toGeoJSON = function(i, t, n) {
        var o, u, f = this.extent * Math.pow(2, n), g = this.extent * i, P = this.extent * t, L = this.loadGeometry(), E = bc.types[this.type];
        function D(H) {
          for (var K = 0; K < H.length; K++) {
            var re = H[K];
            H[K] = [360 * (re.x + g) / f - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (re.y + P) / f) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var R = [];
            for (o = 0; o < L.length; o++) R[o] = L[o][0];
            D(L = R);
            break;
          case 2:
            for (o = 0; o < L.length; o++) D(L[o]);
            break;
          case 3:
            for (L = function(H) {
              var K = H.length;
              if (K <= 1) return [H];
              for (var re, pe, xe = [], Ne = 0; Ne < K; Ne++) {
                var Te = Pm(H[Ne]);
                Te !== 0 && (pe === void 0 && (pe = Te < 0), pe === Te < 0 ? (re && xe.push(re), re = [H[Ne]]) : re.push(H[Ne]));
              }
              return re && xe.push(re), xe;
            }(L), o = 0; o < L.length; o++) for (u = 0; u < L[o].length; u++) D(L[o][u]);
        }
        L.length === 1 ? L = L[0] : E = "Multi" + E;
        var Z = { type: "Feature", geometry: { type: E, coordinates: L }, properties: this.properties };
        return "id" in this && (Z.id = this.id), Z;
      };
      var Im = Nd, Fd = Rd;
      function Rd(i, t) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(Lm, this, t), this.length = this._features.length;
      }
      function Lm(i, t, n) {
        i === 15 ? t.version = n.readVarint() : i === 1 ? t.name = n.readString() : i === 5 ? t.extent = n.readVarint() : i === 2 ? t._features.push(n.pos) : i === 3 ? t._keys.push(n.readString()) : i === 4 && t._values.push(function(o) {
          for (var u = null, f = o.readVarint() + o.pos; o.pos < f; ) {
            var g = o.readVarint() >> 3;
            u = g === 1 ? o.readString() : g === 2 ? o.readFloat() : g === 3 ? o.readDouble() : g === 4 ? o.readVarint64() : g === 5 ? o.readVarint() : g === 6 ? o.readSVarint() : g === 7 ? o.readBoolean() : null;
          }
          return u;
        }(n));
      }
      Rd.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var t = this._pbf.readVarint() + this._pbf.pos;
        return new Im(this._pbf, t, this.extent, this._keys, this._values);
      };
      var Tm = Fd;
      function km(i, t, n) {
        if (i === 3) {
          var o = new Tm(n, n.readVarint() + n.pos);
          o.length && (t[o.name] = o);
        }
      }
      Sl.VectorTile = function(i, t) {
        this.layers = i.readFields(km, {}, t);
      }, Sl.VectorTileFeature = Nd, Sl.VectorTileLayer = Fd;
      const Cm = Sl.VectorTileFeature.types, yu = Math.pow(2, 13);
      function rh(i, t, n, o, u, f, g, P) {
        i.emplaceBack(t, n, 2 * Math.floor(o * yu) + g, u * yu * 2, f * yu * 2, Math.round(P));
      }
      class _u {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new kn(), this.centroidVertexArray = new or(), this.indexArray = new Kr(), this.programConfigurations = new wa(t.layers, t.zoom), this.segments = new Ti(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, o) {
          this.features = [], this.hasPattern = fu("fill-extrusion", this.layers, n);
          for (const { feature: u, id: f, index: g, sourceLayerIndex: P } of t) {
            const L = this.layers[0]._featureFilter.needGeometry, E = Sa(u, L);
            if (!this.layers[0]._featureFilter.filter(new Gi(this.zoom), E, o)) continue;
            const D = { id: f, sourceLayerIndex: P, index: g, geometry: L ? E.geometry : nl(u), properties: u.properties, type: u.type, patterns: {} };
            this.hasPattern ? this.features.push(mu("fill-extrusion", this.layers, D, this.zoom, n)) : this.addFeature(D, D.geometry, g, o, {}), n.featureIndex.insert(u, D.geometry, g, P, this.index, !0);
          }
        }
        addFeatures(t, n, o) {
          for (const u of this.features) {
            const { geometry: f } = u;
            this.addFeature(u, f, u.index, n, o);
          }
        }
        update(t, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wm), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, bm.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t, n, o, u, f) {
          for (const g of xs(n, 500)) {
            const P = { x: 0, y: 0, vertexCount: 0 };
            let L = 0;
            for (const K of g) L += K.length;
            let E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const K of g) {
              if (K.length === 0 || Mm(K)) continue;
              let re = 0;
              for (let pe = 0; pe < K.length; pe++) {
                const xe = K[pe];
                if (pe >= 1) {
                  const Ne = K[pe - 1];
                  if (!Em(xe, Ne)) {
                    E.vertexLength + 4 > Ti.MAX_VERTEX_ARRAY_LENGTH && (E = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Te = xe.sub(Ne)._perp()._unit(), ze = Ne.dist(xe);
                    re + ze > 32768 && (re = 0), rh(this.layoutVertexArray, xe.x, xe.y, Te.x, Te.y, 0, 0, re), rh(this.layoutVertexArray, xe.x, xe.y, Te.x, Te.y, 0, 1, re), P.x += 2 * xe.x, P.y += 2 * xe.y, P.vertexCount += 2, re += ze, rh(this.layoutVertexArray, Ne.x, Ne.y, Te.x, Te.y, 0, 0, re), rh(this.layoutVertexArray, Ne.x, Ne.y, Te.x, Te.y, 0, 1, re), P.x += 2 * Ne.x, P.y += 2 * Ne.y, P.vertexCount += 2;
                    const Ge = E.vertexLength;
                    this.indexArray.emplaceBack(Ge, Ge + 2, Ge + 1), this.indexArray.emplaceBack(Ge + 1, Ge + 2, Ge + 3), E.vertexLength += 4, E.primitiveLength += 2;
                  }
                }
              }
            }
            if (E.vertexLength + L > Ti.MAX_VERTEX_ARRAY_LENGTH && (E = this.segments.prepareSegment(L, this.layoutVertexArray, this.indexArray)), Cm[t.type] !== "Polygon") continue;
            const D = [], R = [], Z = E.vertexLength;
            for (const K of g) if (K.length !== 0) {
              K !== g[0] && R.push(D.length / 2);
              for (let re = 0; re < K.length; re++) {
                const pe = K[re];
                rh(this.layoutVertexArray, pe.x, pe.y, 0, 0, 1, 1, 0), P.x += pe.x, P.y += pe.y, P.vertexCount += 1, D.push(pe.x), D.push(pe.y);
              }
            }
            const H = Td(D, R);
            for (let K = 0; K < H.length; K += 3) this.indexArray.emplaceBack(Z + H[K], Z + H[K + 2], Z + H[K + 1]);
            E.primitiveLength += H.length / 3, E.vertexLength += L;
            for (let K = 0; K < P.vertexCount; K++) {
              const re = Math.floor(P.x / P.vertexCount), pe = Math.floor(P.y / P.vertexCount);
              this.centroidVertexArray.emplaceBack(re, pe);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, f, u);
        }
      }
      function Em(i, t) {
        return i.x === t.x && (i.x < 0 || i.x > tr) || i.y === t.y && (i.y < 0 || i.y > tr);
      }
      function Mm(i) {
        return i.every((t) => t.x < 0) || i.every((t) => t.x > tr) || i.every((t) => t.y < 0) || i.every((t) => t.y > tr);
      }
      let Bd;
      Nt("FillExtrusionBucket", _u, { omit: ["layers", "features"] });
      var zm = { get paint() {
        return Bd = Bd || new a({ "fill-extrusion-opacity": new jt(Y["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Kt(Y["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new jt(Y["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new jt(Y["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new el(Y["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Kt(Y["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Kt(Y["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new jt(Y["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class Dm extends r {
        constructor(t) {
          super(t, zm);
        }
        createBucket(t) {
          return new _u(t);
        }
        queryRadius() {
          return bh(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(t, n, o, u, f, g, P, L) {
          const E = wh(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), g.angle, P), D = this.paint.get("fill-extrusion-height").evaluate(n, o), R = this.paint.get("fill-extrusion-base").evaluate(n, o), Z = function(K, re, pe, xe) {
            const Ne = [];
            for (const Te of K) {
              const ze = [Te.x, Te.y, 0, 1];
              Sh(ze, ze, re), Ne.push(new j(ze[0] / ze[3], ze[1] / ze[3]));
            }
            return Ne;
          }(E, L), H = function(K, re, pe, xe) {
            const Ne = [], Te = [], ze = xe[8] * re, Ge = xe[9] * re, gt = xe[10] * re, Ct = xe[11] * re, ri = xe[8] * pe, Lt = xe[9] * pe, At = xe[10] * pe, Ut = xe[11] * pe;
            for (const Bt of K) {
              const Ft = [], st = [];
              for (const Wt of Bt) {
                const qt = Wt.x, hi = Wt.y, Yi = xe[0] * qt + xe[4] * hi + xe[12], Hi = xe[1] * qt + xe[5] * hi + xe[13], en = xe[2] * qt + xe[6] * hi + xe[14], bo = xe[3] * qt + xe[7] * hi + xe[15], vn = en + gt, tn = bo + Ct, Gn = Yi + ri, Wn = Hi + Lt, Hn = en + At, Tr = bo + Ut, rn = new j((Yi + ze) / tn, (Hi + Ge) / tn);
                rn.z = vn / tn, Ft.push(rn);
                const Mn = new j(Gn / Tr, Wn / Tr);
                Mn.z = Hn / Tr, st.push(Mn);
              }
              Ne.push(Ft), Te.push(st);
            }
            return [Ne, Te];
          }(u, R, D, L);
          return function(K, re, pe) {
            let xe = 1 / 0;
            vo(pe, re) && (xe = Od(pe, re[0]));
            for (let Ne = 0; Ne < re.length; Ne++) {
              const Te = re[Ne], ze = K[Ne];
              for (let Ge = 0; Ge < Te.length - 1; Ge++) {
                const gt = Te[Ge], Ct = [gt, Te[Ge + 1], ze[Ge + 1], ze[Ge], gt];
                gc(pe, Ct) && (xe = Math.min(xe, Od(pe, Ct)));
              }
            }
            return xe !== 1 / 0 && xe;
          }(H[0], H[1], Z);
        }
      }
      function nh(i, t) {
        return i.x * t.x + i.y * t.y;
      }
      function Od(i, t) {
        if (i.length === 1) {
          let n = 0;
          const o = t[n++];
          let u;
          for (; !u || o.equals(u); ) if (u = t[n++], !u) return 1 / 0;
          for (; n < t.length; n++) {
            const f = t[n], g = i[0], P = u.sub(o), L = f.sub(o), E = g.sub(o), D = nh(P, P), R = nh(P, L), Z = nh(L, L), H = nh(E, P), K = nh(E, L), re = D * Z - R * R, pe = (Z * H - R * K) / re, xe = (D * K - R * H) / re, Ne = o.z * (1 - pe - xe) + u.z * pe + f.z * xe;
            if (isFinite(Ne)) return Ne;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const o of t) n = Math.min(n, o.z);
          return n;
        }
      }
      const Nm = y([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Fm } = Nm, Rm = y([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Bm } = Rm, Om = Sl.VectorTileFeature.types, jm = Math.cos(Math.PI / 180 * 37.5), jd = Math.pow(2, 14) / 0.5;
      class vu {
        constructor(t) {
          this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((n) => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new er(), this.layoutVertexArray2 = new go(), this.indexArray = new Kr(), this.programConfigurations = new wa(t.layers, t.zoom), this.segments = new Ti(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(t, n, o) {
          this.hasPattern = fu("line", this.layers, n);
          const u = this.layers[0].layout.get("line-sort-key"), f = !u.isConstant(), g = [];
          for (const { feature: P, id: L, index: E, sourceLayerIndex: D } of t) {
            const R = this.layers[0]._featureFilter.needGeometry, Z = Sa(P, R);
            if (!this.layers[0]._featureFilter.filter(new Gi(this.zoom), Z, o)) continue;
            const H = f ? u.evaluate(Z, {}, o) : void 0, K = { id: L, properties: P.properties, type: P.type, sourceLayerIndex: D, index: E, geometry: R ? Z.geometry : nl(P), patterns: {}, sortKey: H };
            g.push(K);
          }
          f && g.sort((P, L) => P.sortKey - L.sortKey);
          for (const P of g) {
            const { geometry: L, index: E, sourceLayerIndex: D } = P;
            if (this.hasPattern) {
              const R = mu("line", this.layers, P, this.zoom, n);
              this.patternFeatures.push(R);
            } else this.addFeature(P, L, E, o, {});
            n.featureIndex.insert(t[E].feature, L, E, D, this.index);
          }
        }
        update(t, n, o) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, o);
        }
        addFeatures(t, n, o) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Bm)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Fm), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
        }
        addFeature(t, n, o, u, f) {
          const g = this.layers[0].layout, P = g.get("line-join").evaluate(t, {}), L = g.get("line-cap"), E = g.get("line-miter-limit"), D = g.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t);
          for (const R of n) this.addLine(R, t, P, L, E, D);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, o, f, u);
        }
        addLine(t, n, o, u, f, g) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let xe = 0; xe < t.length - 1; xe++) this.totalDistance += t[xe].dist(t[xe + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const P = Om[n.type] === "Polygon";
          let L = t.length;
          for (; L >= 2 && t[L - 1].equals(t[L - 2]); ) L--;
          let E = 0;
          for (; E < L - 1 && t[E].equals(t[E + 1]); ) E++;
          if (L < (P ? 3 : 2)) return;
          o === "bevel" && (f = 1.05);
          const D = this.overscaling <= 16 ? 15 * tr / (512 * this.overscaling) : 0, R = this.segments.prepareSegment(10 * L, this.layoutVertexArray, this.indexArray);
          let Z, H, K, re, pe;
          this.e1 = this.e2 = -1, P && (Z = t[L - 2], pe = t[E].sub(Z)._unit()._perp());
          for (let xe = E; xe < L; xe++) {
            if (K = xe === L - 1 ? P ? t[E + 1] : void 0 : t[xe + 1], K && t[xe].equals(K)) continue;
            pe && (re = pe), Z && (H = Z), Z = t[xe], pe = K ? K.sub(Z)._unit()._perp() : re, re = re || pe;
            let Ne = re.add(pe);
            Ne.x === 0 && Ne.y === 0 || Ne._unit();
            const Te = re.x * pe.x + re.y * pe.y, ze = Ne.x * pe.x + Ne.y * pe.y, Ge = ze !== 0 ? 1 / ze : 1 / 0, gt = 2 * Math.sqrt(2 - 2 * ze), Ct = ze < jm && H && K, ri = re.x * pe.y - re.y * pe.x > 0;
            if (Ct && xe > E) {
              const Ut = Z.dist(H);
              if (Ut > 2 * D) {
                const Bt = Z.sub(Z.sub(H)._mult(D / Ut)._round());
                this.updateDistance(H, Bt), this.addCurrentVertex(Bt, re, 0, 0, R), H = Bt;
              }
            }
            const Lt = H && K;
            let At = Lt ? o : P ? "butt" : u;
            if (Lt && At === "round" && (Ge < g ? At = "miter" : Ge <= 2 && (At = "fakeround")), At === "miter" && Ge > f && (At = "bevel"), At === "bevel" && (Ge > 2 && (At = "flipbevel"), Ge < f && (At = "miter")), H && this.updateDistance(H, Z), At === "miter") Ne._mult(Ge), this.addCurrentVertex(Z, Ne, 0, 0, R);
            else if (At === "flipbevel") {
              if (Ge > 100) Ne = pe.mult(-1);
              else {
                const Ut = Ge * re.add(pe).mag() / re.sub(pe).mag();
                Ne._perp()._mult(Ut * (ri ? -1 : 1));
              }
              this.addCurrentVertex(Z, Ne, 0, 0, R), this.addCurrentVertex(Z, Ne.mult(-1), 0, 0, R);
            } else if (At === "bevel" || At === "fakeround") {
              const Ut = -Math.sqrt(Ge * Ge - 1), Bt = ri ? Ut : 0, Ft = ri ? 0 : Ut;
              if (H && this.addCurrentVertex(Z, re, Bt, Ft, R), At === "fakeround") {
                const st = Math.round(180 * gt / Math.PI / 20);
                for (let Wt = 1; Wt < st; Wt++) {
                  let qt = Wt / st;
                  if (qt !== 0.5) {
                    const Yi = qt - 0.5;
                    qt += qt * Yi * (qt - 1) * ((1.0904 + Te * (Te * (3.55645 - 1.43519 * Te) - 3.2452)) * Yi * Yi + (0.848013 + Te * (0.215638 * Te - 1.06021)));
                  }
                  const hi = pe.sub(re)._mult(qt)._add(re)._unit()._mult(ri ? -1 : 1);
                  this.addHalfVertex(Z, hi.x, hi.y, !1, ri, 0, R);
                }
              }
              K && this.addCurrentVertex(Z, pe, -Bt, -Ft, R);
            } else if (At === "butt") this.addCurrentVertex(Z, Ne, 0, 0, R);
            else if (At === "square") {
              const Ut = H ? 1 : -1;
              this.addCurrentVertex(Z, Ne, Ut, Ut, R);
            } else At === "round" && (H && (this.addCurrentVertex(Z, re, 0, 0, R), this.addCurrentVertex(Z, re, 1, 1, R, !0)), K && (this.addCurrentVertex(Z, pe, -1, -1, R, !0), this.addCurrentVertex(Z, pe, 0, 0, R)));
            if (Ct && xe < L - 1) {
              const Ut = Z.dist(K);
              if (Ut > 2 * D) {
                const Bt = Z.add(K.sub(Z)._mult(D / Ut)._round());
                this.updateDistance(Z, Bt), this.addCurrentVertex(Bt, pe, 0, 0, R), Z = Bt;
              }
            }
          }
        }
        addCurrentVertex(t, n, o, u, f, g = !1) {
          const P = n.y * u - n.x, L = -n.y - n.x * u;
          this.addHalfVertex(t, n.x + n.y * o, n.y - n.x * o, g, !1, o, f), this.addHalfVertex(t, P, L, g, !0, -u, f), this.distance > jd / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, o, u, f, g));
        }
        addHalfVertex({ x: t, y: n }, o, u, f, g, P, L) {
          const E = 0.5 * (this.lineClips ? this.scaledDistance * (jd - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t << 1) + (f ? 1 : 0), (n << 1) + (g ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (P === 0 ? 0 : P < 0 ? -1 : 1) | (63 & E) << 2, E >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const D = L.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, D), L.primitiveLength++), g ? this.e2 = D : this.e1 = D;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t, n) {
          this.distance += t.dist(n), this.updateScaledDistance();
        }
      }
      let qd, Vd;
      Nt("LineBucket", vu, { omit: ["layers", "patternFeatures"] });
      var Ud = { get paint() {
        return Vd = Vd || new a({ "line-opacity": new Kt(Y.paint_line["line-opacity"]), "line-color": new Kt(Y.paint_line["line-color"]), "line-translate": new jt(Y.paint_line["line-translate"]), "line-translate-anchor": new jt(Y.paint_line["line-translate-anchor"]), "line-width": new Kt(Y.paint_line["line-width"]), "line-gap-width": new Kt(Y.paint_line["line-gap-width"]), "line-offset": new Kt(Y.paint_line["line-offset"]), "line-blur": new Kt(Y.paint_line["line-blur"]), "line-dasharray": new m(Y.paint_line["line-dasharray"]), "line-pattern": new el(Y.paint_line["line-pattern"]), "line-gradient": new A(Y.paint_line["line-gradient"]) });
      }, get layout() {
        return qd = qd || new a({ "line-cap": new jt(Y.layout_line["line-cap"]), "line-join": new Kt(Y.layout_line["line-join"]), "line-miter-limit": new jt(Y.layout_line["line-miter-limit"]), "line-round-limit": new jt(Y.layout_line["line-round-limit"]), "line-sort-key": new Kt(Y.layout_line["line-sort-key"]) });
      } };
      class qm extends Kt {
        possiblyEvaluate(t, n) {
          return n = new Gi(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
        }
        evaluate(t, n, o, u) {
          return n = Be({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, o, u);
        }
      }
      let Lh;
      class Vm extends r {
        constructor(t) {
          super(t, Ud), this.gradientVersion = 0, Lh || (Lh = new qm(Ud.paint.properties["line-width"].specification), Lh.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if (t === "line-gradient") {
            const n = this.gradientExpression();
            this.stepInterpolant = !!function(o) {
              return o._styleExpression !== void 0;
            }(n) && n._styleExpression.expression instanceof ro, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t, n) {
          super.recalculate(t, n), this.paint._values["line-floorwidth"] = Lh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }
        createBucket(t) {
          return new vu(t);
        }
        queryRadius(t) {
          const n = t, o = $d(Jc("line-width", this, n), Jc("line-gap-width", this, n)), u = Jc("line-offset", this, n);
          return o / 2 + Math.abs(u) + bh(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t, n, o, u, f, g, P) {
          const L = wh(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), g.angle, P), E = P / 2 * $d(this.paint.get("line-width").evaluate(n, o), this.paint.get("line-gap-width").evaluate(n, o)), D = this.paint.get("line-offset").evaluate(n, o);
          return D && (u = function(R, Z) {
            const H = [];
            for (let K = 0; K < R.length; K++) {
              const re = R[K], pe = [];
              for (let xe = 0; xe < re.length; xe++) {
                const Ne = re[xe - 1], Te = re[xe], ze = re[xe + 1], Ge = xe === 0 ? new j(0, 0) : Te.sub(Ne)._unit()._perp(), gt = xe === re.length - 1 ? new j(0, 0) : ze.sub(Te)._unit()._perp(), Ct = Ge._add(gt)._unit(), ri = Ct.x * gt.x + Ct.y * gt.y;
                ri !== 0 && Ct._mult(1 / ri), pe.push(Ct._mult(Z)._add(Te));
              }
              H.push(pe);
            }
            return H;
          }(u, D * P)), function(R, Z, H) {
            for (let K = 0; K < Z.length; K++) {
              const re = Z[K];
              if (R.length >= 3) {
                for (let pe = 0; pe < re.length; pe++) if (Pa(R, re[pe])) return !0;
              }
              if (Aa(R, re, H)) return !0;
            }
            return !1;
          }(L, u, E);
        }
        isTileClipped() {
          return !0;
        }
      }
      function $d(i, t) {
        return t > 0 ? t + 2 * i : i;
      }
      const Um = y([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), $m = y([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      y([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Zm = y([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      y([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Zd = y([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Gm = y([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function Wm(i, t, n) {
        return i.sections.forEach((o) => {
          o.text = function(u, f, g) {
            const P = f.layout.get("text-transform").evaluate(g, {});
            return P === "uppercase" ? u = u.toLocaleUpperCase() : P === "lowercase" && (u = u.toLocaleLowerCase()), Tn.applyArabicShaping && (u = Tn.applyArabicShaping(u)), u;
          }(o.text, t, n);
        }), i;
      }
      y([{ name: "triangle", components: 3, type: "Uint16" }]), y([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), y([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), y([{ type: "Float32", name: "offsetX" }]), y([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), y([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const sh = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var jr = 24, Gd = Wi, Wd = function(i, t, n, o, u) {
        var f, g, P = 8 * u - o - 1, L = (1 << P) - 1, E = L >> 1, D = -7, R = u - 1, Z = -1, H = i[t + R];
        for (R += Z, f = H & (1 << -D) - 1, H >>= -D, D += P; D > 0; f = 256 * f + i[t + R], R += Z, D -= 8) ;
        for (g = f & (1 << -D) - 1, f >>= -D, D += o; D > 0; g = 256 * g + i[t + R], R += Z, D -= 8) ;
        if (f === 0) f = 1 - E;
        else {
          if (f === L) return g ? NaN : 1 / 0 * (H ? -1 : 1);
          g += Math.pow(2, o), f -= E;
        }
        return (H ? -1 : 1) * g * Math.pow(2, f - o);
      }, Hd = function(i, t, n, o, u, f) {
        var g, P, L, E = 8 * f - u - 1, D = (1 << E) - 1, R = D >> 1, Z = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, H = 0, K = 1, re = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (P = isNaN(t) ? 1 : 0, g = D) : (g = Math.floor(Math.log(t) / Math.LN2), t * (L = Math.pow(2, -g)) < 1 && (g--, L *= 2), (t += g + R >= 1 ? Z / L : Z * Math.pow(2, 1 - R)) * L >= 2 && (g++, L /= 2), g + R >= D ? (P = 0, g = D) : g + R >= 1 ? (P = (t * L - 1) * Math.pow(2, u), g += R) : (P = t * Math.pow(2, R - 1) * Math.pow(2, u), g = 0)); u >= 8; i[n + H] = 255 & P, H += K, P /= 256, u -= 8) ;
        for (g = g << u | P, E += u; E > 0; i[n + H] = 255 & g, H += K, g /= 256, E -= 8) ;
        i[n + H - K] |= 128 * re;
      };
      function Wi(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Wi.Varint = 0, Wi.Fixed64 = 1, Wi.Bytes = 2, Wi.Fixed32 = 5;
      var xu = 4294967296, Xd = 1 / xu, Yd = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function ol(i) {
        return i.type === Wi.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function wc(i, t, n) {
        return n ? 4294967296 * t + (i >>> 0) : 4294967296 * (t >>> 0) + (i >>> 0);
      }
      function Jd(i, t, n) {
        var o = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
        n.realloc(o);
        for (var u = n.pos - 1; u >= i; u--) n.buf[u + o] = n.buf[u];
      }
      function Hm(i, t) {
        for (var n = 0; n < i.length; n++) t.writeVarint(i[n]);
      }
      function Xm(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSVarint(i[n]);
      }
      function Ym(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFloat(i[n]);
      }
      function Jm(i, t) {
        for (var n = 0; n < i.length; n++) t.writeDouble(i[n]);
      }
      function Km(i, t) {
        for (var n = 0; n < i.length; n++) t.writeBoolean(i[n]);
      }
      function Qm(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed32(i[n]);
      }
      function eg(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed32(i[n]);
      }
      function tg(i, t) {
        for (var n = 0; n < i.length; n++) t.writeFixed64(i[n]);
      }
      function ig(i, t) {
        for (var n = 0; n < i.length; n++) t.writeSFixed64(i[n]);
      }
      function Th(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + 16777216 * i[t + 3];
      }
      function Sc(i, t, n) {
        i[n] = t, i[n + 1] = t >>> 8, i[n + 2] = t >>> 16, i[n + 3] = t >>> 24;
      }
      function Kd(i, t) {
        return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) + (i[t + 3] << 24);
      }
      Wi.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, t, n) {
        for (n = n || this.length; this.pos < n; ) {
          var o = this.readVarint(), u = o >> 3, f = this.pos;
          this.type = 7 & o, i(u, t, this), this.pos === f && this.skip(o);
        }
        return t;
      }, readMessage: function(i, t) {
        return this.readFields(i, t, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = Th(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = Kd(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = Th(this.buf, this.pos) + Th(this.buf, this.pos + 4) * xu;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = Th(this.buf, this.pos) + Kd(this.buf, this.pos + 4) * xu;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = Wd(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = Wd(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var t, n, o = this.buf;
        return t = 127 & (n = o[this.pos++]), n < 128 ? t : (t |= (127 & (n = o[this.pos++])) << 7, n < 128 ? t : (t |= (127 & (n = o[this.pos++])) << 14, n < 128 ? t : (t |= (127 & (n = o[this.pos++])) << 21, n < 128 ? t : function(u, f, g) {
          var P, L, E = g.buf;
          if (P = (112 & (L = E[g.pos++])) >> 4, L < 128 || (P |= (127 & (L = E[g.pos++])) << 3, L < 128) || (P |= (127 & (L = E[g.pos++])) << 10, L < 128) || (P |= (127 & (L = E[g.pos++])) << 17, L < 128) || (P |= (127 & (L = E[g.pos++])) << 24, L < 128) || (P |= (1 & (L = E[g.pos++])) << 31, L < 128)) return wc(u, P, f);
          throw new Error("Expected varint not more than 10 bytes");
        }(t |= (15 & (n = o[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, t = this.pos;
        return this.pos = i, i - t >= 12 && Yd ? function(n, o, u) {
          return Yd.decode(n.subarray(o, u));
        }(this.buf, t, i) : function(n, o, u) {
          for (var f = "", g = o; g < u; ) {
            var P, L, E, D = n[g], R = null, Z = D > 239 ? 4 : D > 223 ? 3 : D > 191 ? 2 : 1;
            if (g + Z > u) break;
            Z === 1 ? D < 128 && (R = D) : Z === 2 ? (192 & (P = n[g + 1])) == 128 && (R = (31 & D) << 6 | 63 & P) <= 127 && (R = null) : Z === 3 ? (L = n[g + 2], (192 & (P = n[g + 1])) == 128 && (192 & L) == 128 && ((R = (15 & D) << 12 | (63 & P) << 6 | 63 & L) <= 2047 || R >= 55296 && R <= 57343) && (R = null)) : Z === 4 && (L = n[g + 2], E = n[g + 3], (192 & (P = n[g + 1])) == 128 && (192 & L) == 128 && (192 & E) == 128 && ((R = (15 & D) << 18 | (63 & P) << 12 | (63 & L) << 6 | 63 & E) <= 65535 || R >= 1114112) && (R = null)), R === null ? (R = 65533, Z = 1) : R > 65535 && (R -= 65536, f += String.fromCharCode(R >>> 10 & 1023 | 55296), R = 56320 | 1023 & R), f += String.fromCharCode(R), g += Z;
          }
          return f;
        }(this.buf, t, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, i);
        return this.pos = i, t;
      }, readPackedVarint: function(i, t) {
        if (this.type !== Wi.Bytes) return i.push(this.readVarint(t));
        var n = ol(this);
        for (i = i || []; this.pos < n; ) i.push(this.readVarint(t));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSVarint());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readBoolean());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFloat());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readDouble());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFixed32());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSFixed32());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readFixed64());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Wi.Bytes) return i.push(this.readSFixed64());
        var t = ol(this);
        for (i = i || []; this.pos < t; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var t = 7 & i;
        if (t === Wi.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (t === Wi.Bytes) this.pos = this.readVarint() + this.pos;
        else if (t === Wi.Fixed32) this.pos += 4;
        else {
          if (t !== Wi.Fixed64) throw new Error("Unimplemented type: " + t);
          this.pos += 8;
        }
      }, writeTag: function(i, t) {
        this.writeVarint(i << 3 | t);
      }, realloc: function(i) {
        for (var t = this.length || 16; t < this.pos + i; ) t *= 2;
        if (t !== this.length) {
          var n = new Uint8Array(t);
          n.set(this.buf), this.buf = n, this.length = t;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), Sc(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), Sc(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), Sc(this.buf, -1 & i, this.pos), Sc(this.buf, Math.floor(i * Xd), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), Sc(this.buf, -1 & i, this.pos), Sc(this.buf, Math.floor(i * Xd), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(t, n) {
          var o, u;
          if (t >= 0 ? (o = t % 4294967296 | 0, u = t / 4294967296 | 0) : (u = ~(-t / 4294967296), 4294967295 ^ (o = ~(-t % 4294967296)) ? o = o + 1 | 0 : (o = 0, u = u + 1 | 0)), t >= 18446744073709552e3 || t < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          n.realloc(10), function(f, g, P) {
            P.buf[P.pos++] = 127 & f | 128, f >>>= 7, P.buf[P.pos++] = 127 & f | 128, f >>>= 7, P.buf[P.pos++] = 127 & f | 128, f >>>= 7, P.buf[P.pos++] = 127 & f | 128, P.buf[P.pos] = 127 & (f >>>= 7);
          }(o, 0, n), function(f, g) {
            var P = (7 & f) << 4;
            g.buf[g.pos++] |= P | ((f >>>= 3) ? 128 : 0), f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (g.buf[g.pos++] = 127 & f | ((f >>>= 7) ? 128 : 0), f && (g.buf[g.pos++] = 127 & f)))));
          }(u, n);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var t = this.pos;
        this.pos = function(o, u, f) {
          for (var g, P, L = 0; L < u.length; L++) {
            if ((g = u.charCodeAt(L)) > 55295 && g < 57344) {
              if (!P) {
                g > 56319 || L + 1 === u.length ? (o[f++] = 239, o[f++] = 191, o[f++] = 189) : P = g;
                continue;
              }
              if (g < 56320) {
                o[f++] = 239, o[f++] = 191, o[f++] = 189, P = g;
                continue;
              }
              g = P - 55296 << 10 | g - 56320 | 65536, P = null;
            } else P && (o[f++] = 239, o[f++] = 191, o[f++] = 189, P = null);
            g < 128 ? o[f++] = g : (g < 2048 ? o[f++] = g >> 6 | 192 : (g < 65536 ? o[f++] = g >> 12 | 224 : (o[f++] = g >> 18 | 240, o[f++] = g >> 12 & 63 | 128), o[f++] = g >> 6 & 63 | 128), o[f++] = 63 & g | 128);
          }
          return f;
        }(this.buf, i, this.pos);
        var n = this.pos - t;
        n >= 128 && Jd(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
      }, writeFloat: function(i) {
        this.realloc(4), Hd(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Hd(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var t = i.length;
        this.writeVarint(t), this.realloc(t);
        for (var n = 0; n < t; n++) this.buf[this.pos++] = i[n];
      }, writeRawMessage: function(i, t) {
        this.pos++;
        var n = this.pos;
        i(t, this);
        var o = this.pos - n;
        o >= 128 && Jd(n, o, this), this.pos = n - 1, this.writeVarint(o), this.pos += o;
      }, writeMessage: function(i, t, n) {
        this.writeTag(i, Wi.Bytes), this.writeRawMessage(t, n);
      }, writePackedVarint: function(i, t) {
        t.length && this.writeMessage(i, Hm, t);
      }, writePackedSVarint: function(i, t) {
        t.length && this.writeMessage(i, Xm, t);
      }, writePackedBoolean: function(i, t) {
        t.length && this.writeMessage(i, Km, t);
      }, writePackedFloat: function(i, t) {
        t.length && this.writeMessage(i, Ym, t);
      }, writePackedDouble: function(i, t) {
        t.length && this.writeMessage(i, Jm, t);
      }, writePackedFixed32: function(i, t) {
        t.length && this.writeMessage(i, Qm, t);
      }, writePackedSFixed32: function(i, t) {
        t.length && this.writeMessage(i, eg, t);
      }, writePackedFixed64: function(i, t) {
        t.length && this.writeMessage(i, tg, t);
      }, writePackedSFixed64: function(i, t) {
        t.length && this.writeMessage(i, ig, t);
      }, writeBytesField: function(i, t) {
        this.writeTag(i, Wi.Bytes), this.writeBytes(t);
      }, writeFixed32Field: function(i, t) {
        this.writeTag(i, Wi.Fixed32), this.writeFixed32(t);
      }, writeSFixed32Field: function(i, t) {
        this.writeTag(i, Wi.Fixed32), this.writeSFixed32(t);
      }, writeFixed64Field: function(i, t) {
        this.writeTag(i, Wi.Fixed64), this.writeFixed64(t);
      }, writeSFixed64Field: function(i, t) {
        this.writeTag(i, Wi.Fixed64), this.writeSFixed64(t);
      }, writeVarintField: function(i, t) {
        this.writeTag(i, Wi.Varint), this.writeVarint(t);
      }, writeSVarintField: function(i, t) {
        this.writeTag(i, Wi.Varint), this.writeSVarint(t);
      }, writeStringField: function(i, t) {
        this.writeTag(i, Wi.Bytes), this.writeString(t);
      }, writeFloatField: function(i, t) {
        this.writeTag(i, Wi.Fixed32), this.writeFloat(t);
      }, writeDoubleField: function(i, t) {
        this.writeTag(i, Wi.Fixed64), this.writeDouble(t);
      }, writeBooleanField: function(i, t) {
        this.writeVarintField(i, !!t);
      } };
      var bu = C(Gd);
      const wu = 3;
      function rg(i, t, n) {
        i === 1 && n.readMessage(ng, t);
      }
      function ng(i, t, n) {
        if (i === 3) {
          const { id: o, bitmap: u, width: f, height: g, left: P, top: L, advance: E } = n.readMessage(sg, {});
          t.push({ id: o, bitmap: new Qc({ width: f + 2 * wu, height: g + 2 * wu }, u), metrics: { width: f, height: g, left: P, top: L, advance: E } });
        }
      }
      function sg(i, t, n) {
        i === 1 ? t.id = n.readVarint() : i === 2 ? t.bitmap = n.readBytes() : i === 3 ? t.width = n.readVarint() : i === 4 ? t.height = n.readVarint() : i === 5 ? t.left = n.readSVarint() : i === 6 ? t.top = n.readSVarint() : i === 7 && (t.advance = n.readVarint());
      }
      const Qd = wu;
      function ep(i) {
        let t = 0, n = 0;
        for (const g of i) t += g.w * g.h, n = Math.max(n, g.w);
        i.sort((g, P) => P.h - g.h);
        const o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
        let u = 0, f = 0;
        for (const g of i) for (let P = o.length - 1; P >= 0; P--) {
          const L = o[P];
          if (!(g.w > L.w || g.h > L.h)) {
            if (g.x = L.x, g.y = L.y, f = Math.max(f, g.y + g.h), u = Math.max(u, g.x + g.w), g.w === L.w && g.h === L.h) {
              const E = o.pop();
              P < o.length && (o[P] = E);
            } else g.h === L.h ? (L.x += g.w, L.w -= g.w) : g.w === L.w ? (L.y += g.h, L.h -= g.h) : (o.push({ x: L.x + g.w, y: L.y, w: L.w - g.w, h: g.h }), L.y += g.h, L.h -= g.h);
            break;
          }
        }
        return { w: u, h: f, fill: t / (u * f) || 0 };
      }
      const fs = 1;
      class Su {
        constructor(t, { pixelRatio: n, version: o, stretchX: u, stretchY: f, content: g, textFitWidth: P, textFitHeight: L }) {
          this.paddedRect = t, this.pixelRatio = n, this.stretchX = u, this.stretchY = f, this.content = g, this.version = o, this.textFitWidth = P, this.textFitHeight = L;
        }
        get tl() {
          return [this.paddedRect.x + fs, this.paddedRect.y + fs];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - fs, this.paddedRect.y + this.paddedRect.h - fs];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * fs) / this.pixelRatio, (this.paddedRect.h - 2 * fs) / this.pixelRatio];
        }
      }
      class tp {
        constructor(t, n) {
          const o = {}, u = {};
          this.haveRenderCallbacks = [];
          const f = [];
          this.addImages(t, o, f), this.addImages(n, u, f);
          const { w: g, h: P } = ep(f), L = new Xs({ width: g || 1, height: P || 1 });
          for (const E in t) {
            const D = t[E], R = o[E].paddedRect;
            Xs.copy(D.data, L, { x: 0, y: 0 }, { x: R.x + fs, y: R.y + fs }, D.data);
          }
          for (const E in n) {
            const D = n[E], R = u[E].paddedRect, Z = R.x + fs, H = R.y + fs, K = D.data.width, re = D.data.height;
            Xs.copy(D.data, L, { x: 0, y: 0 }, { x: Z, y: H }, D.data), Xs.copy(D.data, L, { x: 0, y: re - 1 }, { x: Z, y: H - 1 }, { width: K, height: 1 }), Xs.copy(D.data, L, { x: 0, y: 0 }, { x: Z, y: H + re }, { width: K, height: 1 }), Xs.copy(D.data, L, { x: K - 1, y: 0 }, { x: Z - 1, y: H }, { width: 1, height: re }), Xs.copy(D.data, L, { x: 0, y: 0 }, { x: Z + K, y: H }, { width: 1, height: re });
          }
          this.image = L, this.iconPositions = o, this.patternPositions = u;
        }
        addImages(t, n, o) {
          for (const u in t) {
            const f = t[u], g = { x: 0, y: 0, w: f.data.width + 2 * fs, h: f.data.height + 2 * fs };
            o.push(g), n[u] = new Su(g, f), f.hasRenderCallback && this.haveRenderCallbacks.push(u);
          }
        }
        patchUpdatedImages(t, n) {
          t.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const o in t.updatedImages) this.patchUpdatedImage(this.iconPositions[o], t.getImage(o), n), this.patchUpdatedImage(this.patternPositions[o], t.getImage(o), n);
        }
        patchUpdatedImage(t, n, o) {
          if (!t || !n || t.version === n.version) return;
          t.version = n.version;
          const [u, f] = t.tl;
          o.update(n.data, void 0, { x: u, y: f });
        }
      }
      var Al;
      Nt("ImagePosition", Su), Nt("ImageAtlas", tp), _.ah = void 0, (Al = _.ah || (_.ah = {}))[Al.none = 0] = "none", Al[Al.horizontal = 1] = "horizontal", Al[Al.vertical = 2] = "vertical", Al[Al.horizontalOnly = 3] = "horizontalOnly";
      const oh = -17;
      class ah {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t, n) {
          const o = new ah();
          return o.scale = t || 1, o.fontStack = n, o;
        }
        static forImage(t) {
          const n = new ah();
          return n.imageName = t, n;
        }
      }
      class Ac {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t, n) {
          const o = new Ac();
          for (let u = 0; u < t.sections.length; u++) {
            const f = t.sections[u];
            f.image ? o.addImageSection(f) : o.addTextSection(f, n);
          }
          return o;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCharCode(t) {
          return this.text.charCodeAt(t);
        }
        verticalizePunctuation() {
          this.text = function(t) {
            let n = "";
            for (let o = 0; o < t.length; o++) {
              const u = t.charCodeAt(o + 1) || null, f = t.charCodeAt(o - 1) || null;
              n += u && Ja(u) && !sh[t[o + 1]] || f && Ja(f) && !sh[t[o - 1]] || !sh[t[o]] ? t[o] : sh[t[o]];
            }
            return n;
          }(this.text);
        }
        trim() {
          let t = 0;
          for (let o = 0; o < this.text.length && Ch[this.text.charCodeAt(o)]; o++) t++;
          let n = this.text.length;
          for (let o = this.text.length - 1; o >= 0 && o >= t && Ch[this.text.charCodeAt(o)]; o--) n--;
          this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
        }
        substring(t, n) {
          const o = new Ac();
          return o.text = this.text.substring(t, n), o.sectionIndex = this.sectionIndex.slice(t, n), o.sections = this.sections, o;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t, n) => Math.max(t, this.sections[n].scale), 0);
        }
        addTextSection(t, n) {
          this.text += t.text, this.sections.push(ah.forText(t.scale, t.fontStack || n));
          const o = this.sections.length - 1;
          for (let u = 0; u < t.text.length; ++u) this.sectionIndex.push(o);
        }
        addImageSection(t) {
          const n = t.image ? t.image.name : "";
          if (n.length === 0) return void Le("Can't add FormattedSection with an empty image.");
          const o = this.getNextImageSectionCharCode();
          o ? (this.text += String.fromCharCode(o), this.sections.push(ah.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : Le("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function kh(i, t, n, o, u, f, g, P, L, E, D, R, Z, H, K) {
        const re = Ac.fromFeature(i, u);
        let pe;
        R === _.ah.vertical && re.verticalizePunctuation();
        const { processBidirectionalText: xe, processStyledBidirectionalText: Ne } = Tn;
        if (xe && re.sections.length === 1) {
          pe = [];
          const Ge = xe(re.toString(), Au(re, E, f, t, o, H));
          for (const gt of Ge) {
            const Ct = new Ac();
            Ct.text = gt, Ct.sections = re.sections;
            for (let ri = 0; ri < gt.length; ri++) Ct.sectionIndex.push(0);
            pe.push(Ct);
          }
        } else if (Ne) {
          pe = [];
          const Ge = Ne(re.text, re.sectionIndex, Au(re, E, f, t, o, H));
          for (const gt of Ge) {
            const Ct = new Ac();
            Ct.text = gt[0], Ct.sectionIndex = gt[1], Ct.sections = re.sections, pe.push(Ct);
          }
        } else pe = function(Ge, gt) {
          const Ct = [], ri = Ge.text;
          let Lt = 0;
          for (const At of gt) Ct.push(Ge.substring(Lt, At)), Lt = At;
          return Lt < ri.length && Ct.push(Ge.substring(Lt, ri.length)), Ct;
        }(re, Au(re, E, f, t, o, H));
        const Te = [], ze = { positionedLines: Te, text: re.toString(), top: D[1], bottom: D[1], left: D[0], right: D[0], writingMode: R, iconsInText: !1, verticalizable: !1 };
        return function(Ge, gt, Ct, ri, Lt, At, Ut, Bt, Ft, st, Wt, qt) {
          let hi = 0, Yi = oh, Hi = 0, en = 0;
          const bo = Bt === "right" ? 1 : Bt === "left" ? 0 : 0.5;
          let vn = 0;
          for (const Tr of Lt) {
            Tr.trim();
            const rn = Tr.getMaxScale(), Mn = (rn - 1) * jr, xn = { positionedGlyphs: [], lineOffset: 0 };
            Ge.positionedLines[vn] = xn;
            const Xn = xn.positionedGlyphs;
            let bn = 0;
            if (!Tr.length()) {
              Yi += At, ++vn;
              continue;
            }
            for (let ms = 0; ms < Tr.length(); ms++) {
              const ji = Tr.getSection(ms), ir = Tr.getSectionIndex(ms), ar = Tr.getCharCode(ms);
              let Es = 0, Sr = null, Tc = null, La = null, Ta = jr;
              const wo = !(Ft === _.ah.horizontal || !Wt && !Wl(ar) || Wt && (Ch[ar] || (tn = ar, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(tn)))));
              if (ji.imageName) {
                const Ks = ri[ji.imageName];
                if (!Ks) continue;
                La = ji.imageName, Ge.iconsInText = Ge.iconsInText || !0, Tc = Ks.paddedRect;
                const dn = Ks.displaySize;
                ji.scale = ji.scale * jr / qt, Sr = { width: dn[0], height: dn[1], left: fs, top: -Qd, advance: wo ? dn[1] : dn[0] }, Es = Mn + (jr - dn[1] * ji.scale), Ta = Sr.advance;
                const al = wo ? dn[0] * ji.scale - jr * rn : dn[1] * ji.scale - jr * rn;
                al > 0 && al > bn && (bn = al);
              } else {
                const Ks = Ct[ji.fontStack], dn = Ks && Ks[ar];
                if (dn && dn.rect) Tc = dn.rect, Sr = dn.metrics;
                else {
                  const al = gt[ji.fontStack], ph = al && al[ar];
                  if (!ph) continue;
                  Sr = ph.metrics;
                }
                Es = (rn - ji.scale) * jr;
              }
              wo ? (Ge.verticalizable = !0, Xn.push({ glyph: ar, imageName: La, x: hi, y: Yi + Es, vertical: wo, scale: ji.scale, fontStack: ji.fontStack, sectionIndex: ir, metrics: Sr, rect: Tc }), hi += Ta * ji.scale + st) : (Xn.push({ glyph: ar, imageName: La, x: hi, y: Yi + Es, vertical: wo, scale: ji.scale, fontStack: ji.fontStack, sectionIndex: ir, metrics: Sr, rect: Tc }), hi += Sr.advance * ji.scale + st);
            }
            Xn.length !== 0 && (Hi = Math.max(hi - st, Hi), cg(Xn, 0, Xn.length - 1, bo, bn)), hi = 0;
            const Js = At * rn + bn;
            xn.lineOffset = Math.max(bn, Mn), Yi += Js, en = Math.max(Js, en), ++vn;
          }
          var tn;
          const Gn = Yi - oh, { horizontalAlign: Wn, verticalAlign: Hn } = Pu(Ut);
          (function(Tr, rn, Mn, xn, Xn, bn, Js, ms, ji) {
            const ir = (rn - Mn) * Xn;
            let ar = 0;
            ar = bn !== Js ? -ms * xn - oh : (-xn * ji + 0.5) * Js;
            for (const Es of Tr) for (const Sr of Es.positionedGlyphs) Sr.x += ir, Sr.y += ar;
          })(Ge.positionedLines, bo, Wn, Hn, Hi, en, At, Gn, Lt.length), Ge.top += -Hn * Gn, Ge.bottom = Ge.top + Gn, Ge.left += -Wn * Hi, Ge.right = Ge.left + Hi;
        }(ze, t, n, o, pe, g, P, L, R, E, Z, K), !function(Ge) {
          for (const gt of Ge) if (gt.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Te) && ze;
      }
      const Ch = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, og = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ag = { 40: !0 };
      function ip(i, t, n, o, u, f) {
        if (t.imageName) {
          const g = o[t.imageName];
          return g ? g.displaySize[0] * t.scale * jr / f + u : 0;
        }
        {
          const g = n[t.fontStack], P = g && g[i];
          return P ? P.metrics.advance * t.scale + u : 0;
        }
      }
      function rp(i, t, n, o) {
        const u = Math.pow(i - t, 2);
        return o ? i < t ? u / 2 : 2 * u : u + Math.abs(n) * n;
      }
      function lg(i, t, n) {
        let o = 0;
        return i === 10 && (o -= 1e4), n && (o += 150), i !== 40 && i !== 65288 || (o += 50), t !== 41 && t !== 65289 || (o += 50), o;
      }
      function np(i, t, n, o, u, f) {
        let g = null, P = rp(t, n, u, f);
        for (const L of o) {
          const E = rp(t - L.x, n, u, f) + L.badness;
          E <= P && (g = L, P = E);
        }
        return { index: i, x: t, priorBreak: g, badness: P };
      }
      function sp(i) {
        return i ? sp(i.priorBreak).concat(i.index) : [];
      }
      function Au(i, t, n, o, u, f) {
        if (!i) return [];
        const g = [], P = function(R, Z, H, K, re, pe) {
          let xe = 0;
          for (let Ne = 0; Ne < R.length(); Ne++) {
            const Te = R.getSection(Ne);
            xe += ip(R.getCharCode(Ne), Te, K, re, Z, pe);
          }
          return xe / Math.max(1, Math.ceil(xe / H));
        }(i, t, n, o, u, f), L = i.text.indexOf("​") >= 0;
        let E = 0;
        for (let R = 0; R < i.length(); R++) {
          const Z = i.getSection(R), H = i.getCharCode(R);
          if (Ch[H] || (E += ip(H, Z, o, u, t, f)), R < i.length() - 1) {
            const K = !((D = H) < 11904) && (!!fi["CJK Compatibility Forms"](D) || !!fi["CJK Compatibility"](D) || !!fi["CJK Strokes"](D) || !!fi["CJK Symbols and Punctuation"](D) || !!fi["Enclosed CJK Letters and Months"](D) || !!fi["Halfwidth and Fullwidth Forms"](D) || !!fi["Ideographic Description Characters"](D) || !!fi["Vertical Forms"](D) || Gl.test(String.fromCodePoint(D)));
            (og[H] || K || Z.imageName || R !== i.length() - 2 && ag[i.getCharCode(R + 1)]) && g.push(np(R + 1, E, P, g, lg(H, i.getCharCode(R + 1), K && L), !1));
          }
        }
        var D;
        return sp(np(i.length(), E, P, g, 0, !0));
      }
      function Pu(i) {
        let t = 0.5, n = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            t = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            t = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: t, verticalAlign: n };
      }
      function cg(i, t, n, o, u) {
        if (!o && !u) return;
        const f = i[n], g = (i[n].x + f.metrics.advance * f.scale) * o;
        for (let P = t; P <= n; P++) i[P].x -= g, i[P].y += u;
      }
      function hg(i, t, n) {
        const { horizontalAlign: o, verticalAlign: u } = Pu(n), f = t[0] - i.displaySize[0] * o, g = t[1] - i.displaySize[1] * u;
        return { image: i, top: g, bottom: g + i.displaySize[1], left: f, right: f + i.displaySize[0] };
      }
      function op(i) {
        var t, n;
        let o = i.left, u = i.top, f = i.right - o, g = i.bottom - u;
        const P = (t = i.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", L = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", E = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (L === "proportional") {
          if (P === "stretchOnly" && f / g < E || P === "proportional") {
            const D = Math.ceil(g * E);
            o *= D / f, f = D;
          }
        } else if (P === "proportional" && L === "stretchOnly" && E !== 0 && f / g > E) {
          const D = Math.ceil(f / E);
          u *= D / g, g = D;
        }
        return { x1: o, y1: u, x2: o + f, y2: u + g };
      }
      function ap(i, t, n, o, u, f) {
        const g = i.image;
        let P;
        if (g.content) {
          const pe = g.content, xe = g.pixelRatio || 1;
          P = [pe[0] / xe, pe[1] / xe, g.displaySize[0] - pe[2] / xe, g.displaySize[1] - pe[3] / xe];
        }
        const L = t.left * f, E = t.right * f;
        let D, R, Z, H;
        n === "width" || n === "both" ? (H = u[0] + L - o[3], R = u[0] + E + o[1]) : (H = u[0] + (L + E - g.displaySize[0]) / 2, R = H + g.displaySize[0]);
        const K = t.top * f, re = t.bottom * f;
        return n === "height" || n === "both" ? (D = u[1] + K - o[0], Z = u[1] + re + o[2]) : (D = u[1] + (K + re - g.displaySize[1]) / 2, Z = D + g.displaySize[1]), { image: g, top: D, right: R, bottom: Z, left: H, collisionPadding: P };
      }
      const lh = 255, Ia = 128, Pl = lh * Ia;
      function lp(i, t) {
        const { expression: n } = t;
        if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Gi(i + 1)) };
        if (n.kind === "source") return { kind: "source" };
        {
          const { zoomStops: o, interpolationType: u } = n;
          let f = 0;
          for (; f < o.length && o[f] <= i; ) f++;
          f = Math.max(0, f - 1);
          let g = f;
          for (; g < o.length && o[g] < i + 1; ) g++;
          g = Math.min(o.length - 1, g);
          const P = o[f], L = o[g];
          return n.kind === "composite" ? { kind: "composite", minZoom: P, maxZoom: L, interpolationType: u } : { kind: "camera", minZoom: P, maxZoom: L, minSize: n.evaluate(new Gi(P)), maxSize: n.evaluate(new Gi(L)), interpolationType: u };
        }
      }
      function Iu(i, t, n) {
        let o = "never";
        const u = i.get(t);
        return u ? o = u : i.get(n) && (o = "always"), o;
      }
      const ug = Sl.VectorTileFeature.types, dg = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Eh(i, t, n, o, u, f, g, P, L, E, D, R, Z) {
        const H = P ? Math.min(Pl, Math.round(P[0])) : 0, K = P ? Math.min(Pl, Math.round(P[1])) : 0;
        i.emplaceBack(t, n, Math.round(32 * o), Math.round(32 * u), f, g, (H << 1) + (L ? 1 : 0), K, 16 * E, 16 * D, 256 * R, 256 * Z);
      }
      function Lu(i, t, n) {
        i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n), i.emplaceBack(t.x, t.y, n);
      }
      function pg(i) {
        for (const t of i.sections) if (hc(t.text)) return !0;
        return !1;
      }
      class Tu {
        constructor(t) {
          this.layoutVertexArray = new tl(), this.indexArray = new Kr(), this.programConfigurations = t, this.segments = new Ti(), this.dynamicLayoutVertexArray = new va(), this.opacityVertexArray = new Jr(), this.hasVisibleVertices = !1, this.placedSymbolArray = new ni();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t, n, o, u) {
          this.isEmpty() || (o && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Um.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, $m.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, dg, !0), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      Nt("SymbolBuffers", Tu);
      class ku {
        constructor(t, n, o) {
          this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new o(), this.segments = new Ti(), this.collisionVertexArray = new Dr();
        }
        upload(t) {
          this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Zm.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      Nt("CollisionBuffers", ku);
      class Pc {
        constructor(t) {
          this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((g) => g.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = lu([]), this.placementViewportMatrix = lu([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = lp(this.zoom, n["text-size"]), this.iconSizeData = lp(this.zoom, n["icon-size"]);
          const o = this.layers[0].layout, u = o.get("symbol-sort-key"), f = o.get("symbol-z-order");
          this.canOverlap = Iu(o, "text-overlap", "text-allow-overlap") !== "never" || Iu(o, "icon-overlap", "icon-allow-overlap") !== "never" || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = f !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (f === "viewport-y" || f === "auto" && !this.sortFeaturesByKey) && this.canOverlap, o.get("symbol-placement") === "point" && (this.writingModes = o.get("text-writing-mode").map((g) => _.ah[g])), this.stateDependentLayerIds = this.layers.filter((g) => g.isStateDependent()).map((g) => g.id), this.sourceID = t.sourceID;
        }
        createArrays() {
          this.text = new Tu(new wa(this.layers, this.zoom, (t) => /^text/.test(t))), this.icon = new Tu(new wa(this.layers, this.zoom, (t) => /^icon/.test(t))), this.glyphOffsetArray = new xi(), this.lineVertexArray = new Bi(), this.symbolInstances = new ci(), this.textAnchorOffsets = new zi();
        }
        calculateGlyphDependencies(t, n, o, u, f) {
          for (let g = 0; g < t.length; g++) if (n[t.charCodeAt(g)] = !0, (o || u) && f) {
            const P = sh[t.charAt(g)];
            P && (n[P.charCodeAt(0)] = !0);
          }
        }
        populate(t, n, o) {
          const u = this.layers[0], f = u.layout, g = f.get("text-font"), P = f.get("text-field"), L = f.get("icon-image"), E = (P.value.kind !== "constant" || P.value.value instanceof Zr && !P.value.value.isEmpty() || P.value.value.toString().length > 0) && (g.value.kind !== "constant" || g.value.value.length > 0), D = L.value.kind !== "constant" || !!L.value.value || Object.keys(L.parameters).length > 0, R = f.get("symbol-sort-key");
          if (this.features = [], !E && !D) return;
          const Z = n.iconDependencies, H = n.glyphDependencies, K = n.availableImages, re = new Gi(this.zoom);
          for (const { feature: pe, id: xe, index: Ne, sourceLayerIndex: Te } of t) {
            const ze = u._featureFilter.needGeometry, Ge = Sa(pe, ze);
            if (!u._featureFilter.filter(re, Ge, o)) continue;
            let gt, Ct;
            if (ze || (Ge.geometry = nl(pe)), E) {
              const Lt = u.getValueAndResolveTokens("text-field", Ge, o, K), At = Zr.factory(Lt), Ut = this.hasRTLText = this.hasRTLText || pg(At);
              (!Ut || Tn.getRTLTextPluginStatus() === "unavailable" || Ut && Tn.isParsed()) && (gt = Wm(At, u, Ge));
            }
            if (D) {
              const Lt = u.getValueAndResolveTokens("icon-image", Ge, o, K);
              Ct = Lt instanceof Gr ? Lt : Gr.fromString(Lt);
            }
            if (!gt && !Ct) continue;
            const ri = this.sortFeaturesByKey ? R.evaluate(Ge, {}, o) : void 0;
            if (this.features.push({ id: xe, text: gt, icon: Ct, index: Ne, sourceLayerIndex: Te, geometry: Ge.geometry, properties: pe.properties, type: ug[pe.type], sortKey: ri }), Ct && (Z[Ct.name] = !0), gt) {
              const Lt = g.evaluate(Ge, {}, o).join(","), At = f.get("text-rotation-alignment") !== "viewport" && f.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(_.ah.vertical) >= 0;
              for (const Ut of gt.sections) if (Ut.image) Z[Ut.image.name] = !0;
              else {
                const Bt = Zl(gt.toString()), Ft = Ut.fontStack || Lt, st = H[Ft] = H[Ft] || {};
                this.calculateGlyphDependencies(Ut.text, st, At, this.allowVerticalPlacement, Bt);
              }
            }
          }
          f.get("symbol-placement") === "line" && (this.features = function(pe) {
            const xe = {}, Ne = {}, Te = [];
            let ze = 0;
            function Ge(Lt) {
              Te.push(pe[Lt]), ze++;
            }
            function gt(Lt, At, Ut) {
              const Bt = Ne[Lt];
              return delete Ne[Lt], Ne[At] = Bt, Te[Bt].geometry[0].pop(), Te[Bt].geometry[0] = Te[Bt].geometry[0].concat(Ut[0]), Bt;
            }
            function Ct(Lt, At, Ut) {
              const Bt = xe[At];
              return delete xe[At], xe[Lt] = Bt, Te[Bt].geometry[0].shift(), Te[Bt].geometry[0] = Ut[0].concat(Te[Bt].geometry[0]), Bt;
            }
            function ri(Lt, At, Ut) {
              const Bt = Ut ? At[0][At[0].length - 1] : At[0][0];
              return `${Lt}:${Bt.x}:${Bt.y}`;
            }
            for (let Lt = 0; Lt < pe.length; Lt++) {
              const At = pe[Lt], Ut = At.geometry, Bt = At.text ? At.text.toString() : null;
              if (!Bt) {
                Ge(Lt);
                continue;
              }
              const Ft = ri(Bt, Ut), st = ri(Bt, Ut, !0);
              if (Ft in Ne && st in xe && Ne[Ft] !== xe[st]) {
                const Wt = Ct(Ft, st, Ut), qt = gt(Ft, st, Te[Wt].geometry);
                delete xe[Ft], delete Ne[st], Ne[ri(Bt, Te[qt].geometry, !0)] = qt, Te[Wt].geometry = null;
              } else Ft in Ne ? gt(Ft, st, Ut) : st in xe ? Ct(Ft, st, Ut) : (Ge(Lt), xe[Ft] = ze - 1, Ne[st] = ze - 1);
            }
            return Te.filter((Lt) => Lt.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((pe, xe) => pe.sortKey - xe.sortKey);
        }
        update(t, n, o) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, o), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, o));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t, n) {
          const o = this.lineVertexArray.length;
          if (t.segment !== void 0) {
            let u = t.dist(n[t.segment + 1]), f = t.dist(n[t.segment]);
            const g = {};
            for (let P = t.segment + 1; P < n.length; P++) g[P] = { x: n[P].x, y: n[P].y, tileUnitDistanceFromAnchor: u }, P < n.length - 1 && (u += n[P + 1].dist(n[P]));
            for (let P = t.segment || 0; P >= 0; P--) g[P] = { x: n[P].x, y: n[P].y, tileUnitDistanceFromAnchor: f }, P > 0 && (f += n[P - 1].dist(n[P]));
            for (let P = 0; P < n.length; P++) {
              const L = g[P];
              this.lineVertexArray.emplaceBack(L.x, L.y, L.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: o, lineLength: this.lineVertexArray.length - o };
        }
        addSymbols(t, n, o, u, f, g, P, L, E, D, R, Z) {
          const H = t.indexArray, K = t.layoutVertexArray, re = t.segments.prepareSegment(4 * n.length, K, H, this.canOverlap ? g.sortKey : void 0), pe = this.glyphOffsetArray.length, xe = re.vertexLength, Ne = this.allowVerticalPlacement && P === _.ah.vertical ? Math.PI / 2 : 0, Te = g.text && g.text.sections;
          for (let ze = 0; ze < n.length; ze++) {
            const { tl: Ge, tr: gt, bl: Ct, br: ri, tex: Lt, pixelOffsetTL: At, pixelOffsetBR: Ut, minFontScaleX: Bt, minFontScaleY: Ft, glyphOffset: st, isSDF: Wt, sectionIndex: qt } = n[ze], hi = re.vertexLength, Yi = st[1];
            Eh(K, L.x, L.y, Ge.x, Yi + Ge.y, Lt.x, Lt.y, o, Wt, At.x, At.y, Bt, Ft), Eh(K, L.x, L.y, gt.x, Yi + gt.y, Lt.x + Lt.w, Lt.y, o, Wt, Ut.x, At.y, Bt, Ft), Eh(K, L.x, L.y, Ct.x, Yi + Ct.y, Lt.x, Lt.y + Lt.h, o, Wt, At.x, Ut.y, Bt, Ft), Eh(K, L.x, L.y, ri.x, Yi + ri.y, Lt.x + Lt.w, Lt.y + Lt.h, o, Wt, Ut.x, Ut.y, Bt, Ft), Lu(t.dynamicLayoutVertexArray, L, Ne), H.emplaceBack(hi, hi + 1, hi + 2), H.emplaceBack(hi + 1, hi + 2, hi + 3), re.vertexLength += 4, re.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(st[0]), ze !== n.length - 1 && qt === n[ze + 1].sectionIndex || t.programConfigurations.populatePaintArrays(K.length, g, g.index, {}, Z, Te && Te[qt]);
          }
          t.placedSymbolArray.emplaceBack(L.x, L.y, pe, this.glyphOffsetArray.length - pe, xe, E, D, L.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], P, 0, !1, 0, R);
        }
        _addCollisionDebugVertex(t, n, o, u, f, g) {
          return n.emplaceBack(0, 0), t.emplaceBack(o.x, o.y, u, f, Math.round(g.x), Math.round(g.y));
        }
        addCollisionDebugVertices(t, n, o, u, f, g, P) {
          const L = f.segments.prepareSegment(4, f.layoutVertexArray, f.indexArray), E = L.vertexLength, D = f.layoutVertexArray, R = f.collisionVertexArray, Z = P.anchorX, H = P.anchorY;
          this._addCollisionDebugVertex(D, R, g, Z, H, new j(t, n)), this._addCollisionDebugVertex(D, R, g, Z, H, new j(o, n)), this._addCollisionDebugVertex(D, R, g, Z, H, new j(o, u)), this._addCollisionDebugVertex(D, R, g, Z, H, new j(t, u)), L.vertexLength += 4;
          const K = f.indexArray;
          K.emplaceBack(E, E + 1), K.emplaceBack(E + 1, E + 2), K.emplaceBack(E + 2, E + 3), K.emplaceBack(E + 3, E), L.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t, n, o, u) {
          for (let f = t; f < n; f++) {
            const g = this.collisionBoxArray.get(f);
            this.addCollisionDebugVertices(g.x1, g.y1, g.x2, g.y2, u ? this.textCollisionBox : this.iconCollisionBox, g.anchorPoint, o);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ku(un, Zd.members, yr), this.iconCollisionBox = new ku(un, Zd.members, yr);
          for (let t = 0; t < this.symbolInstances.length; t++) {
            const n = this.symbolInstances.get(t);
            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(t, n, o, u, f, g, P, L, E) {
          const D = {};
          for (let R = n; R < o; R++) {
            const Z = t.get(R);
            D.textBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, D.textFeatureIndex = Z.featureIndex;
            break;
          }
          for (let R = u; R < f; R++) {
            const Z = t.get(R);
            D.verticalTextBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, D.verticalTextFeatureIndex = Z.featureIndex;
            break;
          }
          for (let R = g; R < P; R++) {
            const Z = t.get(R);
            D.iconBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, D.iconFeatureIndex = Z.featureIndex;
            break;
          }
          for (let R = L; R < E; R++) {
            const Z = t.get(R);
            D.verticalIconBox = { x1: Z.x1, y1: Z.y1, x2: Z.x2, y2: Z.y2, anchorPointX: Z.anchorPointX, anchorPointY: Z.anchorPointY }, D.verticalIconFeatureIndex = Z.featureIndex;
            break;
          }
          return D;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const o = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t, n) {
          const o = t.placedSymbolArray.get(n), u = o.vertexStartIndex + 4 * o.numGlyphs;
          for (let f = o.vertexStartIndex; f < u; f += 4) t.indexArray.emplaceBack(f, f + 1, f + 2), t.indexArray.emplaceBack(f + 1, f + 2, f + 3);
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const n = Math.sin(t), o = Math.cos(t), u = [], f = [], g = [];
          for (let P = 0; P < this.symbolInstances.length; ++P) {
            g.push(P);
            const L = this.symbolInstances.get(P);
            u.push(0 | Math.round(n * L.anchorX + o * L.anchorY)), f.push(L.featureIndex);
          }
          return g.sort((P, L) => u[P] - u[L] || f[L] - f[P]), g;
        }
        addToSortKeyRanges(t, n) {
          const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          o && o.sortKey === n ? o.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
        }
        sortFeatures(t) {
          if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const o = this.symbolInstances.get(n);
              this.featureSortOrder.push(o.featureIndex), [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach((u, f, g) => {
                u >= 0 && g.indexOf(u) === f && this.addIndicesForPlacedSymbol(this.text, u);
              }), o.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, o.verticalPlacedTextSymbolIndex), o.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.placedIconSymbolIndex), o.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, o.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let cp, hp;
      Nt("SymbolBucket", Pc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Pc.MAX_GLYPHS = 65535, Pc.addDynamicAttributes = Lu;
      var Cu = { get paint() {
        return hp = hp || new a({ "icon-opacity": new Kt(Y.paint_symbol["icon-opacity"]), "icon-color": new Kt(Y.paint_symbol["icon-color"]), "icon-halo-color": new Kt(Y.paint_symbol["icon-halo-color"]), "icon-halo-width": new Kt(Y.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Kt(Y.paint_symbol["icon-halo-blur"]), "icon-translate": new jt(Y.paint_symbol["icon-translate"]), "icon-translate-anchor": new jt(Y.paint_symbol["icon-translate-anchor"]), "text-opacity": new Kt(Y.paint_symbol["text-opacity"]), "text-color": new Kt(Y.paint_symbol["text-color"], { runtimeType: Ei, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new Kt(Y.paint_symbol["text-halo-color"]), "text-halo-width": new Kt(Y.paint_symbol["text-halo-width"]), "text-halo-blur": new Kt(Y.paint_symbol["text-halo-blur"]), "text-translate": new jt(Y.paint_symbol["text-translate"]), "text-translate-anchor": new jt(Y.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return cp = cp || new a({ "symbol-placement": new jt(Y.layout_symbol["symbol-placement"]), "symbol-spacing": new jt(Y.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new jt(Y.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Kt(Y.layout_symbol["symbol-sort-key"]), "symbol-z-order": new jt(Y.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new jt(Y.layout_symbol["icon-allow-overlap"]), "icon-overlap": new jt(Y.layout_symbol["icon-overlap"]), "icon-ignore-placement": new jt(Y.layout_symbol["icon-ignore-placement"]), "icon-optional": new jt(Y.layout_symbol["icon-optional"]), "icon-rotation-alignment": new jt(Y.layout_symbol["icon-rotation-alignment"]), "icon-size": new Kt(Y.layout_symbol["icon-size"]), "icon-text-fit": new jt(Y.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new jt(Y.layout_symbol["icon-text-fit-padding"]), "icon-image": new Kt(Y.layout_symbol["icon-image"]), "icon-rotate": new Kt(Y.layout_symbol["icon-rotate"]), "icon-padding": new Kt(Y.layout_symbol["icon-padding"]), "icon-keep-upright": new jt(Y.layout_symbol["icon-keep-upright"]), "icon-offset": new Kt(Y.layout_symbol["icon-offset"]), "icon-anchor": new Kt(Y.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new jt(Y.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new jt(Y.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new jt(Y.layout_symbol["text-rotation-alignment"]), "text-field": new Kt(Y.layout_symbol["text-field"]), "text-font": new Kt(Y.layout_symbol["text-font"]), "text-size": new Kt(Y.layout_symbol["text-size"]), "text-max-width": new Kt(Y.layout_symbol["text-max-width"]), "text-line-height": new jt(Y.layout_symbol["text-line-height"]), "text-letter-spacing": new Kt(Y.layout_symbol["text-letter-spacing"]), "text-justify": new Kt(Y.layout_symbol["text-justify"]), "text-radial-offset": new Kt(Y.layout_symbol["text-radial-offset"]), "text-variable-anchor": new jt(Y.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Kt(Y.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Kt(Y.layout_symbol["text-anchor"]), "text-max-angle": new jt(Y.layout_symbol["text-max-angle"]), "text-writing-mode": new jt(Y.layout_symbol["text-writing-mode"]), "text-rotate": new Kt(Y.layout_symbol["text-rotate"]), "text-padding": new jt(Y.layout_symbol["text-padding"]), "text-keep-upright": new jt(Y.layout_symbol["text-keep-upright"]), "text-transform": new Kt(Y.layout_symbol["text-transform"]), "text-offset": new Kt(Y.layout_symbol["text-offset"]), "text-allow-overlap": new jt(Y.layout_symbol["text-allow-overlap"]), "text-overlap": new jt(Y.layout_symbol["text-overlap"]), "text-ignore-placement": new jt(Y.layout_symbol["text-ignore-placement"]), "text-optional": new jt(Y.layout_symbol["text-optional"]) });
      } };
      class up {
        constructor(t) {
          if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t.property.overrides ? t.property.overrides.runtimeType : cr, this.defaultValue = t;
        }
        evaluate(t) {
          if (t.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Nt("FormatSectionOverride", up, { omit: ["defaultValue"] });
      class Mh extends r {
        constructor(t) {
          super(t, Cu);
        }
        recalculate(t, n) {
          if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const o = this.layout.get("text-writing-mode");
            if (o) {
              const u = [];
              for (const f of o) u.indexOf(f) < 0 && u.push(f);
              this.layout._values["text-writing-mode"] = u;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, n, o, u) {
          const f = this.layout.get(t).evaluate(n, {}, o, u), g = this._unevaluatedLayout._values[t];
          return g.isDataDriven() || cs(g.value) || !f ? f : function(P, L) {
            return L.replace(/{([^{}]+)}/g, (E, D) => P && D in P ? String(P[D]) : "");
          }(n.properties, f);
        }
        createBucket(t) {
          return new Pc(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t of Cu.paint.overridableProperties) {
            if (!Mh.hasPaintOverride(this.layout, t)) continue;
            const n = this.paint.get(t), o = new up(n), u = new ho(o, n.property.specification);
            let f = null;
            f = n.value.kind === "constant" || n.value.kind === "source" ? new gn("source", u) : new Bn("composite", u, n.value.zoomStops), this.paint._values[t] = new ds(n.property, f, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t, n, o) {
          return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && Mh.hasPaintOverride(this.layout, t);
        }
        static hasPaintOverride(t, n) {
          const o = t.get("text-field"), u = Cu.paint.properties[n];
          let f = !1;
          const g = (P) => {
            for (const L of P) if (u.overrides && u.overrides.hasOverride(L)) return void (f = !0);
          };
          if (o.value.kind === "constant" && o.value.value instanceof Zr) g(o.value.value.sections);
          else if (o.value.kind === "source") {
            const P = (E) => {
              f || (E instanceof fn && mr(E.value) === qi ? g(E.value.sections) : E instanceof ia ? g(E.sections) : E.eachChild(P));
            }, L = o.value;
            L._styleExpression && P(L._styleExpression.expression);
          }
          return f;
        }
      }
      let dp;
      var fg = { get paint() {
        return dp = dp || new a({ "background-color": new jt(Y.paint_background["background-color"]), "background-pattern": new m(Y.paint_background["background-pattern"]), "background-opacity": new jt(Y.paint_background["background-opacity"]) });
      } };
      class mg extends r {
        constructor(t) {
          super(t, fg);
        }
      }
      let pp;
      var gg = { get paint() {
        return pp = pp || new a({ "raster-opacity": new jt(Y.paint_raster["raster-opacity"]), "raster-hue-rotate": new jt(Y.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new jt(Y.paint_raster["raster-brightness-min"]), "raster-brightness-max": new jt(Y.paint_raster["raster-brightness-max"]), "raster-saturation": new jt(Y.paint_raster["raster-saturation"]), "raster-contrast": new jt(Y.paint_raster["raster-contrast"]), "raster-resampling": new jt(Y.paint_raster["raster-resampling"]), "raster-fade-duration": new jt(Y.paint_raster["raster-fade-duration"]) });
      } };
      class yg extends r {
        constructor(t) {
          super(t, gg);
        }
      }
      class _g extends r {
        constructor(t) {
          super(t, {}), this.onAdd = (n) => {
            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
          }, this.onRemove = (n) => {
            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
          }, this.implementation = t;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class vg {
        constructor(t) {
          this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const Eu = 63710088e-1;
      class Il {
        constructor(t, n) {
          if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
          if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Il(tt(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const n = Math.PI / 180, o = this.lat * n, u = t.lat * n, f = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((t.lng - this.lng) * n);
          return Eu * Math.acos(Math.min(f, 1));
        }
        static convert(t) {
          if (t instanceof Il) return t;
          if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Il(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Il(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const fp = 2 * Math.PI * Eu;
      function mp(i) {
        return fp * Math.cos(i * Math.PI / 180);
      }
      function gp(i) {
        return (180 + i) / 360;
      }
      function yp(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function _p(i, t) {
        return i / mp(t);
      }
      function Mu(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class ch {
        constructor(t, n, o = 0) {
          this.x = +t, this.y = +n, this.z = +o;
        }
        static fromLngLat(t, n = 0) {
          const o = Il.convert(t);
          return new ch(gp(o.lng), yp(o.lat), _p(n, o.lat));
        }
        toLngLat() {
          return new Il(360 * this.x - 180, Mu(this.y));
        }
        toAltitude() {
          return this.z * mp(Mu(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / fp * (t = Mu(this.y), 1 / Math.cos(t * Math.PI / 180));
          var t;
        }
      }
      function vp(i, t, n) {
        var o = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
        return [i * o - 2 * Math.PI * 6378137 / 2, t * o - 2 * Math.PI * 6378137 / 2];
      }
      class zu {
        constructor(t, n, o) {
          if (!function(u, f, g) {
            return !(u < 0 || u > 25 || g < 0 || g >= Math.pow(2, u) || f < 0 || f >= Math.pow(2, u));
          }(t, n, o)) throw new Error(`x=${n}, y=${o}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
          this.z = t, this.x = n, this.y = o, this.key = hh(0, t, t, n, o);
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, n, o) {
          const u = (g = this.y, P = this.z, L = vp(256 * (f = this.x), 256 * (g = Math.pow(2, P) - g - 1), P), E = vp(256 * (f + 1), 256 * (g + 1), P), L[0] + "," + L[1] + "," + E[0] + "," + E[1]);
          var f, g, P, L, E;
          const D = function(R, Z, H) {
            let K, re = "";
            for (let pe = R; pe > 0; pe--) K = 1 << pe - 1, re += (Z & K ? 1 : 0) + (H & K ? 2 : 0);
            return re;
          }(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(o === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, D).replace(/{bbox-epsg-3857}/g, u);
        }
        isChildOf(t) {
          const n = this.z - t.z;
          return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
        }
        getTilePoint(t) {
          const n = Math.pow(2, this.z);
          return new j((t.x * n - this.x) * tr, (t.y * n - this.y) * tr);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class xp {
        constructor(t, n) {
          this.wrap = t, this.canonical = n, this.key = hh(t, n.z, n.z, n.x, n.y);
        }
      }
      class Ys {
        constructor(t, n, o, u, f) {
          if (t < o) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${o}`);
          this.overscaledZ = t, this.wrap = n, this.canonical = new zu(o, +u, +f), this.key = hh(n, t, o, u, f);
        }
        clone() {
          return new Ys(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t) {
          return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
        }
        scaledTo(t) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const n = this.canonical.z - t;
          return t > this.canonical.z ? new Ys(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ys(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(t, n) {
          if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
          const o = this.canonical.z - t;
          return t > this.canonical.z ? hh(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : hh(this.wrap * +n, t, t, this.canonical.x >> o, this.canonical.y >> o);
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          const n = this.canonical.z - t.canonical.z;
          return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
        }
        children(t) {
          if (this.overscaledZ >= t) return [new Ys(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, o = 2 * this.canonical.x, u = 2 * this.canonical.y;
          return [new Ys(n, this.wrap, n, o, u), new Ys(n, this.wrap, n, o + 1, u), new Ys(n, this.wrap, n, o, u + 1), new Ys(n, this.wrap, n, o + 1, u + 1)];
        }
        isLessThan(t) {
          return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
        }
        wrapped() {
          return new Ys(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t) {
          return new Ys(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new xp(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t) {
          return this.canonical.getTilePoint(new ch(t.x - this.wrap, t.y));
        }
      }
      function hh(i, t, n, o, u) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const f = 1 << n;
        return (f * f * i + f * u + o).toString(36) + n.toString(36) + t.toString(36);
      }
      Nt("CanonicalTileID", zu), Nt("OverscaledTileID", Ys, { omit: ["posMatrix"] });
      class bp {
        constructor(t, n, o, u = 1, f = 1, g = 1, P = 0) {
          if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
          if (o && !["mapbox", "terrarium", "custom"].includes(o)) return void Le(`"${o}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = n.height;
          const L = this.dim = n.height - 2;
          switch (this.data = new Uint32Array(n.data.buffer), o) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = u, this.greenFactor = f, this.blueFactor = g, this.baseShift = P;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let E = 0; E < L; E++) this.data[this._idx(-1, E)] = this.data[this._idx(0, E)], this.data[this._idx(L, E)] = this.data[this._idx(L - 1, E)], this.data[this._idx(E, -1)] = this.data[this._idx(E, 0)], this.data[this._idx(E, L)] = this.data[this._idx(E, L - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(L, -1)] = this.data[this._idx(L - 1, 0)], this.data[this._idx(-1, L)] = this.data[this._idx(0, L - 1)], this.data[this._idx(L, L)] = this.data[this._idx(L - 1, L - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let E = 0; E < L; E++) for (let D = 0; D < L; D++) {
            const R = this.get(E, D);
            R > this.max && (this.max = R), R < this.min && (this.min = R);
          }
        }
        get(t, n) {
          const o = new Uint8Array(this.data.buffer), u = 4 * this._idx(t, n);
          return this.unpack(o[u], o[u + 1], o[u + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t, n) {
          if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (t + 1);
        }
        unpack(t, n, o) {
          return t * this.redFactor + n * this.greenFactor + o * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Xs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t, n, o) {
          if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
          let u = n * this.dim, f = n * this.dim + this.dim, g = o * this.dim, P = o * this.dim + this.dim;
          switch (n) {
            case -1:
              u = f - 1;
              break;
            case 1:
              f = u + 1;
          }
          switch (o) {
            case -1:
              g = P - 1;
              break;
            case 1:
              P = g + 1;
          }
          const L = -n * this.dim, E = -o * this.dim;
          for (let D = g; D < P; D++) for (let R = u; R < f; R++) this.data[this._idx(R, D)] = t.data[this._idx(R + L, D + E)];
        }
      }
      Nt("DEMData", bp);
      class wp {
        constructor(t) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            this._stringToNumber[o] = n, this._numberToString[n] = o;
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t];
        }
      }
      class Sp {
        constructor(t, n, o, u, f) {
          this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = o, t._y = u, this.properties = t.properties, this.id = f;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { geometry: this.geometry };
          for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
          return t;
        }
      }
      class Ap {
        constructor(t, n) {
          this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ga(tr, 16, 0), this.grid3D = new ga(tr, 16, 0), this.featureIndexArray = new Oi(), this.promoteId = n;
        }
        insert(t, n, o, u, f, g) {
          const P = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(o, u, f);
          const L = g ? this.grid3D : this.grid;
          for (let E = 0; E < n.length; E++) {
            const D = n[E], R = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let Z = 0; Z < D.length; Z++) {
              const H = D[Z];
              R[0] = Math.min(R[0], H.x), R[1] = Math.min(R[1], H.y), R[2] = Math.max(R[2], H.x), R[3] = Math.max(R[3], H.y);
            }
            R[0] < tr && R[1] < tr && R[2] >= 0 && R[3] >= 0 && L.insert(P, R[0], R[1], R[2], R[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Sl.VectorTile(new bu(this.rawTileData)).layers, this.sourceLayerCoder = new wp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t, n, o, u) {
          this.loadVTLayers();
          const f = t.params || {}, g = tr / t.tileSize / t.scale, P = hs(f.filter), L = t.queryGeometry, E = t.queryPadding * g, D = Ip(L), R = this.grid.query(D.minX - E, D.minY - E, D.maxX + E, D.maxY + E), Z = Ip(t.cameraQueryGeometry), H = this.grid3D.query(Z.minX - E, Z.minY - E, Z.maxX + E, Z.maxY + E, (pe, xe, Ne, Te) => function(ze, Ge, gt, Ct, ri) {
            for (const At of ze) if (Ge <= At.x && gt <= At.y && Ct >= At.x && ri >= At.y) return !0;
            const Lt = [new j(Ge, gt), new j(Ge, ri), new j(Ct, ri), new j(Ct, gt)];
            if (ze.length > 2) {
              for (const At of Lt) if (Pa(ze, At)) return !0;
            }
            for (let At = 0; At < ze.length - 1; At++) if (Yc(ze[At], ze[At + 1], Lt)) return !0;
            return !1;
          }(t.cameraQueryGeometry, pe - E, xe - E, Ne + E, Te + E));
          for (const pe of H) R.push(pe);
          R.sort(xg);
          const K = {};
          let re;
          for (let pe = 0; pe < R.length; pe++) {
            const xe = R[pe];
            if (xe === re) continue;
            re = xe;
            const Ne = this.featureIndexArray.get(xe);
            let Te = null;
            this.loadMatchingFeature(K, Ne.bucketIndex, Ne.sourceLayerIndex, Ne.featureIndex, P, f.layers, f.availableImages, n, o, u, (ze, Ge, gt) => (Te || (Te = nl(ze)), Ge.queryIntersectsFeature(L, ze, gt, Te, this.z, t.transform, g, t.pixelPosMatrix)));
          }
          return K;
        }
        loadMatchingFeature(t, n, o, u, f, g, P, L, E, D, R) {
          const Z = this.bucketLayerIDs[n];
          if (g && !function(pe, xe) {
            for (let Ne = 0; Ne < pe.length; Ne++) if (xe.indexOf(pe[Ne]) >= 0) return !0;
            return !1;
          }(g, Z)) return;
          const H = this.sourceLayerCoder.decode(o), K = this.vtLayers[H].feature(u);
          if (f.needGeometry) {
            const pe = Sa(K, !0);
            if (!f.filter(new Gi(this.tileID.overscaledZ), pe, this.tileID.canonical)) return;
          } else if (!f.filter(new Gi(this.tileID.overscaledZ), K)) return;
          const re = this.getId(K, H);
          for (let pe = 0; pe < Z.length; pe++) {
            const xe = Z[pe];
            if (g && g.indexOf(xe) < 0) continue;
            const Ne = L[xe];
            if (!Ne) continue;
            let Te = {};
            re && D && (Te = D.getState(Ne.sourceLayer || "_geojsonTileLayer", re));
            const ze = Be({}, E[xe]);
            ze.paint = Pp(ze.paint, Ne.paint, K, Te, P), ze.layout = Pp(ze.layout, Ne.layout, K, Te, P);
            const Ge = !R || R(K, Ne, Te);
            if (!Ge) continue;
            const gt = new Sp(K, this.z, this.x, this.y, re);
            gt.layer = ze;
            let Ct = t[xe];
            Ct === void 0 && (Ct = t[xe] = []), Ct.push({ featureIndex: u, feature: gt, intersectionZ: Ge });
          }
        }
        lookupSymbolFeatures(t, n, o, u, f, g, P, L) {
          const E = {};
          this.loadVTLayers();
          const D = hs(f);
          for (const R of t) this.loadMatchingFeature(E, o, u, R, D, g, P, L, n);
          return E;
        }
        hasLayer(t) {
          for (const n of this.bucketLayerIDs) for (const o of n) if (t === o) return !0;
          return !1;
        }
        getId(t, n) {
          let o = t.id;
          return this.promoteId && (o = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof o == "boolean" && (o = Number(o))), o;
        }
      }
      function Pp(i, t, n, o, u) {
        return ot(i, (f, g) => {
          const P = t instanceof mo ? t.get(g) : null;
          return P && P.evaluate ? P.evaluate(n, o, u) : P;
        });
      }
      function Ip(i) {
        let t = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const f of i) t = Math.min(t, f.x), n = Math.min(n, f.y), o = Math.max(o, f.x), u = Math.max(u, f.y);
        return { minX: t, minY: n, maxX: o, maxY: u };
      }
      function xg(i, t) {
        return t - i;
      }
      function Lp(i, t, n, o, u) {
        const f = [];
        for (let g = 0; g < i.length; g++) {
          const P = i[g];
          let L;
          for (let E = 0; E < P.length - 1; E++) {
            let D = P[E], R = P[E + 1];
            D.x < t && R.x < t || (D.x < t ? D = new j(t, D.y + (t - D.x) / (R.x - D.x) * (R.y - D.y))._round() : R.x < t && (R = new j(t, D.y + (t - D.x) / (R.x - D.x) * (R.y - D.y))._round()), D.y < n && R.y < n || (D.y < n ? D = new j(D.x + (n - D.y) / (R.y - D.y) * (R.x - D.x), n)._round() : R.y < n && (R = new j(D.x + (n - D.y) / (R.y - D.y) * (R.x - D.x), n)._round()), D.x >= o && R.x >= o || (D.x >= o ? D = new j(o, D.y + (o - D.x) / (R.x - D.x) * (R.y - D.y))._round() : R.x >= o && (R = new j(o, D.y + (o - D.x) / (R.x - D.x) * (R.y - D.y))._round()), D.y >= u && R.y >= u || (D.y >= u ? D = new j(D.x + (u - D.y) / (R.y - D.y) * (R.x - D.x), u)._round() : R.y >= u && (R = new j(D.x + (u - D.y) / (R.y - D.y) * (R.x - D.x), u)._round()), L && D.equals(L[L.length - 1]) || (L = [D], f.push(L)), L.push(R)))));
          }
        }
        return f;
      }
      Nt("FeatureIndex", Ap, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Ll extends j {
        constructor(t, n, o, u) {
          super(t, n), this.angle = o, u !== void 0 && (this.segment = u);
        }
        clone() {
          return new Ll(this.x, this.y, this.angle, this.segment);
        }
      }
      function Tp(i, t, n, o, u) {
        if (t.segment === void 0 || n === 0) return !0;
        let f = t, g = t.segment + 1, P = 0;
        for (; P > -n / 2; ) {
          if (g--, g < 0) return !1;
          P -= i[g].dist(f), f = i[g];
        }
        P += i[g].dist(i[g + 1]), g++;
        const L = [];
        let E = 0;
        for (; P < n / 2; ) {
          const D = i[g], R = i[g + 1];
          if (!R) return !1;
          let Z = i[g - 1].angleTo(D) - D.angleTo(R);
          for (Z = Math.abs((Z + 3 * Math.PI) % (2 * Math.PI) - Math.PI), L.push({ distance: P, angleDelta: Z }), E += Z; P - L[0].distance > o; ) E -= L.shift().angleDelta;
          if (E > u) return !1;
          g++, P += D.dist(R);
        }
        return !0;
      }
      function kp(i) {
        let t = 0;
        for (let n = 0; n < i.length - 1; n++) t += i[n].dist(i[n + 1]);
        return t;
      }
      function Cp(i, t, n) {
        return i ? 0.6 * t * n : 0;
      }
      function Ep(i, t) {
        return Math.max(i ? i.right - i.left : 0, t ? t.right - t.left : 0);
      }
      function bg(i, t, n, o, u, f) {
        const g = Cp(n, u, f), P = Ep(n, o) * f;
        let L = 0;
        const E = kp(i) / 2;
        for (let D = 0; D < i.length - 1; D++) {
          const R = i[D], Z = i[D + 1], H = R.dist(Z);
          if (L + H > E) {
            const K = (E - L) / H, re = Rr.number(R.x, Z.x, K), pe = Rr.number(R.y, Z.y, K), xe = new Ll(re, pe, Z.angleTo(R), D);
            return xe._round(), !g || Tp(i, xe, P, g, t) ? xe : void 0;
          }
          L += H;
        }
      }
      function wg(i, t, n, o, u, f, g, P, L) {
        const E = Cp(o, f, g), D = Ep(o, u), R = D * g, Z = i[0].x === 0 || i[0].x === L || i[0].y === 0 || i[0].y === L;
        return t - R < t / 4 && (t = R + t / 4), Mp(i, Z ? t / 2 * P % t : (D / 2 + 2 * f) * g * P % t, t, E, n, R, Z, !1, L);
      }
      function Mp(i, t, n, o, u, f, g, P, L) {
        const E = f / 2, D = kp(i);
        let R = 0, Z = t - n, H = [];
        for (let K = 0; K < i.length - 1; K++) {
          const re = i[K], pe = i[K + 1], xe = re.dist(pe), Ne = pe.angleTo(re);
          for (; Z + n < R + xe; ) {
            Z += n;
            const Te = (Z - R) / xe, ze = Rr.number(re.x, pe.x, Te), Ge = Rr.number(re.y, pe.y, Te);
            if (ze >= 0 && ze < L && Ge >= 0 && Ge < L && Z - E >= 0 && Z + E <= D) {
              const gt = new Ll(ze, Ge, Ne, K);
              gt._round(), o && !Tp(i, gt, f, o, u) || H.push(gt);
            }
          }
          R += xe;
        }
        return P || H.length || g || (H = Mp(i, R / 2, n, o, u, f, g, !0, L)), H;
      }
      Nt("Anchor", Ll);
      const Ic = fs;
      function zp(i, t, n, o) {
        const u = [], f = i.image, g = f.pixelRatio, P = f.paddedRect.w - 2 * Ic, L = f.paddedRect.h - 2 * Ic;
        let E = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const D = f.stretchX || [[0, P]], R = f.stretchY || [[0, L]], Z = (st, Wt) => st + Wt[1] - Wt[0], H = D.reduce(Z, 0), K = R.reduce(Z, 0), re = P - H, pe = L - K;
        let xe = 0, Ne = H, Te = 0, ze = K, Ge = 0, gt = re, Ct = 0, ri = pe;
        if (f.content && o) {
          const st = f.content, Wt = st[2] - st[0], qt = st[3] - st[1];
          (f.textFitWidth || f.textFitHeight) && (E = op(i)), xe = zh(D, 0, st[0]), Te = zh(R, 0, st[1]), Ne = zh(D, st[0], st[2]), ze = zh(R, st[1], st[3]), Ge = st[0] - xe, Ct = st[1] - Te, gt = Wt - Ne, ri = qt - ze;
        }
        const Lt = E.x1, At = E.y1, Ut = E.x2 - Lt, Bt = E.y2 - At, Ft = (st, Wt, qt, hi) => {
          const Yi = Dh(st.stretch - xe, Ne, Ut, Lt), Hi = Nh(st.fixed - Ge, gt, st.stretch, H), en = Dh(Wt.stretch - Te, ze, Bt, At), bo = Nh(Wt.fixed - Ct, ri, Wt.stretch, K), vn = Dh(qt.stretch - xe, Ne, Ut, Lt), tn = Nh(qt.fixed - Ge, gt, qt.stretch, H), Gn = Dh(hi.stretch - Te, ze, Bt, At), Wn = Nh(hi.fixed - Ct, ri, hi.stretch, K), Hn = new j(Yi, en), Tr = new j(vn, en), rn = new j(vn, Gn), Mn = new j(Yi, Gn), xn = new j(Hi / g, bo / g), Xn = new j(tn / g, Wn / g), bn = t * Math.PI / 180;
          if (bn) {
            const ji = Math.sin(bn), ir = Math.cos(bn), ar = [ir, -ji, ji, ir];
            Hn._matMult(ar), Tr._matMult(ar), Mn._matMult(ar), rn._matMult(ar);
          }
          const Js = st.stretch + st.fixed, ms = Wt.stretch + Wt.fixed;
          return { tl: Hn, tr: Tr, bl: Mn, br: rn, tex: { x: f.paddedRect.x + Ic + Js, y: f.paddedRect.y + Ic + ms, w: qt.stretch + qt.fixed - Js, h: hi.stretch + hi.fixed - ms }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: xn, pixelOffsetBR: Xn, minFontScaleX: gt / g / Ut, minFontScaleY: ri / g / Bt, isSDF: n };
        };
        if (o && (f.stretchX || f.stretchY)) {
          const st = Dp(D, re, H), Wt = Dp(R, pe, K);
          for (let qt = 0; qt < st.length - 1; qt++) {
            const hi = st[qt], Yi = st[qt + 1];
            for (let Hi = 0; Hi < Wt.length - 1; Hi++) u.push(Ft(hi, Wt[Hi], Yi, Wt[Hi + 1]));
          }
        } else u.push(Ft({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: P + 1 }, { fixed: 0, stretch: L + 1 }));
        return u;
      }
      function zh(i, t, n) {
        let o = 0;
        for (const u of i) o += Math.max(t, Math.min(n, u[1])) - Math.max(t, Math.min(n, u[0]));
        return o;
      }
      function Dp(i, t, n) {
        const o = [{ fixed: -Ic, stretch: 0 }];
        for (const [u, f] of i) {
          const g = o[o.length - 1];
          o.push({ fixed: u - g.stretch, stretch: g.stretch }), o.push({ fixed: u - g.stretch, stretch: g.stretch + (f - u) });
        }
        return o.push({ fixed: t + Ic, stretch: n }), o;
      }
      function Dh(i, t, n, o) {
        return i / t * n + o;
      }
      function Nh(i, t, n, o) {
        return i - t * n / o;
      }
      class Fh {
        constructor(t, n, o, u, f, g, P, L, E, D) {
          var R;
          if (this.boxStartIndex = t.length, E) {
            let Z = g.top, H = g.bottom;
            const K = g.collisionPadding;
            K && (Z -= K[1], H += K[3]);
            let re = H - Z;
            re > 0 && (re = Math.max(10, re), this.circleDiameter = re);
          } else {
            const Z = !((R = g.image) === null || R === void 0) && R.content && (g.image.textFitWidth || g.image.textFitHeight) ? op(g) : { x1: g.left, y1: g.top, x2: g.right, y2: g.bottom };
            Z.y1 = Z.y1 * P - L[0], Z.y2 = Z.y2 * P + L[2], Z.x1 = Z.x1 * P - L[3], Z.x2 = Z.x2 * P + L[1];
            const H = g.collisionPadding;
            if (H && (Z.x1 -= H[0] * P, Z.y1 -= H[1] * P, Z.x2 += H[2] * P, Z.y2 += H[3] * P), D) {
              const K = new j(Z.x1, Z.y1), re = new j(Z.x2, Z.y1), pe = new j(Z.x1, Z.y2), xe = new j(Z.x2, Z.y2), Ne = D * Math.PI / 180;
              K._rotate(Ne), re._rotate(Ne), pe._rotate(Ne), xe._rotate(Ne), Z.x1 = Math.min(K.x, re.x, pe.x, xe.x), Z.x2 = Math.max(K.x, re.x, pe.x, xe.x), Z.y1 = Math.min(K.y, re.y, pe.y, xe.y), Z.y2 = Math.max(K.y, re.y, pe.y, xe.y);
            }
            t.emplaceBack(n.x, n.y, Z.x1, Z.y1, Z.x2, Z.y2, o, u, f);
          }
          this.boxEndIndex = t.length;
        }
      }
      class Sg {
        constructor(t = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
          if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o);
        }
        push(t) {
          this.data.push(t), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const t = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
        }
        peek() {
          return this.data[0];
        }
        _up(t) {
          const { data: n, compare: o } = this, u = n[t];
          for (; t > 0; ) {
            const f = t - 1 >> 1, g = n[f];
            if (o(u, g) >= 0) break;
            n[t] = g, t = f;
          }
          n[t] = u;
        }
        _down(t) {
          const { data: n, compare: o } = this, u = this.length >> 1, f = n[t];
          for (; t < u; ) {
            let g = 1 + (t << 1);
            const P = g + 1;
            if (P < this.length && o(n[P], n[g]) < 0 && (g = P), o(n[g], f) >= 0) break;
            n[t] = n[g], t = g;
          }
          n[t] = f;
        }
      }
      function Ag(i, t = 1, n = !1) {
        let o = 1 / 0, u = 1 / 0, f = -1 / 0, g = -1 / 0;
        const P = i[0];
        for (let H = 0; H < P.length; H++) {
          const K = P[H];
          (!H || K.x < o) && (o = K.x), (!H || K.y < u) && (u = K.y), (!H || K.x > f) && (f = K.x), (!H || K.y > g) && (g = K.y);
        }
        const L = Math.min(f - o, g - u);
        let E = L / 2;
        const D = new Sg([], Pg);
        if (L === 0) return new j(o, u);
        for (let H = o; H < f; H += L) for (let K = u; K < g; K += L) D.push(new Lc(H + E, K + E, E, i));
        let R = function(H) {
          let K = 0, re = 0, pe = 0;
          const xe = H[0];
          for (let Ne = 0, Te = xe.length, ze = Te - 1; Ne < Te; ze = Ne++) {
            const Ge = xe[Ne], gt = xe[ze], Ct = Ge.x * gt.y - gt.x * Ge.y;
            re += (Ge.x + gt.x) * Ct, pe += (Ge.y + gt.y) * Ct, K += 3 * Ct;
          }
          return new Lc(re / K, pe / K, 0, H);
        }(i), Z = D.length;
        for (; D.length; ) {
          const H = D.pop();
          (H.d > R.d || !R.d) && (R = H, n && console.log("found best %d after %d probes", Math.round(1e4 * H.d) / 1e4, Z)), H.max - R.d <= t || (E = H.h / 2, D.push(new Lc(H.p.x - E, H.p.y - E, E, i)), D.push(new Lc(H.p.x + E, H.p.y - E, E, i)), D.push(new Lc(H.p.x - E, H.p.y + E, E, i)), D.push(new Lc(H.p.x + E, H.p.y + E, E, i)), Z += 4);
        }
        return n && (console.log(`num probes: ${Z}`), console.log(`best distance: ${R.d}`)), R.p;
      }
      function Pg(i, t) {
        return t.max - i.max;
      }
      function Lc(i, t, n, o) {
        this.p = new j(i, t), this.h = n, this.d = function(u, f) {
          let g = !1, P = 1 / 0;
          for (let L = 0; L < f.length; L++) {
            const E = f[L];
            for (let D = 0, R = E.length, Z = R - 1; D < R; Z = D++) {
              const H = E[D], K = E[Z];
              H.y > u.y != K.y > u.y && u.x < (K.x - H.x) * (u.y - H.y) / (K.y - H.y) + H.x && (g = !g), P = Math.min(P, Xc(u, H, K));
            }
          }
          return (g ? 1 : -1) * Math.sqrt(P);
        }(this.p, o), this.max = this.d + this.h * Math.SQRT2;
      }
      var _n;
      _.aq = void 0, (_n = _.aq || (_.aq = {}))[_n.center = 1] = "center", _n[_n.left = 2] = "left", _n[_n.right = 3] = "right", _n[_n.top = 4] = "top", _n[_n.bottom = 5] = "bottom", _n[_n["top-left"] = 6] = "top-left", _n[_n["top-right"] = 7] = "top-right", _n[_n["bottom-left"] = 8] = "bottom-left", _n[_n["bottom-right"] = 9] = "bottom-right";
      const Tl = 7, Du = Number.POSITIVE_INFINITY;
      function Np(i, t) {
        return t[1] !== Du ? function(n, o, u) {
          let f = 0, g = 0;
          switch (o = Math.abs(o), u = Math.abs(u), n) {
            case "top-right":
            case "top-left":
            case "top":
              g = u - Tl;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              g = -u + Tl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
            case "right":
              f = -o;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              f = o;
          }
          return [f, g];
        }(i, t[0], t[1]) : function(n, o) {
          let u = 0, f = 0;
          o < 0 && (o = 0);
          const g = o / Math.SQRT2;
          switch (n) {
            case "top-right":
            case "top-left":
              f = g - Tl;
              break;
            case "bottom-right":
            case "bottom-left":
              f = -g + Tl;
              break;
            case "bottom":
              f = -o + Tl;
              break;
            case "top":
              f = o - Tl;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
              u = -g;
              break;
            case "top-left":
            case "bottom-left":
              u = g;
              break;
            case "left":
              u = o;
              break;
            case "right":
              u = -o;
          }
          return [u, f];
        }(i, t[0]);
      }
      function Fp(i, t, n) {
        var o;
        const u = i.layout, f = (o = u.get("text-variable-anchor-offset")) === null || o === void 0 ? void 0 : o.evaluate(t, {}, n);
        if (f) {
          const P = f.values, L = [];
          for (let E = 0; E < P.length; E += 2) {
            const D = L[E] = P[E], R = P[E + 1].map((Z) => Z * jr);
            D.startsWith("top") ? R[1] -= Tl : D.startsWith("bottom") && (R[1] += Tl), L[E + 1] = R;
          }
          return new pn(L);
        }
        const g = u.get("text-variable-anchor");
        if (g) {
          let P;
          P = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(t, {}, n) * jr, Du] : u.get("text-offset").evaluate(t, {}, n).map((E) => E * jr);
          const L = [];
          for (const E of g) L.push(E, Np(E, P));
          return new pn(L);
        }
        return null;
      }
      function Nu(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Ig(i, t, n, o, u, f, g, P, L, E, D) {
        let R = f.textMaxSize.evaluate(t, {});
        R === void 0 && (R = g);
        const Z = i.layers[0].layout, H = Z.get("icon-offset").evaluate(t, {}, D), K = Bp(n.horizontal), re = g / 24, pe = i.tilePixelRatio * re, xe = i.tilePixelRatio * R / 24, Ne = i.tilePixelRatio * P, Te = i.tilePixelRatio * Z.get("symbol-spacing"), ze = Z.get("text-padding") * i.tilePixelRatio, Ge = function(st, Wt, qt, hi = 1) {
          const Yi = st.get("icon-padding").evaluate(Wt, {}, qt), Hi = Yi && Yi.values;
          return [Hi[0] * hi, Hi[1] * hi, Hi[2] * hi, Hi[3] * hi];
        }(Z, t, D, i.tilePixelRatio), gt = Z.get("text-max-angle") / 180 * Math.PI, Ct = Z.get("text-rotation-alignment") !== "viewport" && Z.get("symbol-placement") !== "point", ri = Z.get("icon-rotation-alignment") === "map" && Z.get("symbol-placement") !== "point", Lt = Z.get("symbol-placement"), At = Te / 2, Ut = Z.get("icon-text-fit");
        let Bt;
        o && Ut !== "none" && (i.allowVerticalPlacement && n.vertical && (Bt = ap(o, n.vertical, Ut, Z.get("icon-text-fit-padding"), H, re)), K && (o = ap(o, K, Ut, Z.get("icon-text-fit-padding"), H, re)));
        const Ft = (st, Wt) => {
          Wt.x < 0 || Wt.x >= tr || Wt.y < 0 || Wt.y >= tr || function(qt, hi, Yi, Hi, en, bo, vn, tn, Gn, Wn, Hn, Tr, rn, Mn, xn, Xn, bn, Js, ms, ji, ir, ar, Es, Sr, Tc) {
            const La = qt.addToLineVertexArray(hi, Yi);
            let Ta, wo, Ks, dn, al = 0, ph = 0, Vp = 0, Up = 0, Uu = -1, $u = -1;
            const ll = {};
            let $p = bl("");
            if (qt.allowVerticalPlacement && Hi.vertical) {
              const zn = tn.layout.get("text-rotate").evaluate(ir, {}, Sr) + 90;
              Ks = new Fh(Gn, hi, Wn, Hn, Tr, Hi.vertical, rn, Mn, xn, zn), vn && (dn = new Fh(Gn, hi, Wn, Hn, Tr, vn, bn, Js, xn, zn));
            }
            if (en) {
              const zn = tn.layout.get("icon-rotate").evaluate(ir, {}), Qs = tn.layout.get("icon-text-fit") !== "none", tc = zp(en, zn, Es, Qs), qo = vn ? zp(vn, zn, Es, Qs) : void 0;
              wo = new Fh(Gn, hi, Wn, Hn, Tr, en, bn, Js, !1, zn), al = 4 * tc.length;
              const ic = qt.iconSizeData;
              let ka = null;
              ic.kind === "source" ? (ka = [Ia * tn.layout.get("icon-size").evaluate(ir, {})], ka[0] > Pl && Le(`${qt.layerIds[0]}: Value for "icon-size" is >= ${lh}. Reduce your "icon-size".`)) : ic.kind === "composite" && (ka = [Ia * ar.compositeIconSizes[0].evaluate(ir, {}, Sr), Ia * ar.compositeIconSizes[1].evaluate(ir, {}, Sr)], (ka[0] > Pl || ka[1] > Pl) && Le(`${qt.layerIds[0]}: Value for "icon-size" is >= ${lh}. Reduce your "icon-size".`)), qt.addSymbols(qt.icon, tc, ka, ji, ms, ir, _.ah.none, hi, La.lineStartIndex, La.lineLength, -1, Sr), Uu = qt.icon.placedSymbolArray.length - 1, qo && (ph = 4 * qo.length, qt.addSymbols(qt.icon, qo, ka, ji, ms, ir, _.ah.vertical, hi, La.lineStartIndex, La.lineLength, -1, Sr), $u = qt.icon.placedSymbolArray.length - 1);
            }
            const Zp = Object.keys(Hi.horizontal);
            for (const zn of Zp) {
              const Qs = Hi.horizontal[zn];
              if (!Ta) {
                $p = bl(Qs.text);
                const qo = tn.layout.get("text-rotate").evaluate(ir, {}, Sr);
                Ta = new Fh(Gn, hi, Wn, Hn, Tr, Qs, rn, Mn, xn, qo);
              }
              const tc = Qs.positionedLines.length === 1;
              if (Vp += Rp(qt, hi, Qs, bo, tn, xn, ir, Xn, La, Hi.vertical ? _.ah.horizontal : _.ah.horizontalOnly, tc ? Zp : [zn], ll, Uu, ar, Sr), tc) break;
            }
            Hi.vertical && (Up += Rp(qt, hi, Hi.vertical, bo, tn, xn, ir, Xn, La, _.ah.vertical, ["vertical"], ll, $u, ar, Sr));
            const kg = Ta ? Ta.boxStartIndex : qt.collisionBoxArray.length, Cg = Ta ? Ta.boxEndIndex : qt.collisionBoxArray.length, Eg = Ks ? Ks.boxStartIndex : qt.collisionBoxArray.length, Mg = Ks ? Ks.boxEndIndex : qt.collisionBoxArray.length, zg = wo ? wo.boxStartIndex : qt.collisionBoxArray.length, Dg = wo ? wo.boxEndIndex : qt.collisionBoxArray.length, Ng = dn ? dn.boxStartIndex : qt.collisionBoxArray.length, Fg = dn ? dn.boxEndIndex : qt.collisionBoxArray.length;
            let jo = -1;
            const Bh = (zn, Qs) => zn && zn.circleDiameter ? Math.max(zn.circleDiameter, Qs) : Qs;
            jo = Bh(Ta, jo), jo = Bh(Ks, jo), jo = Bh(wo, jo), jo = Bh(dn, jo);
            const Gp = jo > -1 ? 1 : 0;
            Gp && (jo *= Tc / jr), qt.glyphOffsetArray.length >= Pc.MAX_GLYPHS && Le("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ir.sortKey !== void 0 && qt.addToSortKeyRanges(qt.symbolInstances.length, ir.sortKey);
            const Rg = Fp(tn, ir, Sr), [Bg, Og] = function(zn, Qs) {
              const tc = zn.length, qo = Qs == null ? void 0 : Qs.values;
              if ((qo == null ? void 0 : qo.length) > 0) for (let ic = 0; ic < qo.length; ic += 2) {
                const ka = qo[ic + 1];
                zn.emplaceBack(_.aq[qo[ic]], ka[0], ka[1]);
              }
              return [tc, zn.length];
            }(qt.textAnchorOffsets, Rg);
            qt.symbolInstances.emplaceBack(hi.x, hi.y, ll.right >= 0 ? ll.right : -1, ll.center >= 0 ? ll.center : -1, ll.left >= 0 ? ll.left : -1, ll.vertical || -1, Uu, $u, $p, kg, Cg, Eg, Mg, zg, Dg, Ng, Fg, Wn, Vp, Up, al, ph, Gp, 0, rn, jo, Bg, Og);
          }(i, Wt, st, n, o, u, Bt, i.layers[0], i.collisionBoxArray, t.index, t.sourceLayerIndex, i.index, pe, [ze, ze, ze, ze], Ct, L, Ne, Ge, ri, H, t, f, E, D, g);
        };
        if (Lt === "line") for (const st of Lp(t.geometry, 0, 0, tr, tr)) {
          const Wt = wg(st, Te, gt, n.vertical || K, o, 24, xe, i.overscaling, tr);
          for (const qt of Wt) K && Lg(i, K.text, At, qt) || Ft(st, qt);
        }
        else if (Lt === "line-center") {
          for (const st of t.geometry) if (st.length > 1) {
            const Wt = bg(st, gt, n.vertical || K, o, 24, xe);
            Wt && Ft(st, Wt);
          }
        } else if (t.type === "Polygon") for (const st of xs(t.geometry, 0)) {
          const Wt = Ag(st, 16);
          Ft(st[0], new Ll(Wt.x, Wt.y, 0));
        }
        else if (t.type === "LineString") for (const st of t.geometry) Ft(st, new Ll(st[0].x, st[0].y, 0));
        else if (t.type === "Point") for (const st of t.geometry) for (const Wt of st) Ft([Wt], new Ll(Wt.x, Wt.y, 0));
      }
      function Rp(i, t, n, o, u, f, g, P, L, E, D, R, Z, H, K) {
        const re = function(Ne, Te, ze, Ge, gt, Ct, ri, Lt) {
          const At = Ge.layout.get("text-rotate").evaluate(Ct, {}) * Math.PI / 180, Ut = [];
          for (const Bt of Te.positionedLines) for (const Ft of Bt.positionedGlyphs) {
            if (!Ft.rect) continue;
            const st = Ft.rect || {};
            let Wt = Qd + 1, qt = !0, hi = 1, Yi = 0;
            const Hi = (gt || Lt) && Ft.vertical, en = Ft.metrics.advance * Ft.scale / 2;
            if (Lt && Te.verticalizable && (Yi = Bt.lineOffset / 2 - (Ft.imageName ? -(jr - Ft.metrics.width * Ft.scale) / 2 : (Ft.scale - 1) * jr)), Ft.imageName) {
              const ji = ri[Ft.imageName];
              qt = ji.sdf, hi = ji.pixelRatio, Wt = fs / hi;
            }
            const bo = gt ? [Ft.x + en, Ft.y] : [0, 0];
            let vn = gt ? [0, 0] : [Ft.x + en + ze[0], Ft.y + ze[1] - Yi], tn = [0, 0];
            Hi && (tn = vn, vn = [0, 0]);
            const Gn = Ft.metrics.isDoubleResolution ? 2 : 1, Wn = (Ft.metrics.left - Wt) * Ft.scale - en + vn[0], Hn = (-Ft.metrics.top - Wt) * Ft.scale + vn[1], Tr = Wn + st.w / Gn * Ft.scale / hi, rn = Hn + st.h / Gn * Ft.scale / hi, Mn = new j(Wn, Hn), xn = new j(Tr, Hn), Xn = new j(Wn, rn), bn = new j(Tr, rn);
            if (Hi) {
              const ji = new j(-en, en - oh), ir = -Math.PI / 2, ar = jr / 2 - en, Es = new j(5 - oh - ar, -(Ft.imageName ? ar : 0)), Sr = new j(...tn);
              Mn._rotateAround(ir, ji)._add(Es)._add(Sr), xn._rotateAround(ir, ji)._add(Es)._add(Sr), Xn._rotateAround(ir, ji)._add(Es)._add(Sr), bn._rotateAround(ir, ji)._add(Es)._add(Sr);
            }
            if (At) {
              const ji = Math.sin(At), ir = Math.cos(At), ar = [ir, -ji, ji, ir];
              Mn._matMult(ar), xn._matMult(ar), Xn._matMult(ar), bn._matMult(ar);
            }
            const Js = new j(0, 0), ms = new j(0, 0);
            Ut.push({ tl: Mn, tr: xn, bl: Xn, br: bn, tex: st, writingMode: Te.writingMode, glyphOffset: bo, sectionIndex: Ft.sectionIndex, isSDF: qt, pixelOffsetTL: Js, pixelOffsetBR: ms, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Ut;
        }(0, n, P, u, f, g, o, i.allowVerticalPlacement), pe = i.textSizeData;
        let xe = null;
        pe.kind === "source" ? (xe = [Ia * u.layout.get("text-size").evaluate(g, {})], xe[0] > Pl && Le(`${i.layerIds[0]}: Value for "text-size" is >= ${lh}. Reduce your "text-size".`)) : pe.kind === "composite" && (xe = [Ia * H.compositeTextSizes[0].evaluate(g, {}, K), Ia * H.compositeTextSizes[1].evaluate(g, {}, K)], (xe[0] > Pl || xe[1] > Pl) && Le(`${i.layerIds[0]}: Value for "text-size" is >= ${lh}. Reduce your "text-size".`)), i.addSymbols(i.text, re, xe, P, f, g, E, t, L.lineStartIndex, L.lineLength, Z, K);
        for (const Ne of D) R[Ne] = i.text.placedSymbolArray.length - 1;
        return 4 * re.length;
      }
      function Bp(i) {
        for (const t in i) return i[t];
        return null;
      }
      function Lg(i, t, n, o) {
        const u = i.compareText;
        if (t in u) {
          const f = u[t];
          for (let g = f.length - 1; g >= 0; g--) if (o.dist(f[g]) < n) return !0;
        } else u[t] = [];
        return u[t].push(o), !1;
      }
      const Op = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Fu {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, o] = new Uint8Array(t, 0, 2);
          if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const u = o >> 4;
          if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
          const f = Op[15 & o];
          if (!f) throw new Error("Unrecognized array type.");
          const [g] = new Uint16Array(t, 2, 1), [P] = new Uint32Array(t, 4, 1);
          return new Fu(P, g, f, t);
        }
        constructor(t, n = 64, o = Float64Array, u) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
          const f = Op.indexOf(this.ArrayType), g = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, P = t * this.IndexArrayType.BYTES_PER_ELEMENT, L = (8 - P % 8) % 8;
          if (f < 0) throw new Error(`Unexpected typed array class: ${o}.`);
          u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + P + L, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + g + P + L), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + P + L, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + f]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
        }
        add(t, n) {
          const o = this._pos >> 1;
          return this.ids[o] = o, this.coords[this._pos++] = t, this.coords[this._pos++] = n, o;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return Ru(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(t, n, o, u) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: f, coords: g, nodeSize: P } = this, L = [0, f.length - 1, 0], E = [];
          for (; L.length; ) {
            const D = L.pop() || 0, R = L.pop() || 0, Z = L.pop() || 0;
            if (R - Z <= P) {
              for (let pe = Z; pe <= R; pe++) {
                const xe = g[2 * pe], Ne = g[2 * pe + 1];
                xe >= t && xe <= o && Ne >= n && Ne <= u && E.push(f[pe]);
              }
              continue;
            }
            const H = Z + R >> 1, K = g[2 * H], re = g[2 * H + 1];
            K >= t && K <= o && re >= n && re <= u && E.push(f[H]), (D === 0 ? t <= K : n <= re) && (L.push(Z), L.push(H - 1), L.push(1 - D)), (D === 0 ? o >= K : u >= re) && (L.push(H + 1), L.push(R), L.push(1 - D));
          }
          return E;
        }
        within(t, n, o) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: u, coords: f, nodeSize: g } = this, P = [0, u.length - 1, 0], L = [], E = o * o;
          for (; P.length; ) {
            const D = P.pop() || 0, R = P.pop() || 0, Z = P.pop() || 0;
            if (R - Z <= g) {
              for (let pe = Z; pe <= R; pe++) qp(f[2 * pe], f[2 * pe + 1], t, n) <= E && L.push(u[pe]);
              continue;
            }
            const H = Z + R >> 1, K = f[2 * H], re = f[2 * H + 1];
            qp(K, re, t, n) <= E && L.push(u[H]), (D === 0 ? t - o <= K : n - o <= re) && (P.push(Z), P.push(H - 1), P.push(1 - D)), (D === 0 ? t + o >= K : n + o >= re) && (P.push(H + 1), P.push(R), P.push(1 - D));
          }
          return L;
        }
      }
      function Ru(i, t, n, o, u, f) {
        if (u - o <= n) return;
        const g = o + u >> 1;
        jp(i, t, g, o, u, f), Ru(i, t, n, o, g - 1, 1 - f), Ru(i, t, n, g + 1, u, 1 - f);
      }
      function jp(i, t, n, o, u, f) {
        for (; u > o; ) {
          if (u - o > 600) {
            const E = u - o + 1, D = n - o + 1, R = Math.log(E), Z = 0.5 * Math.exp(2 * R / 3), H = 0.5 * Math.sqrt(R * Z * (E - Z) / E) * (D - E / 2 < 0 ? -1 : 1);
            jp(i, t, n, Math.max(o, Math.floor(n - D * Z / E + H)), Math.min(u, Math.floor(n + (E - D) * Z / E + H)), f);
          }
          const g = t[2 * n + f];
          let P = o, L = u;
          for (uh(i, t, o, n), t[2 * u + f] > g && uh(i, t, o, u); P < L; ) {
            for (uh(i, t, P, L), P++, L--; t[2 * P + f] < g; ) P++;
            for (; t[2 * L + f] > g; ) L--;
          }
          t[2 * o + f] === g ? uh(i, t, o, L) : (L++, uh(i, t, L, u)), L <= n && (o = L + 1), n <= L && (u = L - 1);
        }
      }
      function uh(i, t, n, o) {
        Bu(i, n, o), Bu(t, 2 * n, 2 * o), Bu(t, 2 * n + 1, 2 * o + 1);
      }
      function Bu(i, t, n) {
        const o = i[t];
        i[t] = i[n], i[n] = o;
      }
      function qp(i, t, n, o) {
        const u = i - n, f = t - o;
        return u * u + f * f;
      }
      var Ou;
      _.bg = void 0, (Ou = _.bg || (_.bg = {})).create = "create", Ou.load = "load", Ou.fullLoad = "fullLoad";
      let Rh = null, dh = [];
      const ju = 1e3 / 60, qu = "loadTime", Vu = "fullLoadTime", Tg = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const t = i;
        Rh != null && dh.push(t - Rh), Rh = t;
      }, clearMetrics() {
        Rh = null, dh = [], performance.clearMeasures(qu), performance.clearMeasures(Vu);
        for (const i in _.bg) performance.clearMarks(_.bg[i]);
      }, getPerformanceMetrics() {
        performance.measure(qu, _.bg.create, _.bg.load), performance.measure(Vu, _.bg.create, _.bg.fullLoad);
        const i = performance.getEntriesByName(qu)[0].duration, t = performance.getEntriesByName(Vu)[0].duration, n = dh.length, o = 1 / (dh.reduce((f, g) => f + g, 0) / n / 1e3), u = dh.filter((f) => f > ju).reduce((f, g) => f + (g - ju) / ju, 0);
        return { loadTime: i, fullLoadTime: t, fps: o, percentDroppedFrames: u / (n + u) * 100, totalFrames: n };
      } };
      _.$ = class extends z {
      }, _.A = vc, _.B = Vc, _.C = function(i) {
        if (We == null) {
          const t = i.navigator ? i.navigator.userAgent : null;
          We = !!i.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
        }
        return We;
      }, _.D = jt, _.E = Qe, _.F = class {
        constructor(i, t) {
          this.target = i, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new vg(() => this.process()), this.subscription = function(n, o, u, f) {
            return n.addEventListener(o, u, !1), { unsubscribe: () => {
              n.removeEventListener(o, u, !1);
            } };
          }(this.target, "message", (n) => this.receive(n)), this.globalScope = He(self) ? i : window;
        }
        registerMessageHandler(i, t) {
          this.messageHandlers[i] = t;
        }
        sendAsync(i, t) {
          return new Promise((n, o) => {
            const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[u] = { resolve: n, reject: o }, t && t.signal.addEventListener("abort", () => {
              delete this.resolveRejects[u];
              const P = { id: u, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(P);
            }, { once: !0 });
            const f = [], g = Object.assign(Object.assign({}, i), { id: u, sourceMapId: this.mapId, origin: location.origin, data: ya(i.data, f) });
            this.target.postMessage(g, { transfer: f });
          });
        }
        receive(i) {
          const t = i.data, n = t.id;
          if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
            if (t.type === "<cancel>") {
              delete this.tasks[n];
              const o = this.abortControllers[n];
              return delete this.abortControllers[n], void (o && o.abort());
            }
            if (He(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
            this.processTask(n, t);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), t = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(i, t);
        }
        processTask(i, t) {
          return c(this, void 0, void 0, function* () {
            if (t.type === "<response>") {
              const u = this.resolveRejects[i];
              return delete this.resolveRejects[i], u ? void (t.error ? u.reject(Fo(t.error)) : u.resolve(Fo(t.data))) : void 0;
            }
            if (!this.messageHandlers[t.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const n = Fo(t.data), o = new AbortController();
            this.abortControllers[i] = o;
            try {
              const u = yield this.messageHandlers[t.type](t.sourceMapId, n, o);
              this.completeTask(i, null, u);
            } catch (u) {
              this.completeTask(i, u);
            }
          });
        }
        completeTask(i, t, n) {
          const o = [];
          delete this.abortControllers[i];
          const u = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? ya(t) : null, data: ya(n, o) };
          this.target.postMessage(u, { transfer: o });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, _.G = De, _.H = function() {
        var i = new vc(16);
        return vc != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, _.I = Su, _.J = function(i, t, n) {
        var o, u, f, g, P, L, E, D, R, Z, H, K, re = n[0], pe = n[1], xe = n[2];
        return t === i ? (i[12] = t[0] * re + t[4] * pe + t[8] * xe + t[12], i[13] = t[1] * re + t[5] * pe + t[9] * xe + t[13], i[14] = t[2] * re + t[6] * pe + t[10] * xe + t[14], i[15] = t[3] * re + t[7] * pe + t[11] * xe + t[15]) : (u = t[1], f = t[2], g = t[3], P = t[4], L = t[5], E = t[6], D = t[7], R = t[8], Z = t[9], H = t[10], K = t[11], i[0] = o = t[0], i[1] = u, i[2] = f, i[3] = g, i[4] = P, i[5] = L, i[6] = E, i[7] = D, i[8] = R, i[9] = Z, i[10] = H, i[11] = K, i[12] = o * re + P * pe + R * xe + t[12], i[13] = u * re + L * pe + Z * xe + t[13], i[14] = f * re + E * pe + H * xe + t[14], i[15] = g * re + D * pe + K * xe + t[15]), i;
      }, _.K = function(i, t, n) {
        var o = n[0], u = n[1], f = n[2];
        return i[0] = t[0] * o, i[1] = t[1] * o, i[2] = t[2] * o, i[3] = t[3] * o, i[4] = t[4] * u, i[5] = t[5] * u, i[6] = t[6] * u, i[7] = t[7] * u, i[8] = t[8] * f, i[9] = t[9] * f, i[10] = t[10] * f, i[11] = t[11] * f, i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, _.L = bd, _.M = function(i, t) {
        const n = {};
        for (let o = 0; o < t.length; o++) {
          const u = t[o];
          u in i && (n[u] = i[u]);
        }
        return n;
      }, _.N = Il, _.O = gp, _.P = j, _.Q = yp, _.R = Xs, _.S = Ys, _.T = xl, _.U = se, _.V = ge, _.W = rt, _.X = tr, _.Y = y, _.Z = ch, _._ = c, _.a = _e, _.a$ = function(i, t) {
        var n = i[0], o = i[1], u = i[2], f = i[3], g = i[4], P = i[5], L = i[6], E = i[7], D = i[8], R = i[9], Z = i[10], H = i[11], K = i[12], re = i[13], pe = i[14], xe = i[15], Ne = t[0], Te = t[1], ze = t[2], Ge = t[3], gt = t[4], Ct = t[5], ri = t[6], Lt = t[7], At = t[8], Ut = t[9], Bt = t[10], Ft = t[11], st = t[12], Wt = t[13], qt = t[14], hi = t[15];
        return Math.abs(n - Ne) <= Zn * Math.max(1, Math.abs(n), Math.abs(Ne)) && Math.abs(o - Te) <= Zn * Math.max(1, Math.abs(o), Math.abs(Te)) && Math.abs(u - ze) <= Zn * Math.max(1, Math.abs(u), Math.abs(ze)) && Math.abs(f - Ge) <= Zn * Math.max(1, Math.abs(f), Math.abs(Ge)) && Math.abs(g - gt) <= Zn * Math.max(1, Math.abs(g), Math.abs(gt)) && Math.abs(P - Ct) <= Zn * Math.max(1, Math.abs(P), Math.abs(Ct)) && Math.abs(L - ri) <= Zn * Math.max(1, Math.abs(L), Math.abs(ri)) && Math.abs(E - Lt) <= Zn * Math.max(1, Math.abs(E), Math.abs(Lt)) && Math.abs(D - At) <= Zn * Math.max(1, Math.abs(D), Math.abs(At)) && Math.abs(R - Ut) <= Zn * Math.max(1, Math.abs(R), Math.abs(Ut)) && Math.abs(Z - Bt) <= Zn * Math.max(1, Math.abs(Z), Math.abs(Bt)) && Math.abs(H - Ft) <= Zn * Math.max(1, Math.abs(H), Math.abs(Ft)) && Math.abs(K - st) <= Zn * Math.max(1, Math.abs(K), Math.abs(st)) && Math.abs(re - Wt) <= Zn * Math.max(1, Math.abs(re), Math.abs(Wt)) && Math.abs(pe - qt) <= Zn * Math.max(1, Math.abs(pe), Math.abs(qt)) && Math.abs(xe - hi) <= Zn * Math.max(1, Math.abs(xe), Math.abs(hi));
      }, _.a0 = Ti, _.a1 = zu, _.a2 = lt, _.a3 = (i) => {
        const t = window.document.createElement("video");
        return t.muted = !0, new Promise((n) => {
          t.onloadstart = () => {
            n(t);
          };
          for (const o of i) {
            const u = window.document.createElement("source");
            wt(o) || (t.crossOrigin = "Anonymous"), u.src = o, t.appendChild(u);
          }
        });
      }, _.a4 = function() {
        return Ie++;
      }, _.a5 = vt, _.a6 = Pc, _.a7 = hs, _.a8 = Sa, _.a9 = Sp, _.aA = function(i) {
        if (i.type === "custom") return new _g(i);
        switch (i.type) {
          case "background":
            return new mg(i);
          case "circle":
            return new im(i);
          case "fill":
            return new vm(i);
          case "fill-extrusion":
            return new Dm(i);
          case "heatmap":
            return new nm(i);
          case "hillshade":
            return new om(i);
          case "line":
            return new Vm(i);
          case "raster":
            return new yg(i);
          case "symbol":
            return new Mh(i);
        }
      }, _.aB = oe, _.aC = function(i, t) {
        if (!i) return [{ command: "setStyle", args: [t] }];
        let n = [];
        try {
          if (!at(i.version, t.version)) return [{ command: "setStyle", args: [t] }];
          at(i.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), at(i.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), at(i.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), at(i.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), at(i.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), at(i.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), at(i.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), at(i.light, t.light) || n.push({ command: "setLight", args: [t.light] }), at(i.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), at(i.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), at(i.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
          const o = {}, u = [];
          (function(g, P, L, E) {
            let D;
            for (D in P = P || {}, g = g || {}) Object.prototype.hasOwnProperty.call(g, D) && (Object.prototype.hasOwnProperty.call(P, D) || Pt(D, L, E));
            for (D in P) Object.prototype.hasOwnProperty.call(P, D) && (Object.prototype.hasOwnProperty.call(g, D) ? at(g[D], P[D]) || (g[D].type === "geojson" && P[D].type === "geojson" && di(g, P, D) ? yt(L, { command: "setGeoJSONSourceData", args: [D, P[D].data] }) : Gt(D, P, L, E)) : zt(D, P, L));
          })(i.sources, t.sources, u, o);
          const f = [];
          i.layers && i.layers.forEach((g) => {
            "source" in g && o[g.source] ? n.push({ command: "removeLayer", args: [g.id] }) : f.push(g);
          }), n = n.concat(u), function(g, P, L) {
            P = P || [];
            const E = (g = g || []).map(bi), D = P.map(bi), R = g.reduce(Ci, {}), Z = P.reduce(Ci, {}), H = E.slice(), K = /* @__PURE__ */ Object.create(null);
            let re, pe, xe, Ne, Te;
            for (let ze = 0, Ge = 0; ze < E.length; ze++) re = E[ze], Object.prototype.hasOwnProperty.call(Z, re) ? Ge++ : (yt(L, { command: "removeLayer", args: [re] }), H.splice(H.indexOf(re, Ge), 1));
            for (let ze = 0, Ge = 0; ze < D.length; ze++) re = D[D.length - 1 - ze], H[H.length - 1 - ze] !== re && (Object.prototype.hasOwnProperty.call(R, re) ? (yt(L, { command: "removeLayer", args: [re] }), H.splice(H.lastIndexOf(re, H.length - Ge), 1)) : Ge++, Ne = H[H.length - ze], yt(L, { command: "addLayer", args: [Z[re], Ne] }), H.splice(H.length - ze, 0, re), K[re] = !0);
            for (let ze = 0; ze < D.length; ze++) if (re = D[ze], pe = R[re], xe = Z[re], !K[re] && !at(pe, xe)) if (at(pe.source, xe.source) && at(pe["source-layer"], xe["source-layer"]) && at(pe.type, xe.type)) {
              for (Te in oi(pe.layout, xe.layout, L, re, null, "setLayoutProperty"), oi(pe.paint, xe.paint, L, re, null, "setPaintProperty"), at(pe.filter, xe.filter) || yt(L, { command: "setFilter", args: [re, xe.filter] }), at(pe.minzoom, xe.minzoom) && at(pe.maxzoom, xe.maxzoom) || yt(L, { command: "setLayerZoomRange", args: [re, xe.minzoom, xe.maxzoom] }), pe) Object.prototype.hasOwnProperty.call(pe, Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? oi(pe[Te], xe[Te], L, re, Te.slice(6), "setPaintProperty") : at(pe[Te], xe[Te]) || yt(L, { command: "setLayerProperty", args: [re, Te, xe[Te]] }));
              for (Te in xe) Object.prototype.hasOwnProperty.call(xe, Te) && !Object.prototype.hasOwnProperty.call(pe, Te) && Te !== "layout" && Te !== "paint" && Te !== "filter" && Te !== "metadata" && Te !== "minzoom" && Te !== "maxzoom" && (Te.indexOf("paint.") === 0 ? oi(pe[Te], xe[Te], L, re, Te.slice(6), "setPaintProperty") : at(pe[Te], xe[Te]) || yt(L, { command: "setLayerProperty", args: [re, Te, xe[Te]] }));
            } else yt(L, { command: "removeLayer", args: [re] }), Ne = H[H.lastIndexOf(re) + 1], yt(L, { command: "addLayer", args: [xe, Ne] });
          }(f, t.layers, n);
        } catch (o) {
          console.warn("Unable to compute style diff:", o), n = [{ command: "setStyle", args: [t] }];
        }
        return n;
      }, _.aD = function(i) {
        const t = [], n = i.id;
        return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), i.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
      }, _.aE = function i(t, n) {
        if (Array.isArray(t)) {
          if (!Array.isArray(n) || t.length !== n.length) return !1;
          for (let o = 0; o < t.length; o++) if (!i(t[o], n[o])) return !1;
          return !0;
        }
        if (typeof t == "object" && t !== null && n !== null) {
          if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
          for (const o in t) if (!i(t[o], n[o])) return !1;
          return !0;
        }
        return t === n;
      }, _.aF = ot, _.aG = it, _.aH = class extends ba {
        constructor(i, t) {
          super(i, t), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, _.aI = Xl, _.aJ = class extends ba {
        constructor(i, t) {
          super(i, t), this.current = Jl;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let t = 1; t < 16; t++) if (i[t] !== this.current[t]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, _.aK = Yl, _.aL = pc, _.aM = Ri, _.aN = class extends ba {
        constructor(i, t) {
          super(i, t), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, _.aO = class extends ba {
        constructor(i, t) {
          super(i, t), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, _.aP = function(i, t, n, o, u, f, g) {
        var P = 1 / (t - n), L = 1 / (o - u), E = 1 / (f - g);
        return i[0] = -2 * P, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * L, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * E, i[11] = 0, i[12] = (t + n) * P, i[13] = (u + o) * L, i[14] = (g + f) * E, i[15] = 1, i;
      }, _.aQ = tm, _.aR = class extends he {
      }, _.aS = Gm, _.aT = class extends ve {
      }, _.aU = uu, _.aV = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, _.aW = Id, _.aX = or, _.aY = Kr, _.aZ = class extends ft {
      }, _.a_ = function(i, t) {
        return i[0] === t[0] && i[1] === t[1] && i[2] === t[2] && i[3] === t[3] && i[4] === t[4] && i[5] === t[5] && i[6] === t[6] && i[7] === t[7] && i[8] === t[8] && i[9] === t[9] && i[10] === t[10] && i[11] === t[11] && i[12] === t[12] && i[13] === t[13] && i[14] === t[14] && i[15] === t[15];
      }, _.aa = function(i) {
        const t = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, o, u, f) => {
          const g = u || f;
          return t[o] = !g || g.toLowerCase(), "";
        }), t["max-age"]) {
          const n = parseInt(t["max-age"], 10);
          isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
        }
        return t;
      }, _.ab = function(i, t) {
        const n = [];
        for (const o in i) o in t || n.push(o);
        return n;
      }, _.ac = $e, _.ad = function(i, t, n) {
        var o = Math.sin(n), u = Math.cos(n), f = t[0], g = t[1], P = t[2], L = t[3], E = t[4], D = t[5], R = t[6], Z = t[7];
        return t !== i && (i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[0] = f * u + E * o, i[1] = g * u + D * o, i[2] = P * u + R * o, i[3] = L * u + Z * o, i[4] = E * u - f * o, i[5] = D * u - g * o, i[6] = R * u - P * o, i[7] = Z * u - L * o, i;
      }, _.ae = function(i) {
        var t = new vc(16);
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], t;
      }, _.af = Sh, _.ag = function(i, t) {
        let n = 0, o = 0;
        if (i.kind === "constant") o = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: u, minZoom: f, maxZoom: g } = i, P = u ? $e(Xt.interpolationFactor(u, t, f, g), 0, 1) : 0;
          i.kind === "camera" ? o = Rr.number(i.minSize, i.maxSize, P) : n = P;
        }
        return { uSizeT: n, uSize: o };
      }, _.ai = function(i, { uSize: t, uSizeT: n }, { lowerSize: o, upperSize: u }) {
        return i.kind === "source" ? o / Ia : i.kind === "composite" ? Rr.number(o / Ia, u / Ia, n) : t;
      }, _.aj = Lu, _.ak = function(i, t, n, o) {
        const u = t.y - i.y, f = t.x - i.x, g = o.y - n.y, P = o.x - n.x, L = g * f - P * u;
        if (L === 0) return null;
        const E = (P * (i.y - n.y) - g * (i.x - n.x)) / L;
        return new j(i.x + E * f, i.y + E * u);
      }, _.al = Lp, _.am = gc, _.an = lu, _.ao = function(i) {
        let t = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const f of i) t = Math.min(t, f.x), n = Math.min(n, f.y), o = Math.max(o, f.x), u = Math.max(u, f.y);
        return [t, n, o, u];
      }, _.ap = jr, _.ar = Iu, _.as = function(i, t) {
        var n = t[0], o = t[1], u = t[2], f = t[3], g = t[4], P = t[5], L = t[6], E = t[7], D = t[8], R = t[9], Z = t[10], H = t[11], K = t[12], re = t[13], pe = t[14], xe = t[15], Ne = n * P - o * g, Te = n * L - u * g, ze = n * E - f * g, Ge = o * L - u * P, gt = o * E - f * P, Ct = u * E - f * L, ri = D * re - R * K, Lt = D * pe - Z * K, At = D * xe - H * K, Ut = R * pe - Z * re, Bt = R * xe - H * re, Ft = Z * xe - H * pe, st = Ne * Ft - Te * Bt + ze * Ut + Ge * At - gt * Lt + Ct * ri;
        return st ? (i[0] = (P * Ft - L * Bt + E * Ut) * (st = 1 / st), i[1] = (u * Bt - o * Ft - f * Ut) * st, i[2] = (re * Ct - pe * gt + xe * Ge) * st, i[3] = (Z * gt - R * Ct - H * Ge) * st, i[4] = (L * At - g * Ft - E * Lt) * st, i[5] = (n * Ft - u * At + f * Lt) * st, i[6] = (pe * ze - K * Ct - xe * Te) * st, i[7] = (D * Ct - Z * ze + H * Te) * st, i[8] = (g * Bt - P * At + E * ri) * st, i[9] = (o * At - n * Bt - f * ri) * st, i[10] = (K * gt - re * ze + xe * Ne) * st, i[11] = (R * ze - D * gt - H * Ne) * st, i[12] = (P * Lt - g * Ut - L * ri) * st, i[13] = (n * Ut - o * Lt + u * ri) * st, i[14] = (re * Te - K * Ge - pe * Ne) * st, i[15] = (D * Ge - R * Te + Z * Ne) * st, i) : null;
      }, _.at = Nu, _.au = Pu, _.av = Fu, _.aw = function() {
        const i = {}, t = Y.$version;
        for (const n in Y.$root) {
          const o = Y.$root[n];
          if (o.required) {
            let u = null;
            u = n === "version" ? t : o.type === "array" ? [] : {}, u != null && (i[n] = u);
          }
        }
        return i;
      }, _.ax = Ts, _.ay = qe, _.az = function(i) {
        i = i.slice();
        const t = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < i.length; n++) t[i[n].id] = i[n];
        for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = $t(i[n], t[i[n].ref]));
        return i;
      }, _.b = Je, _.b0 = function(i, t) {
        return i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[4] = t[4], i[5] = t[5], i[6] = t[6], i[7] = t[7], i[8] = t[8], i[9] = t[9], i[10] = t[10], i[11] = t[11], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15], i;
      }, _.b1 = function(i, t, n) {
        return i[0] = t[0] * n[0], i[1] = t[1] * n[1], i[2] = t[2] * n[2], i[3] = t[3] * n[3], i;
      }, _.b2 = function(i, t) {
        return i[0] * t[0] + i[1] * t[1] + i[2] * t[2] + i[3] * t[3];
      }, _.b3 = tt, _.b4 = xp, _.b5 = _p, _.b6 = function(i, t, n, o, u) {
        var f, g = 1 / Math.tan(t / 2);
        return i[0] = g / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = g, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, u != null && u !== 1 / 0 ? (i[10] = (u + o) * (f = 1 / (o - u)), i[14] = 2 * u * o * f) : (i[10] = -1, i[14] = -2 * o), i;
      }, _.b7 = function(i, t, n) {
        var o = Math.sin(n), u = Math.cos(n), f = t[4], g = t[5], P = t[6], L = t[7], E = t[8], D = t[9], R = t[10], Z = t[11];
        return t !== i && (i[0] = t[0], i[1] = t[1], i[2] = t[2], i[3] = t[3], i[12] = t[12], i[13] = t[13], i[14] = t[14], i[15] = t[15]), i[4] = f * u + E * o, i[5] = g * u + D * o, i[6] = P * u + R * o, i[7] = L * u + Z * o, i[8] = E * u - f * o, i[9] = D * u - g * o, i[10] = R * u - P * o, i[11] = Z * u - L * o, i;
      }, _.b8 = Me, _.b9 = Ye, _.bA = Gd, _.bB = function(i) {
        return i.message === J;
      }, _.bC = Yr, _.bD = Tn, _.ba = function(i) {
        return i * Math.PI / 180;
      }, _.bb = function(i, t) {
        const { x: n, y: o } = ch.fromLngLat(t);
        return !(i < 0 || i > 25 || o < 0 || o >= 1 || n < 0 || n >= 1);
      }, _.bc = function(i, t) {
        return i[0] = t[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = t[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, _.bd = class extends k {
      }, _.be = Eu, _.bf = Tg, _.bh = Oe, _.bi = function(i, t) {
        _e.REGISTERED_PROTOCOLS[i] = t;
      }, _.bj = function(i) {
        delete _e.REGISTERED_PROTOCOLS[i];
      }, _.bk = function(i, t) {
        const n = {};
        for (let u = 0; u < i.length; u++) {
          const f = t && t[i[u].id] || Bl(i[u]);
          t && (t[i[u].id] = f);
          let g = n[f];
          g || (g = n[f] = []), g.push(i[u]);
        }
        const o = [];
        for (const u in n) o.push(n[u]);
        return o;
      }, _.bl = Nt, _.bm = wp, _.bn = Ap, _.bo = tp, _.bp = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = tr / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const t = i.bucket.layers[0], n = t.layout, o = t._unevaluatedLayout._values, u = { layoutIconSize: o["icon-size"].possiblyEvaluate(new Gi(i.bucket.zoom + 1), i.canonical), layoutTextSize: o["text-size"].possiblyEvaluate(new Gi(i.bucket.zoom + 1), i.canonical), textMaxSize: o["text-size"].possiblyEvaluate(new Gi(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: E, maxZoom: D } = i.bucket.textSizeData;
          u.compositeTextSizes = [o["text-size"].possiblyEvaluate(new Gi(E), i.canonical), o["text-size"].possiblyEvaluate(new Gi(D), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: E, maxZoom: D } = i.bucket.iconSizeData;
          u.compositeIconSizes = [o["icon-size"].possiblyEvaluate(new Gi(E), i.canonical), o["icon-size"].possiblyEvaluate(new Gi(D), i.canonical)];
        }
        const f = n.get("text-line-height") * jr, g = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", P = n.get("text-keep-upright"), L = n.get("text-size");
        for (const E of i.bucket.features) {
          const D = n.get("text-font").evaluate(E, {}, i.canonical).join(","), R = L.evaluate(E, {}, i.canonical), Z = u.layoutTextSize.evaluate(E, {}, i.canonical), H = u.layoutIconSize.evaluate(E, {}, i.canonical), K = { horizontal: {}, vertical: void 0 }, re = E.text;
          let pe, xe = [0, 0];
          if (re) {
            const ze = re.toString(), Ge = n.get("text-letter-spacing").evaluate(E, {}, i.canonical) * jr, gt = Uc(ze) ? Ge : 0, Ct = n.get("text-anchor").evaluate(E, {}, i.canonical), ri = Fp(t, E, i.canonical);
            if (!ri) {
              const Bt = n.get("text-radial-offset").evaluate(E, {}, i.canonical);
              xe = Bt ? Np(Ct, [Bt * jr, Du]) : n.get("text-offset").evaluate(E, {}, i.canonical).map((Ft) => Ft * jr);
            }
            let Lt = g ? "center" : n.get("text-justify").evaluate(E, {}, i.canonical);
            const At = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(E, {}, i.canonical) * jr : 1 / 0, Ut = () => {
              i.bucket.allowVerticalPlacement && Zl(ze) && (K.vertical = kh(re, i.glyphMap, i.glyphPositions, i.imagePositions, D, At, f, Ct, "left", gt, xe, _.ah.vertical, !0, Z, R));
            };
            if (!g && ri) {
              const Bt = /* @__PURE__ */ new Set();
              if (Lt === "auto") for (let st = 0; st < ri.values.length; st += 2) Bt.add(Nu(ri.values[st]));
              else Bt.add(Lt);
              let Ft = !1;
              for (const st of Bt) if (!K.horizontal[st]) if (Ft) K.horizontal[st] = K.horizontal[0];
              else {
                const Wt = kh(re, i.glyphMap, i.glyphPositions, i.imagePositions, D, At, f, "center", st, gt, xe, _.ah.horizontal, !1, Z, R);
                Wt && (K.horizontal[st] = Wt, Ft = Wt.positionedLines.length === 1);
              }
              Ut();
            } else {
              Lt === "auto" && (Lt = Nu(Ct));
              const Bt = kh(re, i.glyphMap, i.glyphPositions, i.imagePositions, D, At, f, Ct, Lt, gt, xe, _.ah.horizontal, !1, Z, R);
              Bt && (K.horizontal[Lt] = Bt), Ut(), Zl(ze) && g && P && (K.vertical = kh(re, i.glyphMap, i.glyphPositions, i.imagePositions, D, At, f, Ct, Lt, gt, xe, _.ah.vertical, !1, Z, R));
            }
          }
          let Ne = !1;
          if (E.icon && E.icon.name) {
            const ze = i.imageMap[E.icon.name];
            ze && (pe = hg(i.imagePositions[E.icon.name], n.get("icon-offset").evaluate(E, {}, i.canonical), n.get("icon-anchor").evaluate(E, {}, i.canonical)), Ne = !!ze.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Ne : i.bucket.sdfIcons !== Ne && Le("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (ze.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const Te = Bp(K.horizontal) || K.vertical;
          i.bucket.iconsInText = !!Te && Te.iconsInText, (Te || pe) && Ig(i.bucket, E, K, pe, i.imageMap, u, Z, H, xe, Ne, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, _.bq = vu, _.br = gu, _.bs = _u, _.bt = Sl, _.bu = bu, _.bv = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, _.bw = function(i, t, n, o, u) {
        return c(this, void 0, void 0, function* () {
          if (ge()) try {
            return yield rt(i, t, n, o, u);
          } catch {
          }
          return function(f, g, P, L, E) {
            const D = f.width, R = f.height;
            Ke && St || (Ke = new OffscreenCanvas(D, R), St = Ke.getContext("2d", { willReadFrequently: !0 })), Ke.width = D, Ke.height = R, St.drawImage(f, 0, 0, D, R);
            const Z = St.getImageData(g, P, L, E);
            return St.clearRect(0, 0, D, R), Z.data;
          }(i, t, n, o, u);
        });
      }, _.bx = bp, _.by = C, _.bz = N, _.c = fe, _.d = (i) => c(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const t = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(t);
        } catch (n) {
          throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), _.e = Be, _.f = (i) => new Promise((t, n) => {
        const o = new Image();
        o.onload = () => {
          t(o), URL.revokeObjectURL(o.src), o.onload = null, window.requestAnimationFrame(() => {
            o.src = je;
          });
        }, o.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const u = new Blob([new Uint8Array(i)], { type: "image/png" });
        o.src = i.byteLength ? URL.createObjectURL(u) : je;
      }), _.g = Ce, _.h = (i, t) => Ze(Be(i, { type: "json" }), t), _.i = He, _.j = Qt, _.k = Mt, _.l = (i, t) => Ze(Be(i, { type: "arrayBuffer" }), t), _.m = Ze, _.n = function(i) {
        return new bu(i).readFields(rg, []);
      }, _.o = Qc, _.p = ep, _.q = a, _.r = Ya, _.s = wt, _.t = $l, _.u = Zs, _.v = Y, _.w = Le, _.x = function([i, t, n]) {
        return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: i * Math.cos(t) * Math.sin(n), y: i * Math.sin(t) * Math.sin(n), z: i * Math.cos(n) };
      }, _.y = Rr, _.z = Gi;
    }), S("worker", ["./shared"], function(_) {
      class c {
        constructor($) {
          this.keyCache = {}, $ && this.replace($);
        }
        replace($) {
          this._layerConfigs = {}, this._layers = {}, this.update($, []);
        }
        update($, W) {
          for (const ce of $) {
            this._layerConfigs[ce.id] = ce;
            const Pe = this._layers[ce.id] = _.aA(ce);
            Pe._featureFilter = _.a7(Pe.filter), this.keyCache[ce.id] && delete this.keyCache[ce.id];
          }
          for (const ce of W) delete this.keyCache[ce], delete this._layerConfigs[ce], delete this._layers[ce];
          this.familiesBySource = {};
          const te = _.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ce of te) {
            const Pe = ce.map((Re) => this._layers[Re.id]), Ee = Pe[0];
            if (Ee.visibility === "none") continue;
            const Ae = Ee.source || "";
            let be = this.familiesBySource[Ae];
            be || (be = this.familiesBySource[Ae] = {});
            const Ve = Ee.sourceLayer || "_geojsonTileLayer";
            let et = be[Ve];
            et || (et = be[Ve] = []), et.push(Pe);
          }
        }
      }
      class C {
        constructor($) {
          const W = {}, te = [];
          for (const Ae in $) {
            const be = $[Ae], Ve = W[Ae] = {};
            for (const et in be) {
              const Re = be[+et];
              if (!Re || Re.bitmap.width === 0 || Re.bitmap.height === 0) continue;
              const mt = { x: 0, y: 0, w: Re.bitmap.width + 2, h: Re.bitmap.height + 2 };
              te.push(mt), Ve[et] = { rect: mt, metrics: Re.metrics };
            }
          }
          const { w: ce, h: Pe } = _.p(te), Ee = new _.o({ width: ce || 1, height: Pe || 1 });
          for (const Ae in $) {
            const be = $[Ae];
            for (const Ve in be) {
              const et = be[+Ve];
              if (!et || et.bitmap.width === 0 || et.bitmap.height === 0) continue;
              const Re = W[Ae][Ve].rect;
              _.o.copy(et.bitmap, Ee, { x: 0, y: 0 }, { x: Re.x + 1, y: Re.y + 1 }, et.bitmap);
            }
          }
          this.image = Ee, this.positions = W;
        }
      }
      _.bl("GlyphAtlas", C);
      class N {
        constructor($) {
          this.tileID = new _.S($.tileID.overscaledZ, $.tileID.wrap, $.tileID.canonical.z, $.tileID.canonical.x, $.tileID.canonical.y), this.uid = $.uid, this.zoom = $.zoom, this.pixelRatio = $.pixelRatio, this.tileSize = $.tileSize, this.source = $.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = $.showCollisionBoxes, this.collectResourceTiming = !!$.collectResourceTiming, this.returnDependencies = !!$.returnDependencies, this.promoteId = $.promoteId, this.inFlightDependencies = [];
        }
        parse($, W, te, ce) {
          return _._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = $, this.collisionBoxArray = new _.a5();
            const Pe = new _.bm(Object.keys($.layers).sort()), Ee = new _.bn(this.tileID, this.promoteId);
            Ee.bucketLayerIDs = [];
            const Ae = {}, be = { featureIndex: Ee, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: te }, Ve = W.familiesBySource[this.source];
            for (const li in Ve) {
              const Di = $.layers[li];
              if (!Di) continue;
              Di.version === 1 && _.w(`Vector tile source "${this.source}" layer "${li}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Vi = Pe.encode(li), hr = [];
              for (let fr = 0; fr < Di.length; fr++) {
                const Ir = Di.feature(fr), Ns = Ee.getId(Ir, li);
                hr.push({ feature: Ir, id: Ns, index: fr, sourceLayerIndex: Vi });
              }
              for (const fr of Ve[li]) {
                const Ir = fr[0];
                Ir.source !== this.source && _.w(`layer.source = ${Ir.source} does not equal this.source = ${this.source}`), Ir.minzoom && this.zoom < Math.floor(Ir.minzoom) || Ir.maxzoom && this.zoom >= Ir.maxzoom || Ir.visibility !== "none" && (q(fr, this.zoom, te), (Ae[Ir.id] = Ir.createBucket({ index: Ee.bucketLayerIDs.length, layers: fr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Vi, sourceID: this.source })).populate(hr, be, this.tileID.canonical), Ee.bucketLayerIDs.push(fr.map((Ns) => Ns.id)));
              }
            }
            const et = _.aF(be.glyphDependencies, (li) => Object.keys(li).map(Number));
            this.inFlightDependencies.forEach((li) => li == null ? void 0 : li.abort()), this.inFlightDependencies = [];
            let Re = Promise.resolve({});
            if (Object.keys(et).length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), Re = ce.sendAsync({ type: "GG", data: { stacks: et, source: this.source, tileID: this.tileID, type: "glyphs" } }, li);
            }
            const mt = Object.keys(be.iconDependencies);
            let Dt = Promise.resolve({});
            if (mt.length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), Dt = ce.sendAsync({ type: "GI", data: { icons: mt, source: this.source, tileID: this.tileID, type: "icons" } }, li);
            }
            const Zt = Object.keys(be.patternDependencies);
            let vi = Promise.resolve({});
            if (Zt.length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), vi = ce.sendAsync({ type: "GI", data: { icons: Zt, source: this.source, tileID: this.tileID, type: "patterns" } }, li);
            }
            const [Jt, gi, pi] = yield Promise.all([Re, Dt, vi]), Ui = new C(Jt), Fi = new _.bo(gi, pi);
            for (const li in Ae) {
              const Di = Ae[li];
              Di instanceof _.a6 ? (q(Di.layers, this.zoom, te), _.bp({ bucket: Di, glyphMap: Jt, glyphPositions: Ui.positions, imageMap: gi, imagePositions: Fi.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Di.hasPattern && (Di instanceof _.bq || Di instanceof _.br || Di instanceof _.bs) && (q(Di.layers, this.zoom, te), Di.addFeatures(be, this.tileID.canonical, Fi.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Ae).filter((li) => !li.isEmpty()), featureIndex: Ee, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Ui.image, imageAtlas: Fi, glyphMap: this.returnDependencies ? Jt : null, iconMap: this.returnDependencies ? gi : null, glyphPositions: this.returnDependencies ? Ui.positions : null };
          });
        }
      }
      function q(ue, $, W) {
        const te = new _.z($);
        for (const ce of ue) ce.recalculate(te, W);
      }
      class j {
        constructor($, W, te) {
          this.actor = $, this.layerIndex = W, this.availableImages = te, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile($, W) {
          return _._(this, void 0, void 0, function* () {
            const te = yield _.l($.request, W);
            try {
              return { vectorTile: new _.bt.VectorTile(new _.bu(te.data)), rawData: te.data, cacheControl: te.cacheControl, expires: te.expires };
            } catch (ce) {
              const Pe = new Uint8Array(te.data);
              let Ee = `Unable to parse the tile at ${$.request.url}, `;
              throw Ee += Pe[0] === 31 && Pe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ce.message}`, new Error(Ee);
            }
          });
        }
        loadTile($) {
          return _._(this, void 0, void 0, function* () {
            const W = $.uid, te = !!($ && $.request && $.request.collectResourceTiming) && new _.bv($.request), ce = new N($);
            this.loading[W] = ce;
            const Pe = new AbortController();
            ce.abort = Pe;
            try {
              const Ee = yield this.loadVectorTile($, Pe);
              if (delete this.loading[W], !Ee) return null;
              const Ae = Ee.rawData, be = {};
              Ee.expires && (be.expires = Ee.expires), Ee.cacheControl && (be.cacheControl = Ee.cacheControl);
              const Ve = {};
              if (te) {
                const Re = te.finish();
                Re && (Ve.resourceTiming = JSON.parse(JSON.stringify(Re)));
              }
              ce.vectorTile = Ee.vectorTile;
              const et = ce.parse(Ee.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[W] = ce, this.fetching[W] = { rawTileData: Ae, cacheControl: be, resourceTiming: Ve };
              try {
                const Re = yield et;
                return _.e({ rawTileData: Ae.slice(0) }, Re, be, Ve);
              } finally {
                delete this.fetching[W];
              }
            } catch (Ee) {
              throw delete this.loading[W], ce.status = "done", this.loaded[W] = ce, Ee;
            }
          });
        }
        reloadTile($) {
          return _._(this, void 0, void 0, function* () {
            const W = $.uid;
            if (!this.loaded || !this.loaded[W]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const te = this.loaded[W];
            if (te.showCollisionBoxes = $.showCollisionBoxes, te.status === "parsing") {
              const ce = yield te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Pe;
              if (this.fetching[W]) {
                const { rawTileData: Ee, cacheControl: Ae, resourceTiming: be } = this.fetching[W];
                delete this.fetching[W], Pe = _.e({ rawTileData: Ee.slice(0) }, ce, Ae, be);
              } else Pe = ce;
              return Pe;
            }
            if (te.status === "done" && te.vectorTile) return te.parse(te.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile($) {
          return _._(this, void 0, void 0, function* () {
            const W = this.loading, te = $.uid;
            W && W[te] && W[te].abort && (W[te].abort.abort(), delete W[te]);
          });
        }
        removeTile($) {
          return _._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[$.uid] && delete this.loaded[$.uid];
          });
        }
      }
      class V {
        constructor() {
          this.loaded = {};
        }
        loadTile($) {
          return _._(this, void 0, void 0, function* () {
            const { uid: W, encoding: te, rawImageData: ce, redFactor: Pe, greenFactor: Ee, blueFactor: Ae, baseShift: be } = $, Ve = ce.width + 2, et = ce.height + 2, Re = _.b(ce) ? new _.R({ width: Ve, height: et }, yield _.bw(ce, -1, -1, Ve, et)) : ce, mt = new _.bx(W, Re, te, Pe, Ee, Ae, be);
            return this.loaded = this.loaded || {}, this.loaded[W] = mt, mt;
          });
        }
        removeTile($) {
          const W = this.loaded, te = $.uid;
          W && W[te] && delete W[te];
        }
      }
      function F(ue, $) {
        if (ue.length !== 0) {
          de(ue[0], $);
          for (var W = 1; W < ue.length; W++) de(ue[W], !$);
        }
      }
      function de(ue, $) {
        for (var W = 0, te = 0, ce = 0, Pe = ue.length, Ee = Pe - 1; ce < Pe; Ee = ce++) {
          var Ae = (ue[ce][0] - ue[Ee][0]) * (ue[Ee][1] + ue[ce][1]), be = W + Ae;
          te += Math.abs(W) >= Math.abs(Ae) ? W - be + Ae : Ae - be + W, W = be;
        }
        W + te >= 0 != !!$ && ue.reverse();
      }
      var ae = _.by(function ue($, W) {
        var te, ce = $ && $.type;
        if (ce === "FeatureCollection") for (te = 0; te < $.features.length; te++) ue($.features[te], W);
        else if (ce === "GeometryCollection") for (te = 0; te < $.geometries.length; te++) ue($.geometries[te], W);
        else if (ce === "Feature") ue($.geometry, W);
        else if (ce === "Polygon") F($.coordinates, W);
        else if (ce === "MultiPolygon") for (te = 0; te < $.coordinates.length; te++) F($.coordinates[te], W);
        return $;
      });
      const ye = _.bt.VectorTileFeature.prototype.toGeoJSON;
      var se = { exports: {} }, ge = _.bz, Me = _.bt.VectorTileFeature, Ye = $e;
      function $e(ue, $) {
        this.options = $ || {}, this.features = ue, this.length = ue.length;
      }
      function tt(ue, $) {
        this.id = typeof ue.id == "number" ? ue.id : void 0, this.type = ue.type, this.rawGeometry = ue.type === 1 ? [ue.geometry] : ue.geometry, this.properties = ue.tags, this.extent = $ || 4096;
      }
      $e.prototype.feature = function(ue) {
        return new tt(this.features[ue], this.options.extent);
      }, tt.prototype.loadGeometry = function() {
        var ue = this.rawGeometry;
        this.geometry = [];
        for (var $ = 0; $ < ue.length; $++) {
          for (var W = ue[$], te = [], ce = 0; ce < W.length; ce++) te.push(new ge(W[ce][0], W[ce][1]));
          this.geometry.push(te);
        }
        return this.geometry;
      }, tt.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var ue = this.geometry, $ = 1 / 0, W = -1 / 0, te = 1 / 0, ce = -1 / 0, Pe = 0; Pe < ue.length; Pe++) for (var Ee = ue[Pe], Ae = 0; Ae < Ee.length; Ae++) {
          var be = Ee[Ae];
          $ = Math.min($, be.x), W = Math.max(W, be.x), te = Math.min(te, be.y), ce = Math.max(ce, be.y);
        }
        return [$, te, W, ce];
      }, tt.prototype.toGeoJSON = Me.prototype.toGeoJSON;
      var Be = _.bA, Ie = Ye;
      function ot(ue) {
        var $ = new Be();
        return function(W, te) {
          for (var ce in W.layers) te.writeMessage(3, it, W.layers[ce]);
        }(ue, $), $.finish();
      }
      function it(ue, $) {
        var W;
        $.writeVarintField(15, ue.version || 1), $.writeStringField(1, ue.name || ""), $.writeVarintField(5, ue.extent || 4096);
        var te = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (W = 0; W < ue.length; W++) te.feature = ue.feature(W), $.writeMessage(2, oe, te);
        var ce = te.keys;
        for (W = 0; W < ce.length; W++) $.writeStringField(3, ce[W]);
        var Pe = te.values;
        for (W = 0; W < Pe.length; W++) $.writeMessage(4, We, Pe[W]);
      }
      function oe(ue, $) {
        var W = ue.feature;
        W.id !== void 0 && $.writeVarintField(1, W.id), $.writeMessage(2, le, ue), $.writeVarintField(3, W.type), $.writeMessage(4, He, W);
      }
      function le(ue, $) {
        var W = ue.feature, te = ue.keys, ce = ue.values, Pe = ue.keycache, Ee = ue.valuecache;
        for (var Ae in W.properties) {
          var be = W.properties[Ae], Ve = Pe[Ae];
          if (be !== null) {
            Ve === void 0 && (te.push(Ae), Pe[Ae] = Ve = te.length - 1), $.writeVarint(Ve);
            var et = typeof be;
            et !== "string" && et !== "boolean" && et !== "number" && (be = JSON.stringify(be));
            var Re = et + ":" + be, mt = Ee[Re];
            mt === void 0 && (ce.push(be), Ee[Re] = mt = ce.length - 1), $.writeVarint(mt);
          }
        }
      }
      function Le(ue, $) {
        return ($ << 3) + (7 & ue);
      }
      function Se(ue) {
        return ue << 1 ^ ue >> 31;
      }
      function He(ue, $) {
        for (var W = ue.loadGeometry(), te = ue.type, ce = 0, Pe = 0, Ee = W.length, Ae = 0; Ae < Ee; Ae++) {
          var be = W[Ae], Ve = 1;
          te === 1 && (Ve = be.length), $.writeVarint(Le(1, Ve));
          for (var et = te === 3 ? be.length - 1 : be.length, Re = 0; Re < et; Re++) {
            Re === 1 && te !== 1 && $.writeVarint(Le(2, et - 1));
            var mt = be[Re].x - ce, Dt = be[Re].y - Pe;
            $.writeVarint(Se(mt)), $.writeVarint(Se(Dt)), ce += mt, Pe += Dt;
          }
          te === 3 && $.writeVarint(Le(7, 1));
        }
      }
      function We(ue, $) {
        var W = typeof ue;
        W === "string" ? $.writeStringField(1, ue) : W === "boolean" ? $.writeBooleanField(7, ue) : W === "number" && (ue % 1 != 0 ? $.writeDoubleField(3, ue) : ue < 0 ? $.writeSVarintField(6, ue) : $.writeVarintField(5, ue));
      }
      se.exports = ot, se.exports.fromVectorTileJs = ot, se.exports.fromGeojsonVt = function(ue, $) {
        $ = $ || {};
        var W = {};
        for (var te in ue) W[te] = new Ie(ue[te].features, $), W[te].name = te, W[te].version = $.version, W[te].extent = $.extent;
        return ot({ layers: W });
      }, se.exports.GeoJSONWrapper = Ie;
      var Je = _.by(se.exports);
      const je = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ue) => ue }, rt = Math.fround || (Ke = new Float32Array(1), (ue) => (Ke[0] = +ue, Ke[0]));
      var Ke;
      const St = 3, J = 5, fe = 6;
      class _e {
        constructor($) {
          this.options = Object.assign(Object.create(je), $), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load($) {
          const { log: W, minZoom: te, maxZoom: ce } = this.options;
          W && console.time("total time");
          const Pe = `prepare ${$.length} points`;
          W && console.time(Pe), this.points = $;
          const Ee = [];
          for (let be = 0; be < $.length; be++) {
            const Ve = $[be];
            if (!Ve.geometry) continue;
            const [et, Re] = Ve.geometry.coordinates, mt = rt(Oe(et)), Dt = rt(qe(Re));
            Ee.push(mt, Dt, 1 / 0, be, -1, 1), this.options.reduce && Ee.push(0);
          }
          let Ae = this.trees[ce + 1] = this._createTree(Ee);
          W && console.timeEnd(Pe);
          for (let be = ce; be >= te; be--) {
            const Ve = +Date.now();
            Ae = this.trees[be] = this._createTree(this._cluster(Ae, be)), W && console.log("z%d: %d clusters in %dms", be, Ae.numItems, +Date.now() - Ve);
          }
          return W && console.timeEnd("total time"), this;
        }
        getClusters($, W) {
          let te = (($[0] + 180) % 360 + 360) % 360 - 180;
          const ce = Math.max(-90, Math.min(90, $[1]));
          let Pe = $[2] === 180 ? 180 : (($[2] + 180) % 360 + 360) % 360 - 180;
          const Ee = Math.max(-90, Math.min(90, $[3]));
          if ($[2] - $[0] >= 360) te = -180, Pe = 180;
          else if (te > Pe) {
            const Re = this.getClusters([te, ce, 180, Ee], W), mt = this.getClusters([-180, ce, Pe, Ee], W);
            return Re.concat(mt);
          }
          const Ae = this.trees[this._limitZoom(W)], be = Ae.range(Oe(te), qe(Ee), Oe(Pe), qe(ce)), Ve = Ae.data, et = [];
          for (const Re of be) {
            const mt = this.stride * Re;
            et.push(Ve[mt + J] > 1 ? Ce(Ve, mt, this.clusterProps) : this.points[Ve[mt + St]]);
          }
          return et;
        }
        getChildren($) {
          const W = this._getOriginId($), te = this._getOriginZoom($), ce = "No cluster with the specified id.", Pe = this.trees[te];
          if (!Pe) throw new Error(ce);
          const Ee = Pe.data;
          if (W * this.stride >= Ee.length) throw new Error(ce);
          const Ae = this.options.radius / (this.options.extent * Math.pow(2, te - 1)), be = Pe.within(Ee[W * this.stride], Ee[W * this.stride + 1], Ae), Ve = [];
          for (const et of be) {
            const Re = et * this.stride;
            Ee[Re + 4] === $ && Ve.push(Ee[Re + J] > 1 ? Ce(Ee, Re, this.clusterProps) : this.points[Ee[Re + St]]);
          }
          if (Ve.length === 0) throw new Error(ce);
          return Ve;
        }
        getLeaves($, W, te) {
          const ce = [];
          return this._appendLeaves(ce, $, W = W || 10, te = te || 0, 0), ce;
        }
        getTile($, W, te) {
          const ce = this.trees[this._limitZoom($)], Pe = Math.pow(2, $), { extent: Ee, radius: Ae } = this.options, be = Ae / Ee, Ve = (te - be) / Pe, et = (te + 1 + be) / Pe, Re = { features: [] };
          return this._addTileFeatures(ce.range((W - be) / Pe, Ve, (W + 1 + be) / Pe, et), ce.data, W, te, Pe, Re), W === 0 && this._addTileFeatures(ce.range(1 - be / Pe, Ve, 1, et), ce.data, Pe, te, Pe, Re), W === Pe - 1 && this._addTileFeatures(ce.range(0, Ve, be / Pe, et), ce.data, -1, te, Pe, Re), Re.features.length ? Re : null;
        }
        getClusterExpansionZoom($) {
          let W = this._getOriginZoom($) - 1;
          for (; W <= this.options.maxZoom; ) {
            const te = this.getChildren($);
            if (W++, te.length !== 1) break;
            $ = te[0].properties.cluster_id;
          }
          return W;
        }
        _appendLeaves($, W, te, ce, Pe) {
          const Ee = this.getChildren(W);
          for (const Ae of Ee) {
            const be = Ae.properties;
            if (be && be.cluster ? Pe + be.point_count <= ce ? Pe += be.point_count : Pe = this._appendLeaves($, be.cluster_id, te, ce, Pe) : Pe < ce ? Pe++ : $.push(Ae), $.length === te) break;
          }
          return Pe;
        }
        _createTree($) {
          const W = new _.av($.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let te = 0; te < $.length; te += this.stride) W.add($[te], $[te + 1]);
          return W.finish(), W.data = $, W;
        }
        _addTileFeatures($, W, te, ce, Pe, Ee) {
          for (const Ae of $) {
            const be = Ae * this.stride, Ve = W[be + J] > 1;
            let et, Re, mt;
            if (Ve) et = De(W, be, this.clusterProps), Re = W[be], mt = W[be + 1];
            else {
              const vi = this.points[W[be + St]];
              et = vi.properties;
              const [Jt, gi] = vi.geometry.coordinates;
              Re = Oe(Jt), mt = qe(gi);
            }
            const Dt = { type: 1, geometry: [[Math.round(this.options.extent * (Re * Pe - te)), Math.round(this.options.extent * (mt * Pe - ce))]], tags: et };
            let Zt;
            Zt = Ve || this.options.generateId ? W[be + St] : this.points[W[be + St]].id, Zt !== void 0 && (Dt.id = Zt), Ee.features.push(Dt);
          }
        }
        _limitZoom($) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+$), this.options.maxZoom + 1));
        }
        _cluster($, W) {
          const { radius: te, extent: ce, reduce: Pe, minPoints: Ee } = this.options, Ae = te / (ce * Math.pow(2, W)), be = $.data, Ve = [], et = this.stride;
          for (let Re = 0; Re < be.length; Re += et) {
            if (be[Re + 2] <= W) continue;
            be[Re + 2] = W;
            const mt = be[Re], Dt = be[Re + 1], Zt = $.within(be[Re], be[Re + 1], Ae), vi = be[Re + J];
            let Jt = vi;
            for (const gi of Zt) {
              const pi = gi * et;
              be[pi + 2] > W && (Jt += be[pi + J]);
            }
            if (Jt > vi && Jt >= Ee) {
              let gi, pi = mt * vi, Ui = Dt * vi, Fi = -1;
              const li = ((Re / et | 0) << 5) + (W + 1) + this.points.length;
              for (const Di of Zt) {
                const Vi = Di * et;
                if (be[Vi + 2] <= W) continue;
                be[Vi + 2] = W;
                const hr = be[Vi + J];
                pi += be[Vi] * hr, Ui += be[Vi + 1] * hr, be[Vi + 4] = li, Pe && (gi || (gi = this._map(be, Re, !0), Fi = this.clusterProps.length, this.clusterProps.push(gi)), Pe(gi, this._map(be, Vi)));
              }
              be[Re + 4] = li, Ve.push(pi / Jt, Ui / Jt, 1 / 0, li, -1, Jt), Pe && Ve.push(Fi);
            } else {
              for (let gi = 0; gi < et; gi++) Ve.push(be[Re + gi]);
              if (Jt > 1) for (const gi of Zt) {
                const pi = gi * et;
                if (!(be[pi + 2] <= W)) {
                  be[pi + 2] = W;
                  for (let Ui = 0; Ui < et; Ui++) Ve.push(be[pi + Ui]);
                }
              }
            }
          }
          return Ve;
        }
        _getOriginId($) {
          return $ - this.points.length >> 5;
        }
        _getOriginZoom($) {
          return ($ - this.points.length) % 32;
        }
        _map($, W, te) {
          if ($[W + J] > 1) {
            const Ee = this.clusterProps[$[W + fe]];
            return te ? Object.assign({}, Ee) : Ee;
          }
          const ce = this.points[$[W + St]].properties, Pe = this.options.map(ce);
          return te && Pe === ce ? Object.assign({}, Pe) : Pe;
        }
      }
      function Ce(ue, $, W) {
        return { type: "Feature", id: ue[$ + St], properties: De(ue, $, W), geometry: { type: "Point", coordinates: [(te = ue[$], 360 * (te - 0.5)), Ze(ue[$ + 1])] } };
        var te;
      }
      function De(ue, $, W) {
        const te = ue[$ + J], ce = te >= 1e4 ? `${Math.round(te / 1e3)}k` : te >= 1e3 ? Math.round(te / 100) / 10 + "k" : te, Pe = ue[$ + fe], Ee = Pe === -1 ? {} : Object.assign({}, W[Pe]);
        return Object.assign(Ee, { cluster: !0, cluster_id: ue[$ + St], point_count: te, point_count_abbreviated: ce });
      }
      function Oe(ue) {
        return ue / 360 + 0.5;
      }
      function qe(ue) {
        const $ = Math.sin(ue * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
        return W < 0 ? 0 : W > 1 ? 1 : W;
      }
      function Ze(ue) {
        const $ = (180 - 360 * ue) * Math.PI / 180;
        return 360 * Math.atan(Math.exp($)) / Math.PI - 90;
      }
      function wt(ue, $, W, te) {
        let ce = te;
        const Pe = $ + (W - $ >> 1);
        let Ee, Ae = W - $;
        const be = ue[$], Ve = ue[$ + 1], et = ue[W], Re = ue[W + 1];
        for (let mt = $ + 3; mt < W; mt += 3) {
          const Dt = bt(ue[mt], ue[mt + 1], be, Ve, et, Re);
          if (Dt > ce) Ee = mt, ce = Dt;
          else if (Dt === ce) {
            const Zt = Math.abs(mt - Pe);
            Zt < Ae && (Ee = mt, Ae = Zt);
          }
        }
        ce > te && (Ee - $ > 3 && wt(ue, $, Ee, te), ue[Ee + 2] = ce, W - Ee > 3 && wt(ue, Ee, W, te));
      }
      function bt(ue, $, W, te, ce, Pe) {
        let Ee = ce - W, Ae = Pe - te;
        if (Ee !== 0 || Ae !== 0) {
          const be = ((ue - W) * Ee + ($ - te) * Ae) / (Ee * Ee + Ae * Ae);
          be > 1 ? (W = ce, te = Pe) : be > 0 && (W += Ee * be, te += Ae * be);
        }
        return Ee = ue - W, Ae = $ - te, Ee * Ee + Ae * Ae;
      }
      function Tt(ue, $, W, te) {
        const ce = { id: ue ?? null, type: $, geometry: W, tags: te, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if ($ === "Point" || $ === "MultiPoint" || $ === "LineString") Mt(ce, W);
        else if ($ === "Polygon") Mt(ce, W[0]);
        else if ($ === "MultiLineString") for (const Pe of W) Mt(ce, Pe);
        else if ($ === "MultiPolygon") for (const Pe of W) Mt(ce, Pe[0]);
        return ce;
      }
      function Mt(ue, $) {
        for (let W = 0; W < $.length; W += 3) ue.minX = Math.min(ue.minX, $[W]), ue.minY = Math.min(ue.minY, $[W + 1]), ue.maxX = Math.max(ue.maxX, $[W]), ue.maxY = Math.max(ue.maxY, $[W + 1]);
      }
      function Qt(ue, $, W, te) {
        if (!$.geometry) return;
        const ce = $.geometry.coordinates;
        if (ce && ce.length === 0) return;
        const Pe = $.geometry.type, Ee = Math.pow(W.tolerance / ((1 << W.maxZoom) * W.extent), 2);
        let Ae = [], be = $.id;
        if (W.promoteId ? be = $.properties[W.promoteId] : W.generateId && (be = te || 0), Pe === "Point") Qe(ce, Ae);
        else if (Pe === "MultiPoint") for (const Ve of ce) Qe(Ve, Ae);
        else if (Pe === "LineString") Y(ce, Ae, Ee, !1);
        else if (Pe === "MultiLineString") {
          if (W.lineMetrics) {
            for (const Ve of ce) Ae = [], Y(Ve, Ae, Ee, !1), ue.push(Tt(be, "LineString", Ae, $.properties));
            return;
          }
          ui(ce, Ae, Ee, !1);
        } else if (Pe === "Polygon") ui(ce, Ae, Ee, !0);
        else {
          if (Pe !== "MultiPolygon") {
            if (Pe === "GeometryCollection") {
              for (const Ve of $.geometry.geometries) Qt(ue, { id: be, geometry: Ve, properties: $.properties }, W, te);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const Ve of ce) {
            const et = [];
            ui(Ve, et, Ee, !0), Ae.push(et);
          }
        }
        ue.push(Tt(be, Pe, Ae, $.properties));
      }
      function Qe(ue, $) {
        $.push($t(ue[0]), at(ue[1]), 0);
      }
      function Y(ue, $, W, te) {
        let ce, Pe, Ee = 0;
        for (let be = 0; be < ue.length; be++) {
          const Ve = $t(ue[be][0]), et = at(ue[be][1]);
          $.push(Ve, et, 0), be > 0 && (Ee += te ? (ce * et - Ve * Pe) / 2 : Math.sqrt(Math.pow(Ve - ce, 2) + Math.pow(et - Pe, 2))), ce = Ve, Pe = et;
        }
        const Ae = $.length - 3;
        $[2] = 1, wt($, 0, Ae, W), $[Ae + 2] = 1, $.size = Math.abs(Ee), $.start = 0, $.end = $.size;
      }
      function ui(ue, $, W, te) {
        for (let ce = 0; ce < ue.length; ce++) {
          const Pe = [];
          Y(ue[ce], Pe, W, te), $.push(Pe);
        }
      }
      function $t(ue) {
        return ue / 360 + 0.5;
      }
      function at(ue) {
        const $ = Math.sin(ue * Math.PI / 180), W = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
        return W < 0 ? 0 : W > 1 ? 1 : W;
      }
      function yt(ue, $, W, te, ce, Pe, Ee, Ae) {
        if (te /= $, Pe >= (W /= $) && Ee < te) return ue;
        if (Ee < W || Pe >= te) return null;
        const be = [];
        for (const Ve of ue) {
          const et = Ve.geometry;
          let Re = Ve.type;
          const mt = ce === 0 ? Ve.minX : Ve.minY, Dt = ce === 0 ? Ve.maxX : Ve.maxY;
          if (mt >= W && Dt < te) {
            be.push(Ve);
            continue;
          }
          if (Dt < W || mt >= te) continue;
          let Zt = [];
          if (Re === "Point" || Re === "MultiPoint") zt(et, Zt, W, te, ce);
          else if (Re === "LineString") Pt(et, Zt, W, te, ce, !1, Ae.lineMetrics);
          else if (Re === "MultiLineString") di(et, Zt, W, te, ce, !1);
          else if (Re === "Polygon") di(et, Zt, W, te, ce, !0);
          else if (Re === "MultiPolygon") for (const vi of et) {
            const Jt = [];
            di(vi, Jt, W, te, ce, !0), Jt.length && Zt.push(Jt);
          }
          if (Zt.length) {
            if (Ae.lineMetrics && Re === "LineString") {
              for (const vi of Zt) be.push(Tt(Ve.id, Re, vi, Ve.tags));
              continue;
            }
            Re !== "LineString" && Re !== "MultiLineString" || (Zt.length === 1 ? (Re = "LineString", Zt = Zt[0]) : Re = "MultiLineString"), Re !== "Point" && Re !== "MultiPoint" || (Re = Zt.length === 3 ? "Point" : "MultiPoint"), be.push(Tt(Ve.id, Re, Zt, Ve.tags));
          }
        }
        return be.length ? be : null;
      }
      function zt(ue, $, W, te, ce) {
        for (let Pe = 0; Pe < ue.length; Pe += 3) {
          const Ee = ue[Pe + ce];
          Ee >= W && Ee <= te && oi($, ue[Pe], ue[Pe + 1], ue[Pe + 2]);
        }
      }
      function Pt(ue, $, W, te, ce, Pe, Ee) {
        let Ae = Gt(ue);
        const be = ce === 0 ? bi : Ci;
        let Ve, et, Re = ue.start;
        for (let Jt = 0; Jt < ue.length - 3; Jt += 3) {
          const gi = ue[Jt], pi = ue[Jt + 1], Ui = ue[Jt + 2], Fi = ue[Jt + 3], li = ue[Jt + 4], Di = ce === 0 ? gi : pi, Vi = ce === 0 ? Fi : li;
          let hr = !1;
          Ee && (Ve = Math.sqrt(Math.pow(gi - Fi, 2) + Math.pow(pi - li, 2))), Di < W ? Vi > W && (et = be(Ae, gi, pi, Fi, li, W), Ee && (Ae.start = Re + Ve * et)) : Di > te ? Vi < te && (et = be(Ae, gi, pi, Fi, li, te), Ee && (Ae.start = Re + Ve * et)) : oi(Ae, gi, pi, Ui), Vi < W && Di >= W && (et = be(Ae, gi, pi, Fi, li, W), hr = !0), Vi > te && Di <= te && (et = be(Ae, gi, pi, Fi, li, te), hr = !0), !Pe && hr && (Ee && (Ae.end = Re + Ve * et), $.push(Ae), Ae = Gt(ue)), Ee && (Re += Ve);
        }
        let mt = ue.length - 3;
        const Dt = ue[mt], Zt = ue[mt + 1], vi = ce === 0 ? Dt : Zt;
        vi >= W && vi <= te && oi(Ae, Dt, Zt, ue[mt + 2]), mt = Ae.length - 3, Pe && mt >= 3 && (Ae[mt] !== Ae[0] || Ae[mt + 1] !== Ae[1]) && oi(Ae, Ae[0], Ae[1], Ae[2]), Ae.length && $.push(Ae);
      }
      function Gt(ue) {
        const $ = [];
        return $.size = ue.size, $.start = ue.start, $.end = ue.end, $;
      }
      function di(ue, $, W, te, ce, Pe) {
        for (const Ee of ue) Pt(Ee, $, W, te, ce, Pe, !1);
      }
      function oi(ue, $, W, te) {
        ue.push($, W, te);
      }
      function bi(ue, $, W, te, ce, Pe) {
        const Ee = (Pe - $) / (te - $);
        return oi(ue, Pe, W + (ce - W) * Ee, 1), Ee;
      }
      function Ci(ue, $, W, te, ce, Pe) {
        const Ee = (Pe - W) / (ce - W);
        return oi(ue, $ + (te - $) * Ee, Pe, 1), Ee;
      }
      function lt(ue, $) {
        const W = [];
        for (let te = 0; te < ue.length; te++) {
          const ce = ue[te], Pe = ce.type;
          let Ee;
          if (Pe === "Point" || Pe === "MultiPoint" || Pe === "LineString") Ee = ei(ce.geometry, $);
          else if (Pe === "MultiLineString" || Pe === "Polygon") {
            Ee = [];
            for (const Ae of ce.geometry) Ee.push(ei(Ae, $));
          } else if (Pe === "MultiPolygon") {
            Ee = [];
            for (const Ae of ce.geometry) {
              const be = [];
              for (const Ve of Ae) be.push(ei(Ve, $));
              Ee.push(be);
            }
          }
          W.push(Tt(ce.id, Pe, Ee, ce.tags));
        }
        return W;
      }
      function ei(ue, $) {
        const W = [];
        W.size = ue.size, ue.start !== void 0 && (W.start = ue.start, W.end = ue.end);
        for (let te = 0; te < ue.length; te += 3) W.push(ue[te] + $, ue[te + 1], ue[te + 2]);
        return W;
      }
      function ai(ue, $) {
        if (ue.transformed) return ue;
        const W = 1 << ue.z, te = ue.x, ce = ue.y;
        for (const Pe of ue.features) {
          const Ee = Pe.geometry, Ae = Pe.type;
          if (Pe.geometry = [], Ae === 1) for (let be = 0; be < Ee.length; be += 2) Pe.geometry.push(It(Ee[be], Ee[be + 1], $, W, te, ce));
          else for (let be = 0; be < Ee.length; be++) {
            const Ve = [];
            for (let et = 0; et < Ee[be].length; et += 2) Ve.push(It(Ee[be][et], Ee[be][et + 1], $, W, te, ce));
            Pe.geometry.push(Ve);
          }
        }
        return ue.transformed = !0, ue;
      }
      function It(ue, $, W, te, ce, Pe) {
        return [Math.round(W * (ue * te - ce)), Math.round(W * ($ * te - Pe))];
      }
      function cr(ue, $, W, te, ce) {
        const Pe = $ === ce.maxZoom ? 0 : ce.tolerance / ((1 << $) * ce.extent), Ee = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ue.length, source: null, x: W, y: te, z: $, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const Ae of ue) ct(Ee, Ae, Pe, ce);
        return Ee;
      }
      function ct(ue, $, W, te) {
        const ce = $.geometry, Pe = $.type, Ee = [];
        if (ue.minX = Math.min(ue.minX, $.minX), ue.minY = Math.min(ue.minY, $.minY), ue.maxX = Math.max(ue.maxX, $.maxX), ue.maxY = Math.max(ue.maxY, $.maxY), Pe === "Point" || Pe === "MultiPoint") for (let Ae = 0; Ae < ce.length; Ae += 3) Ee.push(ce[Ae], ce[Ae + 1]), ue.numPoints++, ue.numSimplified++;
        else if (Pe === "LineString") si(Ee, ce, ue, W, !1, !1);
        else if (Pe === "MultiLineString" || Pe === "Polygon") for (let Ae = 0; Ae < ce.length; Ae++) si(Ee, ce[Ae], ue, W, Pe === "Polygon", Ae === 0);
        else if (Pe === "MultiPolygon") for (let Ae = 0; Ae < ce.length; Ae++) {
          const be = ce[Ae];
          for (let Ve = 0; Ve < be.length; Ve++) si(Ee, be[Ve], ue, W, !0, Ve === 0);
        }
        if (Ee.length) {
          let Ae = $.tags || null;
          if (Pe === "LineString" && te.lineMetrics) {
            Ae = {};
            for (const Ve in $.tags) Ae[Ve] = $.tags[Ve];
            Ae.mapbox_clip_start = ce.start / ce.size, Ae.mapbox_clip_end = ce.end / ce.size;
          }
          const be = { geometry: Ee, type: Pe === "Polygon" || Pe === "MultiPolygon" ? 3 : Pe === "LineString" || Pe === "MultiLineString" ? 2 : 1, tags: Ae };
          $.id !== null && (be.id = $.id), ue.features.push(be);
        }
      }
      function si(ue, $, W, te, ce, Pe) {
        const Ee = te * te;
        if (te > 0 && $.size < (ce ? Ee : te)) return void (W.numPoints += $.length / 3);
        const Ae = [];
        for (let be = 0; be < $.length; be += 3) (te === 0 || $[be + 2] > Ee) && (W.numSimplified++, Ae.push($[be], $[be + 1])), W.numPoints++;
        ce && function(be, Ve) {
          let et = 0;
          for (let Re = 0, mt = be.length, Dt = mt - 2; Re < mt; Dt = Re, Re += 2) et += (be[Re] - be[Dt]) * (be[Re + 1] + be[Dt + 1]);
          if (et > 0 === Ve) for (let Re = 0, mt = be.length; Re < mt / 2; Re += 2) {
            const Dt = be[Re], Zt = be[Re + 1];
            be[Re] = be[mt - 2 - Re], be[Re + 1] = be[mt - 1 - Re], be[mt - 2 - Re] = Dt, be[mt - 1 - Re] = Zt;
          }
        }(Ae, Pe), ue.push(Ae);
      }
      const kt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class Ei {
        constructor($, W) {
          const te = (W = this.options = function(Pe, Ee) {
            for (const Ae in Ee) Pe[Ae] = Ee[Ae];
            return Pe;
          }(Object.create(kt), W)).debug;
          if (te && console.time("preprocess data"), W.maxZoom < 0 || W.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (W.promoteId && W.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ce = function(Pe, Ee) {
            const Ae = [];
            if (Pe.type === "FeatureCollection") for (let be = 0; be < Pe.features.length; be++) Qt(Ae, Pe.features[be], Ee, be);
            else Qt(Ae, Pe.type === "Feature" ? Pe : { geometry: Pe }, Ee);
            return Ae;
          }($, W);
          this.tiles = {}, this.tileCoords = [], te && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", W.indexMaxZoom, W.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ce = function(Pe, Ee) {
            const Ae = Ee.buffer / Ee.extent;
            let be = Pe;
            const Ve = yt(Pe, 1, -1 - Ae, Ae, 0, -1, 2, Ee), et = yt(Pe, 1, 1 - Ae, 2 + Ae, 0, -1, 2, Ee);
            return (Ve || et) && (be = yt(Pe, 1, -Ae, 1 + Ae, 0, -1, 2, Ee) || [], Ve && (be = lt(Ve, 1).concat(be)), et && (be = be.concat(lt(et, -1)))), be;
          }(ce, W), ce.length && this.splitTile(ce, 0, 0, 0), te && (ce.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile($, W, te, ce, Pe, Ee, Ae) {
          const be = [$, W, te, ce], Ve = this.options, et = Ve.debug;
          for (; be.length; ) {
            ce = be.pop(), te = be.pop(), W = be.pop(), $ = be.pop();
            const Re = 1 << W, mt = Pr(W, te, ce);
            let Dt = this.tiles[mt];
            if (!Dt && (et > 1 && console.time("creation"), Dt = this.tiles[mt] = cr($, W, te, ce, Ve), this.tileCoords.push({ z: W, x: te, y: ce }), et)) {
              et > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", W, te, ce, Dt.numFeatures, Dt.numPoints, Dt.numSimplified), console.timeEnd("creation"));
              const hr = `z${W}`;
              this.stats[hr] = (this.stats[hr] || 0) + 1, this.total++;
            }
            if (Dt.source = $, Pe == null) {
              if (W === Ve.indexMaxZoom || Dt.numPoints <= Ve.indexMaxPoints) continue;
            } else {
              if (W === Ve.maxZoom || W === Pe) continue;
              if (Pe != null) {
                const hr = Pe - W;
                if (te !== Ee >> hr || ce !== Ae >> hr) continue;
              }
            }
            if (Dt.source = null, $.length === 0) continue;
            et > 1 && console.time("clipping");
            const Zt = 0.5 * Ve.buffer / Ve.extent, vi = 0.5 - Zt, Jt = 0.5 + Zt, gi = 1 + Zt;
            let pi = null, Ui = null, Fi = null, li = null, Di = yt($, Re, te - Zt, te + Jt, 0, Dt.minX, Dt.maxX, Ve), Vi = yt($, Re, te + vi, te + gi, 0, Dt.minX, Dt.maxX, Ve);
            $ = null, Di && (pi = yt(Di, Re, ce - Zt, ce + Jt, 1, Dt.minY, Dt.maxY, Ve), Ui = yt(Di, Re, ce + vi, ce + gi, 1, Dt.minY, Dt.maxY, Ve), Di = null), Vi && (Fi = yt(Vi, Re, ce - Zt, ce + Jt, 1, Dt.minY, Dt.maxY, Ve), li = yt(Vi, Re, ce + vi, ce + gi, 1, Dt.minY, Dt.maxY, Ve), Vi = null), et > 1 && console.timeEnd("clipping"), be.push(pi || [], W + 1, 2 * te, 2 * ce), be.push(Ui || [], W + 1, 2 * te, 2 * ce + 1), be.push(Fi || [], W + 1, 2 * te + 1, 2 * ce), be.push(li || [], W + 1, 2 * te + 1, 2 * ce + 1);
          }
        }
        getTile($, W, te) {
          $ = +$, W = +W, te = +te;
          const ce = this.options, { extent: Pe, debug: Ee } = ce;
          if ($ < 0 || $ > 24) return null;
          const Ae = 1 << $, be = Pr($, W = W + Ae & Ae - 1, te);
          if (this.tiles[be]) return ai(this.tiles[be], Pe);
          Ee > 1 && console.log("drilling down to z%d-%d-%d", $, W, te);
          let Ve, et = $, Re = W, mt = te;
          for (; !Ve && et > 0; ) et--, Re >>= 1, mt >>= 1, Ve = this.tiles[Pr(et, Re, mt)];
          return Ve && Ve.source ? (Ee > 1 && (console.log("found parent tile z%d-%d-%d", et, Re, mt), console.time("drilling down")), this.splitTile(Ve.source, et, Re, mt, $, W, te), Ee > 1 && console.timeEnd("drilling down"), this.tiles[be] ? ai(this.tiles[be], Pe) : null) : null;
        }
      }
      function Pr(ue, $, W) {
        return 32 * ((1 << ue) * W + $) + ue;
      }
      function Et(ue, $) {
        return $ ? ue.properties[$] : ue.id;
      }
      function $r(ue, $) {
        if (ue == null) return !0;
        if (ue.type === "Feature") return Et(ue, $) != null;
        if (ue.type === "FeatureCollection") {
          const W = /* @__PURE__ */ new Set();
          for (const te of ue.features) {
            const ce = Et(te, $);
            if (ce == null || W.has(ce)) return !1;
            W.add(ce);
          }
          return !0;
        }
        return !1;
      }
      function qi(ue, $) {
        const W = /* @__PURE__ */ new Map();
        if (ue != null) if (ue.type === "Feature") W.set(Et(ue, $), ue);
        else for (const te of ue.features) W.set(Et(te, $), te);
        return W;
      }
      class Cr extends j {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile($, W) {
          return _._(this, void 0, void 0, function* () {
            const te = $.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ce = this._geoJSONIndex.getTile(te.z, te.x, te.y);
            if (!ce) return null;
            const Pe = new class {
              constructor(Ae) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = _.X, this.length = Ae.length, this._features = Ae;
              }
              feature(Ae) {
                return new class {
                  constructor(be) {
                    this._feature = be, this.extent = _.X, this.type = be.type, this.properties = be.tags, "id" in be && !isNaN(be.id) && (this.id = parseInt(be.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const be = [];
                      for (const Ve of this._feature.geometry) be.push([new _.P(Ve[0], Ve[1])]);
                      return be;
                    }
                    {
                      const be = [];
                      for (const Ve of this._feature.geometry) {
                        const et = [];
                        for (const Re of Ve) et.push(new _.P(Re[0], Re[1]));
                        be.push(et);
                      }
                      return be;
                    }
                  }
                  toGeoJSON(be, Ve, et) {
                    return ye.call(this, be, Ve, et);
                  }
                }(this._features[Ae]);
              }
            }(ce.features);
            let Ee = Je(Pe);
            return Ee.byteOffset === 0 && Ee.byteLength === Ee.buffer.byteLength || (Ee = new Uint8Array(Ee)), { vectorTile: Pe, rawData: Ee.buffer };
          });
        }
        loadData($) {
          return _._(this, void 0, void 0, function* () {
            var W;
            (W = this._pendingRequest) === null || W === void 0 || W.abort();
            const te = !!($ && $.request && $.request.collectResourceTiming) && new _.bv($.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON($, this._pendingRequest), this._geoJSONIndex = $.cluster ? new _e(function({ superclusterOptions: Ee, clusterProperties: Ae }) {
                if (!Ae || !Ee) return Ee;
                const be = {}, Ve = {}, et = { accumulated: null, zoom: 0 }, Re = { properties: null }, mt = Object.keys(Ae);
                for (const Dt of mt) {
                  const [Zt, vi] = Ae[Dt], Jt = _.bC(vi), gi = _.bC(typeof Zt == "string" ? [Zt, ["accumulated"], ["get", Dt]] : Zt);
                  be[Dt] = Jt.value, Ve[Dt] = gi.value;
                }
                return Ee.map = (Dt) => {
                  Re.properties = Dt;
                  const Zt = {};
                  for (const vi of mt) Zt[vi] = be[vi].evaluate(et, Re);
                  return Zt;
                }, Ee.reduce = (Dt, Zt) => {
                  Re.properties = Zt;
                  for (const vi of mt) et.accumulated = Dt[vi], Dt[vi] = Ve[vi].evaluate(et, Re);
                }, Ee;
              }($)).load((yield this._pendingData).features) : (ce = yield this._pendingData, new Ei(ce, $.geojsonVtOptions)), this.loaded = {};
              const Pe = {};
              if (te) {
                const Ee = te.finish();
                Ee && (Pe.resourceTiming = {}, Pe.resourceTiming[$.source] = JSON.parse(JSON.stringify(Ee)));
              }
              return Pe;
            } catch (Pe) {
              if (delete this._pendingRequest, _.bB(Pe)) return { abandoned: !0 };
              throw Pe;
            }
            var ce;
          });
        }
        getData() {
          return _._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile($) {
          const W = this.loaded;
          return W && W[$.uid] ? super.reloadTile($) : this.loadTile($);
        }
        loadAndProcessGeoJSON($, W) {
          return _._(this, void 0, void 0, function* () {
            let te = yield this.loadGeoJSON($, W);
            if (delete this._pendingRequest, typeof te != "object") throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
            if (ae(te, !0), $.filter) {
              const ce = _.bC($.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ce.result === "error") throw new Error(ce.value.map((Ee) => `${Ee.key}: ${Ee.message}`).join(", "));
              te = { type: "FeatureCollection", features: te.features.filter((Ee) => ce.value.evaluate({ zoom: 0 }, Ee)) };
            }
            return te;
          });
        }
        loadGeoJSON($, W) {
          return _._(this, void 0, void 0, function* () {
            const { promoteId: te } = $;
            if ($.request) {
              const ce = yield _.h($.request, W);
              return this._dataUpdateable = $r(ce.data, te) ? qi(ce.data, te) : void 0, ce.data;
            }
            if (typeof $.data == "string") try {
              const ce = JSON.parse($.data);
              return this._dataUpdateable = $r(ce, te) ? qi(ce, te) : void 0, ce;
            } catch {
              throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
            }
            if (!$.dataDiff) throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${$.source}`);
            return function(ce, Pe, Ee) {
              var Ae, be, Ve, et;
              if (Pe.removeAll && ce.clear(), Pe.remove) for (const Re of Pe.remove) ce.delete(Re);
              if (Pe.add) for (const Re of Pe.add) {
                const mt = Et(Re, Ee);
                mt != null && ce.set(mt, Re);
              }
              if (Pe.update) for (const Re of Pe.update) {
                let mt = ce.get(Re.id);
                if (mt == null) continue;
                const Dt = !Re.removeAllProperties && (((Ae = Re.removeProperties) === null || Ae === void 0 ? void 0 : Ae.length) > 0 || ((be = Re.addOrUpdateProperties) === null || be === void 0 ? void 0 : be.length) > 0);
                if ((Re.newGeometry || Re.removeAllProperties || Dt) && (mt = Object.assign({}, mt), ce.set(Re.id, mt), Dt && (mt.properties = Object.assign({}, mt.properties))), Re.newGeometry && (mt.geometry = Re.newGeometry), Re.removeAllProperties) mt.properties = {};
                else if (((Ve = Re.removeProperties) === null || Ve === void 0 ? void 0 : Ve.length) > 0) for (const Zt of Re.removeProperties) Object.prototype.hasOwnProperty.call(mt.properties, Zt) && delete mt.properties[Zt];
                if (((et = Re.addOrUpdateProperties) === null || et === void 0 ? void 0 : et.length) > 0) for (const { key: Zt, value: vi } of Re.addOrUpdateProperties) mt.properties[Zt] = vi;
              }
            }(this._dataUpdateable, $.dataDiff, te), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource($) {
          return _._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom($) {
          return this._geoJSONIndex.getClusterExpansionZoom($.clusterId);
        }
        getClusterChildren($) {
          return this._geoJSONIndex.getChildren($.clusterId);
        }
        getClusterLeaves($) {
          return this._geoJSONIndex.getLeaves($.clusterId, $.limit, $.offset);
        }
      }
      class Er {
        constructor($) {
          this.self = $, this.actor = new _.F($), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (W, te) => {
            if (this.externalWorkerSourceTypes[W]) throw new Error(`Worker source with name "${W}" already registered.`);
            this.externalWorkerSourceTypes[W] = te;
          }, this.self.addProtocol = _.bi, this.self.removeProtocol = _.bj, this.self.registerRTLTextPlugin = (W) => {
            if (_.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            _.bD.setMethods(W);
          }, this.actor.registerMessageHandler("LDT", (W, te) => this._getDEMWorkerSource(W, te.source).loadTile(te)), this.actor.registerMessageHandler("RDT", (W, te) => _._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(W, te.source).removeTile(te);
          })), this.actor.registerMessageHandler("GCEZ", (W, te) => _._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, te.type, te.source).getClusterExpansionZoom(te);
          })), this.actor.registerMessageHandler("GCC", (W, te) => _._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, te.type, te.source).getClusterChildren(te);
          })), this.actor.registerMessageHandler("GCL", (W, te) => _._(this, void 0, void 0, function* () {
            return this._getWorkerSource(W, te.type, te.source).getClusterLeaves(te);
          })), this.actor.registerMessageHandler("LD", (W, te) => this._getWorkerSource(W, te.type, te.source).loadData(te)), this.actor.registerMessageHandler("GD", (W, te) => this._getWorkerSource(W, te.type, te.source).getData()), this.actor.registerMessageHandler("LT", (W, te) => this._getWorkerSource(W, te.type, te.source).loadTile(te)), this.actor.registerMessageHandler("RT", (W, te) => this._getWorkerSource(W, te.type, te.source).reloadTile(te)), this.actor.registerMessageHandler("AT", (W, te) => this._getWorkerSource(W, te.type, te.source).abortTile(te)), this.actor.registerMessageHandler("RMT", (W, te) => this._getWorkerSource(W, te.type, te.source).removeTile(te)), this.actor.registerMessageHandler("RS", (W, te) => _._(this, void 0, void 0, function* () {
            if (!this.workerSources[W] || !this.workerSources[W][te.type] || !this.workerSources[W][te.type][te.source]) return;
            const ce = this.workerSources[W][te.type][te.source];
            delete this.workerSources[W][te.type][te.source], ce.removeSource !== void 0 && ce.removeSource(te);
          })), this.actor.registerMessageHandler("RM", (W) => _._(this, void 0, void 0, function* () {
            delete this.layerIndexes[W], delete this.availableImages[W], delete this.workerSources[W], delete this.demWorkerSources[W];
          })), this.actor.registerMessageHandler("SR", (W, te) => _._(this, void 0, void 0, function* () {
            this.referrer = te;
          })), this.actor.registerMessageHandler("SRPS", (W, te) => this._syncRTLPluginState(W, te)), this.actor.registerMessageHandler("IS", (W, te) => _._(this, void 0, void 0, function* () {
            this.self.importScripts(te);
          })), this.actor.registerMessageHandler("SI", (W, te) => this._setImages(W, te)), this.actor.registerMessageHandler("UL", (W, te) => _._(this, void 0, void 0, function* () {
            this._getLayerIndex(W).update(te.layers, te.removedIds);
          })), this.actor.registerMessageHandler("SL", (W, te) => _._(this, void 0, void 0, function* () {
            this._getLayerIndex(W).replace(te);
          }));
        }
        _setImages($, W) {
          return _._(this, void 0, void 0, function* () {
            this.availableImages[$] = W;
            for (const te in this.workerSources[$]) {
              const ce = this.workerSources[$][te];
              for (const Pe in ce) ce[Pe].availableImages = W;
            }
          });
        }
        _syncRTLPluginState($, W) {
          return _._(this, void 0, void 0, function* () {
            if (_.bD.isParsed()) return _.bD.getState();
            if (W.pluginStatus !== "loading") return _.bD.setState(W), W;
            const te = W.pluginURL;
            if (this.self.importScripts(te), _.bD.isParsed()) {
              const ce = { pluginStatus: "loaded", pluginURL: te };
              return _.bD.setState(ce), ce;
            }
            throw _.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${te}`);
          });
        }
        _getAvailableImages($) {
          let W = this.availableImages[$];
          return W || (W = []), W;
        }
        _getLayerIndex($) {
          let W = this.layerIndexes[$];
          return W || (W = this.layerIndexes[$] = new c()), W;
        }
        _getWorkerSource($, W, te) {
          if (this.workerSources[$] || (this.workerSources[$] = {}), this.workerSources[$][W] || (this.workerSources[$][W] = {}), !this.workerSources[$][W][te]) {
            const ce = { sendAsync: (Pe, Ee) => (Pe.targetMapId = $, this.actor.sendAsync(Pe, Ee)) };
            switch (W) {
              case "vector":
                this.workerSources[$][W][te] = new j(ce, this._getLayerIndex($), this._getAvailableImages($));
                break;
              case "geojson":
                this.workerSources[$][W][te] = new Cr(ce, this._getLayerIndex($), this._getAvailableImages($));
                break;
              default:
                this.workerSources[$][W][te] = new this.externalWorkerSourceTypes[W](ce, this._getLayerIndex($), this._getAvailableImages($));
            }
          }
          return this.workerSources[$][W][te];
        }
        _getDEMWorkerSource($, W) {
          return this.demWorkerSources[$] || (this.demWorkerSources[$] = {}), this.demWorkerSources[$][W] || (this.demWorkerSources[$][W] = new V()), this.demWorkerSources[$][W];
        }
      }
      return _.i(self) && (self.worker = new Er(self)), Er;
    }), S("index", ["exports", "./shared"], function(_, c) {
      var C = "4.7.1";
      let N, q;
      const j = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (a) => new Promise((e, r) => {
        const s = requestAnimationFrame(e);
        a.signal.addEventListener("abort", () => {
          cancelAnimationFrame(s), r(c.c());
        });
      }), getImageData(a, e = 0) {
        return this.getImageCanvasContext(a).getImageData(-e, -e, a.width + 2 * e, a.height + 2 * e);
      }, getImageCanvasContext(a) {
        const e = window.document.createElement("canvas"), r = e.getContext("2d", { willReadFrequently: !0 });
        if (!r) throw new Error("failed to create canvas 2d context");
        return e.width = a.width, e.height = a.height, r.drawImage(a, 0, 0, a.width, a.height), r;
      }, resolveURL: (a) => (N || (N = document.createElement("a")), N.href = a, N.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (q == null && (q = matchMedia("(prefers-reduced-motion: reduce)")), q.matches);
      } };
      class V {
        static testProp(e) {
          if (!V.docStyle) return e[0];
          for (let r = 0; r < e.length; r++) if (e[r] in V.docStyle) return e[r];
          return e[0];
        }
        static create(e, r, s) {
          const l = window.document.createElement(e);
          return r !== void 0 && (l.className = r), s && s.appendChild(l), l;
        }
        static createNS(e, r) {
          return window.document.createElementNS(e, r);
        }
        static disableDrag() {
          V.docStyle && V.selectProp && (V.userSelect = V.docStyle[V.selectProp], V.docStyle[V.selectProp] = "none");
        }
        static enableDrag() {
          V.docStyle && V.selectProp && (V.docStyle[V.selectProp] = V.userSelect);
        }
        static setTransform(e, r) {
          e.style[V.transformProp] = r;
        }
        static addEventListener(e, r, s, l = {}) {
          e.addEventListener(r, s, "passive" in l ? l : l.capture);
        }
        static removeEventListener(e, r, s, l = {}) {
          e.removeEventListener(r, s, "passive" in l ? l : l.capture);
        }
        static suppressClickInternal(e) {
          e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", V.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", V.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", V.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(e) {
          const r = e.getBoundingClientRect();
          return { x: r.width / e.offsetWidth || 1, y: r.height / e.offsetHeight || 1, boundingClientRect: r };
        }
        static getPoint(e, r, s) {
          const l = r.boundingClientRect;
          return new c.P((s.clientX - l.left) / r.x - e.clientLeft, (s.clientY - l.top) / r.y - e.clientTop);
        }
        static mousePos(e, r) {
          const s = V.getScale(e);
          return V.getPoint(e, s, r);
        }
        static touchPos(e, r) {
          const s = [], l = V.getScale(e);
          for (let h = 0; h < r.length; h++) s.push(V.getPoint(e, l, r[h]));
          return s;
        }
        static mouseButton(e) {
          return e.button;
        }
        static remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
      }
      V.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, V.selectProp = V.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), V.transformProp = V.testProp(["transform", "WebkitTransform"]);
      const F = { supported: !1, testSupport: function(a) {
        !ye && ae && (se ? ge(a) : de = a);
      } };
      let de, ae, ye = !1, se = !1;
      function ge(a) {
        const e = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, e);
        try {
          if (a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, ae), a.isContextLost()) return;
          F.supported = !0;
        } catch {
        }
        a.deleteTexture(e), ye = !0;
      }
      var Me;
      typeof document < "u" && (ae = document.createElement("img"), ae.onload = () => {
        de && ge(de), de = null, se = !0;
      }, ae.onerror = () => {
        ye = !0, de = null;
      }, ae.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(a) {
        let e, r, s, l;
        a.resetRequestQueue = () => {
          e = [], r = 0, s = 0, l = {};
        }, a.addThrottleControl = (I) => {
          const k = s++;
          return l[k] = I, k;
        }, a.removeThrottleControl = (I) => {
          delete l[I], y();
        }, a.getImage = (I, k, z = !0) => new Promise((M, O) => {
          F.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), c.e(I, { type: "image" }), e.push({ abortController: k, requestParameters: I, supportImageRefresh: z, state: "queued", onError: (U) => {
            O(U);
          }, onSuccess: (U) => {
            M(U);
          } }), y();
        });
        const h = (I) => c._(this, void 0, void 0, function* () {
          I.state = "running";
          const { requestParameters: k, supportImageRefresh: z, onError: M, onSuccess: O, abortController: U } = I, B = z === !1 && !c.i(self) && !c.g(k.url) && (!k.headers || Object.keys(k.headers).reduce((ee, ne) => ee && ne === "accept", !0));
          r++;
          const G = B ? b(k, U) : c.m(k, U);
          try {
            const ee = yield G;
            delete I.abortController, I.state = "completed", ee.data instanceof HTMLImageElement || c.b(ee.data) ? O(ee) : ee.data && O({ data: yield (Q = ee.data, typeof createImageBitmap == "function" ? c.d(Q) : c.f(Q)), cacheControl: ee.cacheControl, expires: ee.expires });
          } catch (ee) {
            delete I.abortController, M(ee);
          } finally {
            r--, y();
          }
          var Q;
        }), y = () => {
          const I = (() => {
            for (const k of Object.keys(l)) if (l[k]()) return !0;
            return !1;
          })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let k = r; k < I && e.length > 0; k++) {
            const z = e.shift();
            z.abortController.signal.aborted ? k-- : h(z);
          }
        }, b = (I, k) => new Promise((z, M) => {
          const O = new Image(), U = I.url, B = I.credentials;
          B && B === "include" ? O.crossOrigin = "use-credentials" : (B && B === "same-origin" || !c.s(U)) && (O.crossOrigin = "anonymous"), k.signal.addEventListener("abort", () => {
            O.src = "", M(c.c());
          }), O.fetchPriority = "high", O.onload = () => {
            O.onerror = O.onload = null, z({ data: O });
          }, O.onerror = () => {
            O.onerror = O.onload = null, k.signal.aborted || M(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, O.src = U;
        });
      }(Me || (Me = {})), Me.resetRequestQueue();
      class Ye {
        constructor(e) {
          this._transformRequestFn = e;
        }
        transformRequest(e, r) {
          return this._transformRequestFn && this._transformRequestFn(e, r) || { url: e };
        }
        setTransformRequest(e) {
          this._transformRequestFn = e;
        }
      }
      function $e(a) {
        var e = new c.A(3);
        return e[0] = a[0], e[1] = a[1], e[2] = a[2], e;
      }
      var tt, Be = function(a, e, r) {
        return a[0] = e[0] - r[0], a[1] = e[1] - r[1], a[2] = e[2] - r[2], a;
      };
      tt = new c.A(3), c.A != Float32Array && (tt[0] = 0, tt[1] = 0, tt[2] = 0);
      var Ie = function(a) {
        var e = a[0], r = a[1];
        return e * e + r * r;
      };
      function ot(a) {
        const e = [];
        if (typeof a == "string") e.push({ id: "default", url: a });
        else if (a && a.length > 0) {
          const r = [];
          for (const { id: s, url: l } of a) {
            const h = `${s}${l}`;
            r.indexOf(h) === -1 && (r.push(h), e.push({ id: s, url: l }));
          }
        }
        return e;
      }
      function it(a, e, r) {
        const s = a.split("?");
        return s[0] += `${e}${r}`, s.join("?");
      }
      (function() {
        var a = new c.A(2);
        c.A != Float32Array && (a[0] = 0, a[1] = 0);
      })();
      class oe {
        constructor(e, r, s, l) {
          this.context = e, this.format = s, this.texture = e.gl.createTexture(), this.update(r, l);
        }
        update(e, r, s) {
          const { width: l, height: h } = e, y = !(this.size && this.size[0] === l && this.size[1] === h || s), { context: b } = this, { gl: I } = b;
          if (this.useMipmap = !!(r && r.useMipmap), I.bindTexture(I.TEXTURE_2D, this.texture), b.pixelStoreUnpackFlipY.set(!1), b.pixelStoreUnpack.set(1), b.pixelStoreUnpackPremultiplyAlpha.set(this.format === I.RGBA && (!r || r.premultiply !== !1)), y) this.size = [l, h], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? I.texImage2D(I.TEXTURE_2D, 0, this.format, this.format, I.UNSIGNED_BYTE, e) : I.texImage2D(I.TEXTURE_2D, 0, this.format, l, h, 0, this.format, I.UNSIGNED_BYTE, e.data);
          else {
            const { x: k, y: z } = s || { x: 0, y: 0 };
            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? I.texSubImage2D(I.TEXTURE_2D, 0, k, z, I.RGBA, I.UNSIGNED_BYTE, e) : I.texSubImage2D(I.TEXTURE_2D, 0, k, z, l, h, I.RGBA, I.UNSIGNED_BYTE, e.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && I.generateMipmap(I.TEXTURE_2D);
        }
        bind(e, r, s) {
          const { context: l } = this, { gl: h } = l;
          h.bindTexture(h.TEXTURE_2D, this.texture), s !== h.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (s = h.LINEAR), e !== this.filter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, s || e), this.filter = e), r !== this.wrap && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, r), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, r), this.wrap = r);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      function le(a) {
        const { userImage: e } = a;
        return !!(e && e.render && e.render()) && (a.data.replace(new Uint8Array(e.data.buffer)), !0);
      }
      class Le extends c.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e) {
          if (this.loaded !== e && (this.loaded = e, e)) {
            for (const { ids: r, promiseResolve: s } of this.requestors) s(this._getImagesForIds(r));
            this.requestors = [];
          }
        }
        getImage(e) {
          const r = this.images[e];
          if (r && !r.data && r.spriteData) {
            const s = r.spriteData;
            r.data = new c.R({ width: s.width, height: s.height }, s.context.getImageData(s.x, s.y, s.width, s.height).data), r.spriteData = null;
          }
          return r;
        }
        addImage(e, r) {
          if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
          this._validate(e, r) && (this.images[e] = r);
        }
        _validate(e, r) {
          let s = !0;
          const l = r.data || r.spriteData;
          return this._validateStretch(r.stretchX, l && l.width) || (this.fire(new c.j(new Error(`Image "${e}" has invalid "stretchX" value`))), s = !1), this._validateStretch(r.stretchY, l && l.height) || (this.fire(new c.j(new Error(`Image "${e}" has invalid "stretchY" value`))), s = !1), this._validateContent(r.content, r) || (this.fire(new c.j(new Error(`Image "${e}" has invalid "content" value`))), s = !1), s;
        }
        _validateStretch(e, r) {
          if (!e) return !0;
          let s = 0;
          for (const l of e) {
            if (l[0] < s || l[1] < l[0] || r < l[1]) return !1;
            s = l[1];
          }
          return !0;
        }
        _validateContent(e, r) {
          if (!e) return !0;
          if (e.length !== 4) return !1;
          const s = r.spriteData, l = s && s.width || r.data.width, h = s && s.height || r.data.height;
          return !(e[0] < 0 || l < e[0] || e[1] < 0 || h < e[1] || e[2] < 0 || l < e[2] || e[3] < 0 || h < e[3] || e[2] < e[0] || e[3] < e[1]);
        }
        updateImage(e, r, s = !0) {
          const l = this.getImage(e);
          if (s && (l.data.width !== r.data.width || l.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${l.data.width}x${l.data.height}) and new image (${r.data.width}x${r.data.height}).`);
          r.version = l.version + 1, this.images[e] = r, this.updatedImages[e] = !0;
        }
        removeImage(e) {
          const r = this.images[e];
          delete this.images[e], delete this.patterns[e], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e) {
          return new Promise((r, s) => {
            let l = !0;
            if (!this.isLoaded()) for (const h of e) this.images[h] || (l = !1);
            this.isLoaded() || l ? r(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: r });
          });
        }
        _getImagesForIds(e) {
          const r = {};
          for (const s of e) {
            let l = this.getImage(s);
            l || (this.fire(new c.k("styleimagemissing", { id: s })), l = this.getImage(s)), l ? r[s] = { data: l.data.clone(), pixelRatio: l.pixelRatio, sdf: l.sdf, version: l.version, stretchX: l.stretchX, stretchY: l.stretchY, content: l.content, textFitWidth: l.textFitWidth, textFitHeight: l.textFitHeight, hasRenderCallback: !!(l.userImage && l.userImage.render) } : c.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return r;
        }
        getPixelSize() {
          const { width: e, height: r } = this.atlasImage;
          return { width: e, height: r };
        }
        getPattern(e) {
          const r = this.patterns[e], s = this.getImage(e);
          if (!s) return null;
          if (r && r.position.version === s.version) return r.position;
          if (r) r.position.version = s.version;
          else {
            const l = { w: s.data.width + 2, h: s.data.height + 2, x: 0, y: 0 }, h = new c.I(l, s);
            this.patterns[e] = { bin: l, position: h };
          }
          return this._updatePatternAtlas(), this.patterns[e].position;
        }
        bind(e) {
          const r = e.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new oe(e, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const e = [];
          for (const h in this.patterns) e.push(this.patterns[h].bin);
          const { w: r, h: s } = c.p(e), l = this.atlasImage;
          l.resize({ width: r || 1, height: s || 1 });
          for (const h in this.patterns) {
            const { bin: y } = this.patterns[h], b = y.x + 1, I = y.y + 1, k = this.getImage(h).data, z = k.width, M = k.height;
            c.R.copy(k, l, { x: 0, y: 0 }, { x: b, y: I }, { width: z, height: M }), c.R.copy(k, l, { x: 0, y: M - 1 }, { x: b, y: I - 1 }, { width: z, height: 1 }), c.R.copy(k, l, { x: 0, y: 0 }, { x: b, y: I + M }, { width: z, height: 1 }), c.R.copy(k, l, { x: z - 1, y: 0 }, { x: b - 1, y: I }, { width: 1, height: M }), c.R.copy(k, l, { x: 0, y: 0 }, { x: b + z, y: I }, { width: 1, height: M });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e) {
          for (const r of e) {
            if (this.callbackDispatchedThisFrame[r]) continue;
            this.callbackDispatchedThisFrame[r] = !0;
            const s = this.getImage(r);
            s || c.w(`Image with ID: "${r}" was not found`), le(s) && this.updateImage(r, s);
          }
        }
      }
      const Se = 1e20;
      function He(a, e, r, s, l, h, y, b, I) {
        for (let k = e; k < e + s; k++) We(a, r * h + k, h, l, y, b, I);
        for (let k = r; k < r + l; k++) We(a, k * h + e, 1, s, y, b, I);
      }
      function We(a, e, r, s, l, h, y) {
        h[0] = 0, y[0] = -Se, y[1] = Se, l[0] = a[e];
        for (let b = 1, I = 0, k = 0; b < s; b++) {
          l[b] = a[e + b * r];
          const z = b * b;
          do {
            const M = h[I];
            k = (l[b] - l[M] + z - M * M) / (b - M) / 2;
          } while (k <= y[I] && --I > -1);
          I++, h[I] = b, y[I] = k, y[I + 1] = Se;
        }
        for (let b = 0, I = 0; b < s; b++) {
          for (; y[I + 1] < b; ) I++;
          const k = h[I], z = b - k;
          a[e + b * r] = l[k] + z * z;
        }
      }
      class Je {
        constructor(e, r) {
          this.requestManager = e, this.localIdeographFontFamily = r, this.entries = {};
        }
        setURL(e) {
          this.url = e;
        }
        getGlyphs(e) {
          return c._(this, void 0, void 0, function* () {
            const r = [];
            for (const h in e) for (const y of e[h]) r.push(this._getAndCacheGlyphsPromise(h, y));
            const s = yield Promise.all(r), l = {};
            for (const { stack: h, id: y, glyph: b } of s) l[h] || (l[h] = {}), l[h][y] = b && { id: b.id, bitmap: b.bitmap.clone(), metrics: b.metrics };
            return l;
          });
        }
        _getAndCacheGlyphsPromise(e, r) {
          return c._(this, void 0, void 0, function* () {
            let s = this.entries[e];
            s || (s = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
            let l = s.glyphs[r];
            if (l !== void 0) return { stack: e, id: r, glyph: l };
            if (l = this._tinySDF(s, e, r), l) return s.glyphs[r] = l, { stack: e, id: r, glyph: l };
            const h = Math.floor(r / 256);
            if (256 * h > 65535) throw new Error("glyphs > 65535 not supported");
            if (s.ranges[h]) return { stack: e, id: r, glyph: l };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!s.requests[h]) {
              const b = Je.loadGlyphRange(e, h, this.url, this.requestManager);
              s.requests[h] = b;
            }
            const y = yield s.requests[h];
            for (const b in y) this._doesCharSupportLocalGlyph(+b) || (s.glyphs[+b] = y[+b]);
            return s.ranges[h] = !0, { stack: e, id: r, glyph: y[r] || null };
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e));
        }
        _tinySDF(e, r, s) {
          const l = this.localIdeographFontFamily;
          if (!l || !this._doesCharSupportLocalGlyph(s)) return;
          let h = e.tinySDF;
          if (!h) {
            let b = "400";
            /bold/i.test(r) ? b = "900" : /medium/i.test(r) ? b = "500" : /light/i.test(r) && (b = "200"), h = e.tinySDF = new Je.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: l, fontWeight: b });
          }
          const y = h.draw(String.fromCharCode(s));
          return { id: s, bitmap: new c.o({ width: y.width || 60, height: y.height || 60 }, y.data), metrics: { width: y.glyphWidth / 2 || 24, height: y.glyphHeight / 2 || 24, left: y.glyphLeft / 2 + 0.5 || 0, top: y.glyphTop / 2 - 27.5 || -8, advance: y.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Je.loadGlyphRange = function(a, e, r, s) {
        return c._(this, void 0, void 0, function* () {
          const l = 256 * e, h = l + 255, y = s.transformRequest(r.replace("{fontstack}", a).replace("{range}", `${l}-${h}`), "Glyphs"), b = yield c.l(y, new AbortController());
          if (!b || !b.data) throw new Error(`Could not load glyph range. range: ${e}, ${l}-${h}`);
          const I = {};
          for (const k of c.n(b.data)) I[k.id] = k;
          return I;
        });
      }, Je.TinySDF = class {
        constructor({ fontSize: a = 24, buffer: e = 3, radius: r = 8, cutoff: s = 0.25, fontFamily: l = "sans-serif", fontWeight: h = "normal", fontStyle: y = "normal" } = {}) {
          this.buffer = e, this.cutoff = s, this.radius = r;
          const b = this.size = a + 4 * e, I = this._createCanvas(b), k = this.ctx = I.getContext("2d", { willReadFrequently: !0 });
          k.font = `${y} ${h} ${a}px ${l}`, k.textBaseline = "alphabetic", k.textAlign = "left", k.fillStyle = "black", this.gridOuter = new Float64Array(b * b), this.gridInner = new Float64Array(b * b), this.f = new Float64Array(b), this.z = new Float64Array(b + 1), this.v = new Uint16Array(b);
        }
        _createCanvas(a) {
          const e = document.createElement("canvas");
          return e.width = e.height = a, e;
        }
        draw(a) {
          const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: s, actualBoundingBoxLeft: l, actualBoundingBoxRight: h } = this.ctx.measureText(a), y = Math.ceil(r), b = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(h - l))), I = Math.min(this.size - this.buffer, y + Math.ceil(s)), k = b + 2 * this.buffer, z = I + 2 * this.buffer, M = Math.max(k * z, 0), O = new Uint8ClampedArray(M), U = { data: O, width: k, height: z, glyphWidth: b, glyphHeight: I, glyphTop: y, glyphLeft: 0, glyphAdvance: e };
          if (b === 0 || I === 0) return U;
          const { ctx: B, buffer: G, gridInner: Q, gridOuter: ee } = this;
          B.clearRect(G, G, b, I), B.fillText(a, G, G + y);
          const ne = B.getImageData(G, G, b, I);
          ee.fill(Se, 0, M), Q.fill(0, 0, M);
          for (let ie = 0; ie < I; ie++) for (let he = 0; he < b; he++) {
            const we = ne.data[4 * (ie * b + he) + 3] / 255;
            if (we === 0) continue;
            const ve = (ie + G) * k + he + G;
            if (we === 1) ee[ve] = 0, Q[ve] = Se;
            else {
              const Ue = 0.5 - we;
              ee[ve] = Ue > 0 ? Ue * Ue : 0, Q[ve] = Ue < 0 ? Ue * Ue : 0;
            }
          }
          He(ee, 0, 0, k, z, k, this.f, this.v, this.z), He(Q, G, G, b, I, k, this.f, this.v, this.z);
          for (let ie = 0; ie < M; ie++) {
            const he = Math.sqrt(ee[ie]) - Math.sqrt(Q[ie]);
            O[ie] = Math.round(255 - 255 * (he / this.radius + this.cutoff));
          }
          return U;
        }
      };
      class je {
        constructor() {
          this.specification = c.v.light.position;
        }
        possiblyEvaluate(e, r) {
          return c.x(e.expression.evaluate(r));
        }
        interpolate(e, r, s) {
          return { x: c.y.number(e.x, r.x, s), y: c.y.number(e.y, r.y, s), z: c.y.number(e.z, r.z, s) };
        }
      }
      let rt;
      class Ke extends c.E {
        constructor(e) {
          super(), rt = rt || new c.q({ anchor: new c.D(c.v.light.anchor), position: new je(), color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(rt), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e, r = {}) {
          if (!this._validate(c.r, e, r)) for (const s in e) {
            const l = e[s];
            s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), l) : this._transitionable.setValue(s, l);
          }
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, s) {
          return (!s || s.validate !== !1) && c.t(this, e.call(c.u, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }));
        }
      }
      const St = new c.q({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) });
      class J extends c.E {
        constructor(e) {
          super(), this._transitionable = new c.T(St), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.z(0));
        }
        setSky(e, r = {}) {
          if (!this._validate(c.B, e, r)) {
            e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const s in e) {
              const l = e[s];
              s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), l) : this._transitionable.setValue(s, l);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        _validate(e, r, s = {}) {
          return (s == null ? void 0 : s.validate) !== !1 && c.t(this, e.call(c.u, c.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })));
        }
        calculateFogBlendOpacity(e) {
          return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
        }
      }
      class fe {
        constructor(e, r) {
          this.width = e, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(e, r) {
          const s = e.join(",") + String(r);
          return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(e, r)), this.dashEntry[s];
        }
        getDashRanges(e, r, s) {
          const l = [];
          let h = e.length % 2 == 1 ? -e[e.length - 1] * s : 0, y = e[0] * s, b = !0;
          l.push({ left: h, right: y, isDash: b, zeroLength: e[0] === 0 });
          let I = e[0];
          for (let k = 1; k < e.length; k++) {
            b = !b;
            const z = e[k];
            h = I * s, I += z, y = I * s, l.push({ left: h, right: y, isDash: b, zeroLength: z === 0 });
          }
          return l;
        }
        addRoundDash(e, r, s) {
          const l = r / 2;
          for (let h = -s; h <= s; h++) {
            const y = this.width * (this.nextRow + s + h);
            let b = 0, I = e[b];
            for (let k = 0; k < this.width; k++) {
              k / I.right > 1 && (I = e[++b]);
              const z = Math.abs(k - I.left), M = Math.abs(k - I.right), O = Math.min(z, M);
              let U;
              const B = h / s * (l + 1);
              if (I.isDash) {
                const G = l - Math.abs(B);
                U = Math.sqrt(O * O + G * G);
              } else U = l - Math.sqrt(O * O + B * B);
              this.data[y + k] = Math.max(0, Math.min(255, U + 128));
            }
          }
        }
        addRegularDash(e) {
          for (let b = e.length - 1; b >= 0; --b) {
            const I = e[b], k = e[b + 1];
            I.zeroLength ? e.splice(b, 1) : k && k.isDash === I.isDash && (k.left = I.left, e.splice(b, 1));
          }
          const r = e[0], s = e[e.length - 1];
          r.isDash === s.isDash && (r.left = s.left - this.width, s.right = r.right + this.width);
          const l = this.width * this.nextRow;
          let h = 0, y = e[h];
          for (let b = 0; b < this.width; b++) {
            b / y.right > 1 && (y = e[++h]);
            const I = Math.abs(b - y.left), k = Math.abs(b - y.right), z = Math.min(I, k);
            this.data[l + b] = Math.max(0, Math.min(255, (y.isDash ? z : -z) + 128));
          }
        }
        addDash(e, r) {
          const s = r ? 7 : 0, l = 2 * s + 1;
          if (this.nextRow + l > this.height) return c.w("LineAtlas out of space"), null;
          let h = 0;
          for (let b = 0; b < e.length; b++) h += e[b];
          if (h !== 0) {
            const b = this.width / h, I = this.getDashRanges(e, this.width, b);
            r ? this.addRoundDash(I, b, s) : this.addRegularDash(I);
          }
          const y = { y: (this.nextRow + s + 0.5) / this.height, height: 2 * s / this.height, width: h };
          return this.nextRow += l, this.dirty = !0, y;
        }
        bind(e) {
          const r = e.gl;
          this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
        }
      }
      const _e = "maplibre_preloaded_worker_pool";
      class Ce {
        constructor() {
          this.active = {};
        }
        acquire(e) {
          if (!this.workers) for (this.workers = []; this.workers.length < Ce.workerCount; ) this.workers.push(new Worker(c.a.WORKER_URL));
          return this.active[e] = !0, this.workers.slice();
        }
        release(e) {
          delete this.active[e], this.numActive() === 0 && (this.workers.forEach((r) => {
            r.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[_e];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const De = Math.floor(j.hardwareConcurrency / 2);
      let Oe, qe;
      function Ze() {
        return Oe || (Oe = new Ce()), Oe;
      }
      Ce.workerCount = c.C(globalThis) ? Math.max(Math.min(De, 3), 1) : 1;
      class wt {
        constructor(e, r) {
          this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = r;
          const s = this.workerPool.acquire(r);
          for (let l = 0; l < s.length; l++) {
            const h = new c.F(s[l], r);
            h.name = `Worker ${l}`, this.actors.push(h);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(e, r) {
          const s = [];
          for (const l of this.actors) s.push(l.sendAsync({ type: e, data: r }));
          return Promise.all(s);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(e = !0) {
          this.actors.forEach((r) => {
            r.remove();
          }), this.actors = [], e && this.workerPool.release(this.id);
        }
        registerMessageHandler(e, r) {
          for (const s of this.actors) s.registerMessageHandler(e, r);
        }
      }
      function bt() {
        return qe || (qe = new wt(Ze(), c.G), qe.registerMessageHandler("GR", (a, e, r) => c.m(e, r))), qe;
      }
      function Tt(a, e) {
        const r = c.H();
        return c.J(r, r, [1, 1, 0]), c.K(r, r, [0.5 * a.width, 0.5 * a.height, 1]), c.L(r, r, a.calculatePosMatrix(e.toUnwrapped()));
      }
      function Mt(a, e, r, s, l, h) {
        const y = function(M, O, U) {
          if (M) for (const B of M) {
            const G = O[B];
            if (G && G.source === U && G.type === "fill-extrusion") return !0;
          }
          else for (const B in O) {
            const G = O[B];
            if (G.source === U && G.type === "fill-extrusion") return !0;
          }
          return !1;
        }(l && l.layers, e, a.id), b = h.maxPitchScaleFactor(), I = a.tilesIn(s, b, y);
        I.sort(Qt);
        const k = [];
        for (const M of I) k.push({ wrappedTileID: M.tileID.wrapped().key, queryResults: M.tile.queryRenderedFeatures(e, r, a._state, M.queryGeometry, M.cameraQueryGeometry, M.scale, l, h, b, Tt(a.transform, M.tileID)) });
        const z = function(M) {
          const O = {}, U = {};
          for (const B of M) {
            const G = B.queryResults, Q = B.wrappedTileID, ee = U[Q] = U[Q] || {};
            for (const ne in G) {
              const ie = G[ne], he = ee[ne] = ee[ne] || {}, we = O[ne] = O[ne] || [];
              for (const ve of ie) he[ve.featureIndex] || (he[ve.featureIndex] = !0, we.push(ve));
            }
          }
          return O;
        }(k);
        for (const M in z) z[M].forEach((O) => {
          const U = O.feature, B = a.getFeatureState(U.layer["source-layer"], U.id);
          U.source = U.layer.source, U.layer["source-layer"] && (U.sourceLayer = U.layer["source-layer"]), U.state = B;
        });
        return z;
      }
      function Qt(a, e) {
        const r = a.tileID, s = e.tileID;
        return r.overscaledZ - s.overscaledZ || r.canonical.y - s.canonical.y || r.wrap - s.wrap || r.canonical.x - s.canonical.x;
      }
      function Qe(a, e, r) {
        return c._(this, void 0, void 0, function* () {
          let s = a;
          if (a.url ? s = (yield c.h(e.transformRequest(a.url, "Source"), r)).data : yield j.frameAsync(r), !s) return null;
          const l = c.M(c.e(s, a), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in s && s.vector_layers && (l.vectorLayerIds = s.vector_layers.map((h) => h.id)), l;
        });
      }
      class Y {
        constructor(e, r) {
          e && (r ? this.setSouthWest(e).setNorthEast(r) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
        }
        setNorthEast(e) {
          return this._ne = e instanceof c.N ? new c.N(e.lng, e.lat) : c.N.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof c.N ? new c.N(e.lng, e.lat) : c.N.convert(e), this;
        }
        extend(e) {
          const r = this._sw, s = this._ne;
          let l, h;
          if (e instanceof c.N) l = e, h = e;
          else {
            if (!(e instanceof Y)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Y.convert(e)) : this.extend(c.N.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(c.N.convert(e)) : this;
            if (l = e._sw, h = e._ne, !l || !h) return this;
          }
          return r || s ? (r.lng = Math.min(l.lng, r.lng), r.lat = Math.min(l.lat, r.lat), s.lng = Math.max(h.lng, s.lng), s.lat = Math.max(h.lat, s.lat)) : (this._sw = new c.N(l.lng, l.lat), this._ne = new c.N(h.lng, h.lat)), this;
        }
        getCenter() {
          return new c.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new c.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new c.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: r, lat: s } = c.N.convert(e);
          let l = this._sw.lng <= r && r <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (l = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && l;
        }
        static convert(e) {
          return e instanceof Y ? e : e && new Y(e);
        }
        static fromLngLat(e, r = 0) {
          const s = 360 * r / 40075017, l = s / Math.cos(Math.PI / 180 * e.lat);
          return new Y(new c.N(e.lng - l, e.lat - s), new c.N(e.lng + l, e.lat + s));
        }
        adjustAntiMeridian() {
          const e = new c.N(this._sw.lng, this._sw.lat), r = new c.N(this._ne.lng, this._ne.lat);
          return new Y(e, e.lng > r.lng ? new c.N(r.lng + 360, r.lat) : r);
        }
      }
      class ui {
        constructor(e, r, s) {
          this.bounds = Y.convert(this.validateBounds(e)), this.minzoom = r || 0, this.maxzoom = s || 24;
        }
        validateBounds(e) {
          return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
        }
        contains(e) {
          const r = Math.pow(2, e.z), s = Math.floor(c.O(this.bounds.getWest()) * r), l = Math.floor(c.Q(this.bounds.getNorth()) * r), h = Math.ceil(c.O(this.bounds.getEast()) * r), y = Math.ceil(c.Q(this.bounds.getSouth()) * r);
          return e.x >= s && e.x < h && e.y >= l && e.y < y;
        }
      }
      class $t extends c.E {
        constructor(e, r, s, l) {
          if (super(), this.id = e, this.dispatcher = s, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.M(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(l);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield Qe(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (c.e(this, e), e.bounds && (this.tileBounds = new ui(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new c.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setSourceProperty(e) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return c.e({}, this._options);
        }
        loadTile(e) {
          return c._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            s.request.collectResourceTiming = this._collectResourceTiming;
            let l = "RT";
            if (e.actor && e.state !== "expired") {
              if (e.state === "loading") return new Promise((h, y) => {
                e.reloadPromise = { resolve: h, reject: y };
              });
            } else e.actor = this.dispatcher.getActor(), l = "LT";
            e.abortController = new AbortController();
            try {
              const h = yield e.actor.sendAsync({ type: l, data: s }, e.abortController);
              if (delete e.abortController, e.aborted) return;
              this._afterTileLoadWorkerResponse(e, h);
            } catch (h) {
              if (delete e.abortController, e.aborted) return;
              if (h && h.status !== 404) throw h;
              this._afterTileLoadWorkerResponse(e, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(e, r) {
          if (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), e.reloadPromise) {
            const s = e.reloadPromise;
            e.reloadPromise = null, this.loadTile(e).then(s.resolve).catch(s.reject);
          }
        }
        abortTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class at extends c.E {
        constructor(e, r, s, l) {
          super(), this.id = e, this.dispatcher = s, this.setEventedParent(l), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, r), c.e(this, c.M(r, ["url", "scheme", "tileSize"]));
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const e = yield Qe(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, e && (c.e(this, e), e.bounds && (this.tileBounds = new ui(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (e) {
              this._tileJSONRequest = null, this.fire(new c.j(e));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(e) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load();
        }
        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }
        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }
        serialize() {
          return c.e({}, this._options);
        }
        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }
        loadTile(e) {
          return c._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e.abortController = new AbortController();
            try {
              const s = yield Me.getImage(this.map._requestManager.transformRequest(r, "Tile"), e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (s && s.data) {
                this.map._refreshExpiredTiles && s.cacheControl && s.expires && e.setExpiryData({ cacheControl: s.cacheControl, expires: s.expires });
                const l = this.map.painter.context, h = l.gl, y = s.data;
                e.texture = this.map.painter.getTileTexture(y.width), e.texture ? e.texture.update(y, { useMipmap: !0 }) : (e.texture = new oe(l, y, h.RGBA, { useMipmap: !0 }), e.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
              }
            } catch (s) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (s) throw e.state = "errored", s;
            }
          });
        }
        abortTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController);
          });
        }
        unloadTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.texture && this.map.painter.saveTileTexture(e.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class yt extends at {
        constructor(e, r, s, l) {
          super(e, r, s, l), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
        }
        loadTile(e) {
          return c._(this, void 0, void 0, function* () {
            const r = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = this.map._requestManager.transformRequest(r, "Tile");
            e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
            try {
              const l = yield Me.getImage(s, e.abortController, this.map._refreshExpiredTiles);
              if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
              if (l && l.data) {
                const h = l.data;
                this.map._refreshExpiredTiles && l.cacheControl && l.expires && e.setExpiryData({ cacheControl: l.cacheControl, expires: l.expires });
                const y = c.b(h) && c.U() ? h : yield this.readImageNow(h), b = { type: this.type, uid: e.uid, source: this.id, rawImageData: y, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!e.actor || e.state === "expired") {
                  e.actor = this.dispatcher.getActor();
                  const I = yield e.actor.sendAsync({ type: "LDT", data: b });
                  e.dem = I, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded";
                }
              }
            } catch (l) {
              if (delete e.abortController, e.aborted) e.state = "unloaded";
              else if (l) throw e.state = "errored", l;
            }
          });
        }
        readImageNow(e) {
          return c._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && c.V()) {
              const r = e.width + 2, s = e.height + 2;
              try {
                return new c.R({ width: r, height: s }, yield c.W(e, -1, -1, r, s));
              } catch {
              }
            }
            return j.getImageData(e, 1);
          });
        }
        _getNeighboringTiles(e) {
          const r = e.canonical, s = Math.pow(2, r.z), l = (r.x - 1 + s) % s, h = r.x === 0 ? e.wrap - 1 : e.wrap, y = (r.x + 1 + s) % s, b = r.x + 1 === s ? e.wrap + 1 : e.wrap, I = {};
          return I[new c.S(e.overscaledZ, h, r.z, l, r.y).key] = { backfilled: !1 }, I[new c.S(e.overscaledZ, b, r.z, y, r.y).key] = { backfilled: !1 }, r.y > 0 && (I[new c.S(e.overscaledZ, h, r.z, l, r.y - 1).key] = { backfilled: !1 }, I[new c.S(e.overscaledZ, e.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, I[new c.S(e.overscaledZ, b, r.z, y, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < s && (I[new c.S(e.overscaledZ, h, r.z, l, r.y + 1).key] = { backfilled: !1 }, I[new c.S(e.overscaledZ, e.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, I[new c.S(e.overscaledZ, b, r.z, y, r.y + 1).key] = { backfilled: !1 }), I;
        }
        unloadTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
          });
        }
      }
      class zt extends c.E {
        constructor(e, r, s, l) {
          super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = s.getActor(), this.setEventedParent(l), this._data = r.data, this._options = c.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId;
          const h = c.X / this.tileSize;
          r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (r.buffer !== void 0 ? r.buffer : 128) * h, tolerance: (r.tolerance !== void 0 ? r.tolerance : 0.375) * h, extent: c.X, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: r.clusterMaxZoom !== void 0 ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: c.X, radius: (r.clusterRadius || 50) * h, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        setData(e) {
          return this._data = e, this._updateWorkerData(), this;
        }
        updateData(e) {
          return this._updateWorkerData(e), this;
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            const e = c.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: e });
          });
        }
        setClusterOptions(e) {
          return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = e.clusterRadius), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterChildren(e) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
        }
        getClusterLeaves(e, r, s) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: r, offset: s } });
        }
        _updateWorkerData(e) {
          return c._(this, void 0, void 0, function* () {
            const r = c.e({ type: this.type }, this.workerOptions);
            e ? r.dataDiff = e : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(j.resolveURL(this._data), "Source"), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.k("dataloading", { dataType: "source" }));
            try {
              const s = yield this.actor.sendAsync({ type: "LD", data: r });
              if (this._pendingLoads--, this._removed || s.abandoned) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              let l = null;
              s.resourceTiming && s.resourceTiming[this.id] && (l = s.resourceTiming[this.id].slice(0));
              const h = { dataType: "source" };
              this._collectResourceTiming && l && l.length > 0 && c.e(h, { resourceTiming: l }), this.fire(new c.k("data", Object.assign(Object.assign({}, h), { sourceDataType: "metadata" }))), this.fire(new c.k("data", Object.assign(Object.assign({}, h), { sourceDataType: "content" })));
            } catch (s) {
              if (this._pendingLoads--, this._removed) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              this.fire(new c.j(s));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(e) {
          return c._(this, void 0, void 0, function* () {
            const r = e.actor ? "RT" : "LT";
            e.actor = this.actor;
            const s = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            e.abortController = new AbortController();
            const l = yield this.actor.sendAsync({ type: r, data: s }, e.abortController);
            delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(l, this.map.painter, r === "RT");
          });
        }
        abortTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
          });
        }
        unloadTile(e) {
          return c._(this, void 0, void 0, function* () {
            e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return c.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var Pt = c.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class Gt extends c.E {
        constructor(e, r, s, l) {
          super(), this.id = e, this.dispatcher = s, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(l), this.options = r;
        }
        load(e) {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const r = yield Me.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, e && (this.coordinates = e), this._finishLoading());
            } catch (r) {
              this._request = null, this._loaded = !0, this.fire(new c.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e) {
          return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(e) {
          this.coordinates = e;
          const r = e.map(c.Z.fromLngLat);
          this.tileID = function(l) {
            let h = 1 / 0, y = 1 / 0, b = -1 / 0, I = -1 / 0;
            for (const O of l) h = Math.min(h, O.x), y = Math.min(y, O.y), b = Math.max(b, O.x), I = Math.max(I, O.y);
            const k = Math.max(b - h, I - y), z = Math.max(0, Math.floor(-Math.log(k) / Math.LN2)), M = Math.pow(2, z);
            return new c.a1(z, Math.floor((h + b) / 2 * M), Math.floor((y + I) / 2 * M));
          }(r), this.minzoom = this.maxzoom = this.tileID.z;
          const s = r.map((l) => this.tileID.getTilePoint(l)._round());
          return this._boundsArray = new c.$(), this._boundsArray.emplaceBack(s[0].x, s[0].y, 0, 0), this._boundsArray.emplaceBack(s[1].x, s[1].y, c.X, 0), this._boundsArray.emplaceBack(s[3].x, s[3].y, 0, c.X), this._boundsArray.emplaceBack(s[2].x, s[2].y, c.X, c.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Pt.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new oe(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let s = !1;
          for (const l in this.tiles) {
            const h = this.tiles[l];
            h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, s = !0);
          }
          s && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(e) {
          return c._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class di extends Gt {
        constructor(e, r, s, l) {
          super(e, r, s, l), this.roundZoom = !0, this.type = "video", this.options = r;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const e = this.options;
            this.urls = [];
            for (const r of e.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
            try {
              const r = yield c.a3(this.urls);
              if (this._loaded = !0, !r) return;
              this.video = r, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (r) {
              this.fire(new c.j(r));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e) {
          if (this.video) {
            const r = this.video.seekable;
            e < r.start(0) || e > r.end(0) ? this.fire(new c.j(new c.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = e;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e) {
          this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const e = this.map.painter.context, r = e.gl;
          this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, Pt.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new oe(e, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let s = !1;
          for (const l in this.tiles) {
            const h = this.tiles[l];
            h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, s = !0);
          }
          s && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class oi extends Gt {
        constructor(e, r, s, l) {
          super(e, r, s, l), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((h) => !Array.isArray(h) || h.length !== 2 || h.some((y) => typeof y != "number")) || this.fire(new c.j(new c.a2(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.j(new c.a2(`sources.${e}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new c.j(new c.a2(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new c.j(new c.a2(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.j(new c.a2(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e) {
          this.map = e, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const r = this.map.painter.context, s = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, Pt.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new oe(r, this.canvas, s.RGBA, { premultiply: !0 });
          let l = !1;
          for (const h in this.tiles) {
            const y = this.tiles[h];
            y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, l = !0);
          }
          l && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
          return !1;
        }
      }
      const bi = {}, Ci = (a) => {
        switch (a) {
          case "geojson":
            return zt;
          case "image":
            return Gt;
          case "raster":
            return at;
          case "raster-dem":
            return yt;
          case "vector":
            return $t;
          case "video":
            return di;
          case "canvas":
            return oi;
        }
        return bi[a];
      }, lt = "RTLPluginLoaded";
      class ei extends c.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = bt();
        }
        _syncState(e) {
          return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((r) => {
            throw this.status = "error", r;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(e) {
          return c._(this, arguments, void 0, function* (r, s = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = j.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
            if (this.status === "unavailable") {
              if (!s) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return c._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new c.k(lt));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let ai = null;
      function It() {
        return ai || (ai = new ei()), ai;
      }
      class cr {
        constructor(e, r) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = c.a4(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(e) {
          const r = e + this.timeAdded;
          r < this.fadeEndTime || (this.fadeEndTime = r);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(e) {
          this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e, r, s) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
            e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(l, h) {
              const y = {};
              if (!h) return y;
              for (const b of l) {
                const I = b.layerIds.map((k) => h.getLayer(k)).filter(Boolean);
                if (I.length !== 0) {
                  b.layers = I, b.stateDependentLayerIds && (b.stateDependentLayers = b.stateDependentLayerIds.map((k) => I.filter((z) => z.id === k)[0]));
                  for (const k of I) y[k.id] = b;
                }
              }
              return y;
            }(e.buckets, r.style), this.hasSymbolBuckets = !1;
            for (const l in this.buckets) {
              const h = this.buckets[l];
              if (h instanceof c.a6) {
                if (this.hasSymbolBuckets = !0, !s) break;
                h.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const l in this.buckets) {
              const h = this.buckets[l];
              if (h instanceof c.a6 && h.hasRTLText) {
                this.hasRTLText = !0, It().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const l in this.buckets) {
              const h = this.buckets[l];
              this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(l).queryRadius(h));
            }
            e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
          } else this.collisionBoxArray = new c.a5();
        }
        unloadVectorData() {
          for (const e in this.buckets) this.buckets[e].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(e) {
          return this.buckets[e.id];
        }
        upload(e) {
          for (const s in this.buckets) {
            const l = this.buckets[s];
            l.uploadPending() && l.upload(e);
          }
          const r = e.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new oe(e, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new oe(e, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(e) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e, r, s, l, h, y, b, I, k, z) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: l, cameraQueryGeometry: h, scale: y, tileSize: this.tileSize, pixelPosMatrix: z, transform: I, params: b, queryPadding: this.queryPadding * k }, e, r, s) : {};
        }
        querySourceFeatures(e, r) {
          const s = this.latestFeatureIndex;
          if (!s || !s.rawTileData) return;
          const l = s.loadVTLayers(), h = r && r.sourceLayer ? r.sourceLayer : "", y = l._geojsonTileLayer || l[h];
          if (!y) return;
          const b = c.a7(r && r.filter), { z: I, x: k, y: z } = this.tileID.canonical, M = { z: I, x: k, y: z };
          for (let O = 0; O < y.length; O++) {
            const U = y.feature(O);
            if (b.needGeometry) {
              const Q = c.a8(U, !0);
              if (!b.filter(new c.z(this.tileID.overscaledZ), Q, this.tileID.canonical)) continue;
            } else if (!b.filter(new c.z(this.tileID.overscaledZ), U)) continue;
            const B = s.getId(U, h), G = new c.a9(U, I, k, z, B);
            G.tile = M, e.push(G);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e) {
          const r = this.expirationTime;
          if (e.cacheControl) {
            const s = c.aa(e.cacheControl);
            s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"]);
          } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
          if (this.expirationTime) {
            const s = Date.now();
            let l = !1;
            if (this.expirationTime > s) l = !1;
            else if (r) if (this.expirationTime < r) l = !0;
            else {
              const h = this.expirationTime - r;
              h ? this.expirationTime = s + Math.max(h, 3e4) : l = !0;
            }
            else l = !0;
            l ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(e, r) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
          const s = this.latestFeatureIndex.loadVTLayers();
          for (const l in this.buckets) {
            if (!r.style.hasLayer(l)) continue;
            const h = this.buckets[l], y = h.layers[0].sourceLayer || "_geojsonTileLayer", b = s[y], I = e[y];
            if (!b || !I || Object.keys(I).length === 0) continue;
            h.update(I, b, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const k = r && r.style && r.style.getLayer(l);
            k && (this.queryPadding = Math.max(this.queryPadding, k.queryRadius(h)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < j.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(e) {
          this.symbolFadeHoldUntil = j.now() + e;
        }
        setDependencies(e, r) {
          const s = {};
          for (const l of r) s[l] = !0;
          this.dependencies[e] = s;
        }
        hasDependency(e, r) {
          for (const s of e) {
            const l = this.dependencies[s];
            if (l) {
              for (const h of r) if (l[h]) return !0;
            }
          }
          return !1;
        }
      }
      class ct {
        constructor(e, r) {
          this.max = e, this.onRemove = r, this.reset();
        }
        reset() {
          for (const e in this.data) for (const r of this.data[e]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
          return this.data = {}, this.order = [], this;
        }
        add(e, r, s) {
          const l = e.wrapped().key;
          this.data[l] === void 0 && (this.data[l] = []);
          const h = { value: r, timeout: void 0 };
          if (s !== void 0 && (h.timeout = setTimeout(() => {
            this.remove(e, h);
          }, s)), this.data[l].push(h), this.order.push(l), this.order.length > this.max) {
            const y = this._getAndRemoveByKey(this.order[0]);
            y && this.onRemove(y);
          }
          return this;
        }
        has(e) {
          return e.wrapped().key in this.data;
        }
        getAndRemove(e) {
          return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
        }
        _getAndRemoveByKey(e) {
          const r = this.data[e].shift();
          return r.timeout && clearTimeout(r.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), r.value;
        }
        getByKey(e) {
          const r = this.data[e];
          return r ? r[0].value : null;
        }
        get(e) {
          return this.has(e) ? this.data[e.wrapped().key][0].value : null;
        }
        remove(e, r) {
          if (!this.has(e)) return this;
          const s = e.wrapped().key, l = r === void 0 ? 0 : this.data[s].indexOf(r), h = this.data[s][l];
          return this.data[s].splice(l, 1), h.timeout && clearTimeout(h.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(h.value), this.order.splice(this.order.indexOf(s), 1), this;
        }
        setMaxSize(e) {
          for (this.max = e; this.order.length > this.max; ) {
            const r = this._getAndRemoveByKey(this.order[0]);
            r && this.onRemove(r);
          }
          return this;
        }
        filter(e) {
          const r = [];
          for (const s in this.data) for (const l of this.data[s]) e(l.value) || r.push(l);
          for (const s of r) this.remove(s.value.tileID, s);
        }
      }
      class si {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e, r, s) {
          const l = String(r);
          if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][l] = this.stateChanges[e][l] || {}, c.e(this.stateChanges[e][l], s), this.deletedStates[e] === null) {
            this.deletedStates[e] = {};
            for (const h in this.state[e]) h !== l && (this.deletedStates[e][h] = null);
          } else if (this.deletedStates[e] && this.deletedStates[e][l] === null) {
            this.deletedStates[e][l] = {};
            for (const h in this.state[e][l]) s[h] || (this.deletedStates[e][l][h] = null);
          } else for (const h in s) this.deletedStates[e] && this.deletedStates[e][l] && this.deletedStates[e][l][h] === null && delete this.deletedStates[e][l][h];
        }
        removeFeatureState(e, r, s) {
          if (this.deletedStates[e] === null) return;
          const l = String(r);
          if (this.deletedStates[e] = this.deletedStates[e] || {}, s && r !== void 0) this.deletedStates[e][l] !== null && (this.deletedStates[e][l] = this.deletedStates[e][l] || {}, this.deletedStates[e][l][s] = null);
          else if (r !== void 0) if (this.stateChanges[e] && this.stateChanges[e][l]) for (s in this.deletedStates[e][l] = {}, this.stateChanges[e][l]) this.deletedStates[e][l][s] = null;
          else this.deletedStates[e][l] = null;
          else this.deletedStates[e] = null;
        }
        getState(e, r) {
          const s = String(r), l = c.e({}, (this.state[e] || {})[s], (this.stateChanges[e] || {})[s]);
          if (this.deletedStates[e] === null) return {};
          if (this.deletedStates[e]) {
            const h = this.deletedStates[e][r];
            if (h === null) return {};
            for (const y in h) delete l[y];
          }
          return l;
        }
        initializeTileState(e, r) {
          e.setFeatureState(this.state, r);
        }
        coalesceChanges(e, r) {
          const s = {};
          for (const l in this.stateChanges) {
            this.state[l] = this.state[l] || {};
            const h = {};
            for (const y in this.stateChanges[l]) this.state[l][y] || (this.state[l][y] = {}), c.e(this.state[l][y], this.stateChanges[l][y]), h[y] = this.state[l][y];
            s[l] = h;
          }
          for (const l in this.deletedStates) {
            this.state[l] = this.state[l] || {};
            const h = {};
            if (this.deletedStates[l] === null) for (const y in this.state[l]) h[y] = {}, this.state[l][y] = {};
            else for (const y in this.deletedStates[l]) {
              if (this.deletedStates[l][y] === null) this.state[l][y] = {};
              else for (const b of Object.keys(this.deletedStates[l][y])) delete this.state[l][y][b];
              h[y] = this.state[l][y];
            }
            s[l] = s[l] || {}, c.e(s[l], h);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(s).length !== 0) for (const l in e) e[l].setFeatureState(s, r);
        }
      }
      class kt extends c.E {
        constructor(e, r, s) {
          super(), this.id = e, this.dispatcher = s, this.on("data", (l) => this._dataHandler(l)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((l, h, y, b) => {
            const I = new (Ci(h.type))(l, h, y, b);
            if (I.id !== l) throw new Error(`Expected Source id to be ${l} instead of ${I.id}`);
            return I;
          })(e, r, s, this), this._tiles = {}, this._cache = new ct(0, (l) => this._unloadTile(l)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new si(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(e) {
          this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
        }
        onRemove(e) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const e in this._tiles) {
            const r = this._tiles[e];
            if (r.state !== "loaded" && r.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const e = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(e, r, s) {
          return c._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(e), this._tileLoaded(e, r, s);
            } catch (l) {
              e.state = "errored", l.status !== 404 ? this._source.fire(new c.j(l, { tile: e })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(e) {
          this._source.unloadTile && this._source.unloadTile(e);
        }
        _abortTile(e) {
          this._source.abortTile && this._source.abortTile(e), this._source.fire(new c.k("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const r in this._tiles) {
            const s = this._tiles[r];
            s.upload(e), s.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((e) => e.tileID).sort(Ei).map((e) => e.key);
        }
        getRenderableIds(e) {
          const r = [];
          for (const s in this._tiles) this._isIdRenderable(s, e) && r.push(this._tiles[s]);
          return e ? r.sort((s, l) => {
            const h = s.tileID, y = l.tileID, b = new c.P(h.canonical.x, h.canonical.y)._rotate(this.transform.angle), I = new c.P(y.canonical.x, y.canonical.y)._rotate(this.transform.angle);
            return h.overscaledZ - y.overscaledZ || I.y - b.y || I.x - b.x;
          }).map((s) => s.tileID.key) : r.map((s) => s.tileID).sort(Ei).map((s) => s.key);
        }
        hasRenderableParent(e) {
          const r = this.findLoadedParent(e, 0);
          return !!r && this._isIdRenderable(r.tileID.key);
        }
        _isIdRenderable(e, r) {
          return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (r || !this._tiles[e].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const e in this._tiles) this._tiles[e].state !== "errored" && this._reloadTile(e, "reloading");
          }
        }
        _reloadTile(e, r) {
          return c._(this, void 0, void 0, function* () {
            const s = this._tiles[e];
            s && (s.state !== "loading" && (s.state = r), yield this._loadTile(s, e, r));
          });
        }
        _tileLoaded(e, r, s) {
          e.timeAdded = j.now(), s === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(r, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new c.k("data", { dataType: "source", tile: e, coord: e.tileID }));
        }
        _backfillDEM(e) {
          const r = this.getRenderableIds();
          for (let l = 0; l < r.length; l++) {
            const h = r[l];
            if (e.neighboringTiles && e.neighboringTiles[h]) {
              const y = this.getTileByID(h);
              s(e, y), s(y, e);
            }
          }
          function s(l, h) {
            l.needsHillshadePrepare = !0, l.needsTerrainPrepare = !0;
            let y = h.tileID.canonical.x - l.tileID.canonical.x;
            const b = h.tileID.canonical.y - l.tileID.canonical.y, I = Math.pow(2, l.tileID.canonical.z), k = h.tileID.key;
            y === 0 && b === 0 || Math.abs(b) > 1 || (Math.abs(y) > 1 && (Math.abs(y + I) === 1 ? y += I : Math.abs(y - I) === 1 && (y -= I)), h.dem && l.dem && (l.dem.backfillBorder(h.dem, y, b), l.neighboringTiles && l.neighboringTiles[k] && (l.neighboringTiles[k].backfilled = !0)));
          }
        }
        getTile(e) {
          return this.getTileByID(e.key);
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        _retainLoadedChildren(e, r, s, l) {
          for (const h in this._tiles) {
            let y = this._tiles[h];
            if (l[h] || !y.hasData() || y.tileID.overscaledZ <= r || y.tileID.overscaledZ > s) continue;
            let b = y.tileID;
            for (; y && y.tileID.overscaledZ > r + 1; ) {
              const k = y.tileID.scaledTo(y.tileID.overscaledZ - 1);
              y = this._tiles[k.key], y && y.hasData() && (b = k);
            }
            let I = b;
            for (; I.overscaledZ > r; ) if (I = I.scaledTo(I.overscaledZ - 1), e[I.key]) {
              l[b.key] = b;
              break;
            }
          }
        }
        findLoadedParent(e, r) {
          if (e.key in this._loadedParentTiles) {
            const s = this._loadedParentTiles[e.key];
            return s && s.tileID.overscaledZ >= r ? s : null;
          }
          for (let s = e.overscaledZ - 1; s >= r; s--) {
            const l = e.scaledTo(s), h = this._getLoadedTile(l);
            if (h) return h;
          }
        }
        findLoadedSibling(e) {
          return this._getLoadedTile(e);
        }
        _getLoadedTile(e) {
          const r = this._tiles[e.key];
          return r && r.hasData() ? r : this._cache.getByKey(e.wrapped().key);
        }
        updateCacheSize(e) {
          const r = Math.ceil(e.width / this._source.tileSize) + 1, s = Math.ceil(e.height / this._source.tileSize) + 1, l = Math.floor(r * s * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), h = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, l) : l;
          this._cache.setMaxSize(h);
        }
        handleWrapJump(e) {
          const r = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
          if (this._prevLng = e, r) {
            const s = {};
            for (const l in this._tiles) {
              const h = this._tiles[l];
              h.tileID = h.tileID.unwrapTo(h.tileID.wrap + r), s[h.tileID.key] = h;
            }
            this._tiles = s;
            for (const l in this._timers) clearTimeout(this._timers[l]), delete this._timers[l];
            for (const l in this._tiles) this._setTileReloadTimer(l, this._tiles[l]);
          }
        }
        _updateCoveredAndRetainedTiles(e, r, s, l, h, y) {
          const b = {}, I = {}, k = Object.keys(e), z = j.now();
          for (const M of k) {
            const O = e[M], U = this._tiles[M];
            if (!U || U.fadeEndTime !== 0 && U.fadeEndTime <= z) continue;
            const B = this.findLoadedParent(O, r), G = this.findLoadedSibling(O), Q = B || G || null;
            Q && (this._addTile(Q.tileID), b[Q.tileID.key] = Q.tileID), I[M] = O;
          }
          this._retainLoadedChildren(I, l, s, e);
          for (const M in b) e[M] || (this._coveredTiles[M] = !0, e[M] = b[M]);
          if (y) {
            const M = {}, O = {};
            for (const U of h) this._tiles[U.key].hasData() ? M[U.key] = U : O[U.key] = U;
            for (const U in O) {
              const B = O[U].children(this._source.maxzoom);
              this._tiles[B[0].key] && this._tiles[B[1].key] && this._tiles[B[2].key] && this._tiles[B[3].key] && (M[B[0].key] = e[B[0].key] = B[0], M[B[1].key] = e[B[1].key] = B[1], M[B[2].key] = e[B[2].key] = B[2], M[B[3].key] = e[B[3].key] = B[3], delete O[U]);
            }
            for (const U in O) {
              const B = O[U], G = this.findLoadedParent(B, this._source.minzoom), Q = this.findLoadedSibling(B), ee = G || Q || null;
              if (ee) {
                M[ee.tileID.key] = e[ee.tileID.key] = ee.tileID;
                for (const ne in M) M[ne].isChildOf(ee.tileID) && delete M[ne];
              }
            }
            for (const U in this._tiles) M[U] || (this._coveredTiles[U] = !0);
          }
        }
        update(e, r) {
          if (!this._sourceLoaded || this._paused) return;
          let s;
          this.transform = e, this.terrain = r, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((z) => new c.S(z.canonical.z, z.wrap, z.canonical.z, z.canonical.x, z.canonical.y)) : (s = e.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r }), this._source.hasTile && (s = s.filter((z) => this._source.hasTile(z)))) : s = [];
          const l = e.coveringZoomLevel(this._source), h = Math.max(l - kt.maxOverzooming, this._source.minzoom), y = Math.max(l + kt.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const z = {};
            for (const M of s) if (M.canonical.z > this._source.minzoom) {
              const O = M.scaledTo(M.canonical.z - 1);
              z[O.key] = O;
              const U = M.scaledTo(Math.max(this._source.minzoom, Math.min(M.canonical.z, 5)));
              z[U.key] = U;
            }
            s = s.concat(Object.values(z));
          }
          const b = s.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, b && this.fire(new c.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const I = this._updateRetainedTiles(s, l);
          Pr(this._source.type) && this._updateCoveredAndRetainedTiles(I, h, y, l, s, r);
          for (const z in I) this._tiles[z].clearFadeHold();
          const k = c.ab(this._tiles, I);
          for (const z of k) {
            const M = this._tiles[z];
            M.hasSymbolBuckets && !M.holdingForFade() ? M.setHoldDuration(this.map._fadeDuration) : M.hasSymbolBuckets && !M.symbolFadeFinished() || this._removeTile(z);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
        }
        _updateRetainedTiles(e, r) {
          var s;
          const l = {}, h = {}, y = Math.max(r - kt.maxOverzooming, this._source.minzoom), b = Math.max(r + kt.maxUnderzooming, this._source.minzoom), I = {};
          for (const k of e) {
            const z = this._addTile(k);
            l[k.key] = k, z.hasData() || r < this._source.maxzoom && (I[k.key] = k);
          }
          this._retainLoadedChildren(I, r, b, l);
          for (const k of e) {
            let z = this._tiles[k.key];
            if (z.hasData()) continue;
            if (r + 1 > this._source.maxzoom) {
              const O = k.children(this._source.maxzoom)[0], U = this.getTile(O);
              if (U && U.hasData()) {
                l[O.key] = O;
                continue;
              }
            } else {
              const O = k.children(this._source.maxzoom);
              if (l[O[0].key] && l[O[1].key] && l[O[2].key] && l[O[3].key]) continue;
            }
            let M = z.wasRequested();
            for (let O = k.overscaledZ - 1; O >= y; --O) {
              const U = k.scaledTo(O);
              if (h[U.key]) break;
              if (h[U.key] = !0, z = this.getTile(U), !z && M && (z = this._addTile(U)), z) {
                const B = z.hasData();
                if ((B || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || M) && (l[U.key] = U), M = z.wasRequested(), B) break;
              }
            }
          }
          return l;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const e in this._tiles) {
            const r = [];
            let s, l = this._tiles[e].tileID;
            for (; l.overscaledZ > 0; ) {
              if (l.key in this._loadedParentTiles) {
                s = this._loadedParentTiles[l.key];
                break;
              }
              r.push(l.key);
              const h = l.scaledTo(l.overscaledZ - 1);
              if (s = this._getLoadedTile(h), s) break;
              l = h;
            }
            for (const h of r) this._loadedParentTiles[h] = s;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const e in this._tiles) {
            const r = this._tiles[e].tileID, s = this._getLoadedTile(r);
            this._loadedSiblingTiles[r.key] = s;
          }
        }
        _addTile(e) {
          let r = this._tiles[e.key];
          if (r) return r;
          r = this._cache.getAndRemove(e), r && (this._setTileReloadTimer(e.key, r), r.tileID = e, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, r)));
          const s = r;
          return r || (r = new cr(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(r, e.key, r.state)), r.uses++, this._tiles[e.key] = r, s || this._source.fire(new c.k("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
        }
        _setTileReloadTimer(e, r) {
          e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
          const s = r.getExpiryTimeout();
          s && (this._timers[e] = setTimeout(() => {
            this._reloadTile(e, "expired"), delete this._timers[e];
          }, s));
        }
        _removeTile(e) {
          const r = this._tiles[e];
          r && (r.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
        }
        _dataHandler(e) {
          const r = e.sourceDataType;
          e.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && r === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const e in this._tiles) this._removeTile(e);
          this._cache.reset();
        }
        tilesIn(e, r, s) {
          const l = [], h = this.transform;
          if (!h) return l;
          const y = s ? h.getCameraQueryGeometry(e) : e, b = e.map((B) => h.pointCoordinate(B, this.terrain)), I = y.map((B) => h.pointCoordinate(B, this.terrain)), k = this.getIds();
          let z = 1 / 0, M = 1 / 0, O = -1 / 0, U = -1 / 0;
          for (const B of I) z = Math.min(z, B.x), M = Math.min(M, B.y), O = Math.max(O, B.x), U = Math.max(U, B.y);
          for (let B = 0; B < k.length; B++) {
            const G = this._tiles[k[B]];
            if (G.holdingForFade()) continue;
            const Q = G.tileID, ee = Math.pow(2, h.zoom - G.tileID.overscaledZ), ne = r * G.queryPadding * c.X / G.tileSize / ee, ie = [Q.getTilePoint(new c.Z(z, M)), Q.getTilePoint(new c.Z(O, U))];
            if (ie[0].x - ne < c.X && ie[0].y - ne < c.X && ie[1].x + ne >= 0 && ie[1].y + ne >= 0) {
              const he = b.map((ve) => Q.getTilePoint(ve)), we = I.map((ve) => Q.getTilePoint(ve));
              l.push({ tile: G, tileID: Q, queryGeometry: he, cameraQueryGeometry: we, scale: ee });
            }
          }
          return l;
        }
        getVisibleCoordinates(e) {
          const r = this.getRenderableIds(e).map((s) => this._tiles[s].tileID);
          for (const s of r) s.posMatrix = this.transform.calculatePosMatrix(s.toUnwrapped());
          return r;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Pr(this._source.type)) {
            const e = j.now();
            for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= e) return !0;
          }
          return !1;
        }
        setFeatureState(e, r, s) {
          this._state.updateState(e = e || "_geojsonTileLayer", r, s);
        }
        removeFeatureState(e, r, s) {
          this._state.removeFeatureState(e = e || "_geojsonTileLayer", r, s);
        }
        getFeatureState(e, r) {
          return this._state.getState(e = e || "_geojsonTileLayer", r);
        }
        setDependencies(e, r, s) {
          const l = this._tiles[e];
          l && l.setDependencies(r, s);
        }
        reloadTilesForDependencies(e, r) {
          for (const s in this._tiles) this._tiles[s].hasDependency(e, r) && this._reloadTile(s, "reloading");
          this._cache.filter((s) => !s.hasDependency(e, r));
        }
      }
      function Ei(a, e) {
        const r = Math.abs(2 * a.wrap) - +(a.wrap < 0), s = Math.abs(2 * e.wrap) - +(e.wrap < 0);
        return a.overscaledZ - e.overscaledZ || s - r || e.canonical.y - a.canonical.y || e.canonical.x - a.canonical.x;
      }
      function Pr(a) {
        return a === "raster" || a === "image" || a === "video";
      }
      kt.maxOverzooming = 10, kt.maxUnderzooming = 3;
      class Et {
        constructor(e, r) {
          this.reset(e, r);
        }
        reset(e, r) {
          this.points = e || [], this._distances = [0];
          for (let s = 1; s < this.points.length; s++) this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e) {
          if (this.points.length === 1) return this.points[0];
          e = c.ac(e, 0, 1);
          let r = 1, s = this._distances[r];
          const l = e * this.paddedLength + this.padding;
          for (; s < l && r < this._distances.length; ) s = this._distances[++r];
          const h = r - 1, y = this._distances[h], b = s - y, I = b > 0 ? (l - y) / b : 0;
          return this.points[h].mult(1 - I).add(this.points[r].mult(I));
        }
      }
      function $r(a, e) {
        let r = !0;
        return a === "always" || a !== "never" && e !== "never" || (r = !1), r;
      }
      class qi {
        constructor(e, r, s) {
          const l = this.boxCells = [], h = this.circleCells = [];
          this.xCellCount = Math.ceil(e / s), this.yCellCount = Math.ceil(r / s);
          for (let y = 0; y < this.xCellCount * this.yCellCount; y++) l.push([]), h.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = r, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e, r, s, l, h) {
          this._forEachCell(r, s, l, h, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(r), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(h);
        }
        insertCircle(e, r, s, l) {
          this._forEachCell(r - l, s - l, r + l, s + l, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(r), this.circles.push(s), this.circles.push(l);
        }
        _insertBoxCell(e, r, s, l, h, y) {
          this.boxCells[h].push(y);
        }
        _insertCircleCell(e, r, s, l, h, y) {
          this.circleCells[h].push(y);
        }
        _query(e, r, s, l, h, y, b) {
          if (s < 0 || e > this.width || l < 0 || r > this.height) return [];
          const I = [];
          if (e <= 0 && r <= 0 && this.width <= s && this.height <= l) {
            if (h) return [{ key: null, x1: e, y1: r, x2: s, y2: l }];
            for (let k = 0; k < this.boxKeys.length; k++) I.push({ key: this.boxKeys[k], x1: this.bboxes[4 * k], y1: this.bboxes[4 * k + 1], x2: this.bboxes[4 * k + 2], y2: this.bboxes[4 * k + 3] });
            for (let k = 0; k < this.circleKeys.length; k++) {
              const z = this.circles[3 * k], M = this.circles[3 * k + 1], O = this.circles[3 * k + 2];
              I.push({ key: this.circleKeys[k], x1: z - O, y1: M - O, x2: z + O, y2: M + O });
            }
          } else this._forEachCell(e, r, s, l, this._queryCell, I, { hitTest: h, overlapMode: y, seenUids: { box: {}, circle: {} } }, b);
          return I;
        }
        query(e, r, s, l) {
          return this._query(e, r, s, l, !1, null);
        }
        hitTest(e, r, s, l, h, y) {
          return this._query(e, r, s, l, !0, h, y).length > 0;
        }
        hitTestCircle(e, r, s, l, h) {
          const y = e - s, b = e + s, I = r - s, k = r + s;
          if (b < 0 || y > this.width || k < 0 || I > this.height) return !1;
          const z = [];
          return this._forEachCell(y, I, b, k, this._queryCellCircle, z, { hitTest: !0, overlapMode: l, circle: { x: e, y: r, radius: s }, seenUids: { box: {}, circle: {} } }, h), z.length > 0;
        }
        _queryCell(e, r, s, l, h, y, b, I) {
          const { seenUids: k, hitTest: z, overlapMode: M } = b, O = this.boxCells[h];
          if (O !== null) {
            const B = this.bboxes;
            for (const G of O) if (!k.box[G]) {
              k.box[G] = !0;
              const Q = 4 * G, ee = this.boxKeys[G];
              if (e <= B[Q + 2] && r <= B[Q + 3] && s >= B[Q + 0] && l >= B[Q + 1] && (!I || I(ee)) && (!z || !$r(M, ee.overlapMode)) && (y.push({ key: ee, x1: B[Q], y1: B[Q + 1], x2: B[Q + 2], y2: B[Q + 3] }), z)) return !0;
            }
          }
          const U = this.circleCells[h];
          if (U !== null) {
            const B = this.circles;
            for (const G of U) if (!k.circle[G]) {
              k.circle[G] = !0;
              const Q = 3 * G, ee = this.circleKeys[G];
              if (this._circleAndRectCollide(B[Q], B[Q + 1], B[Q + 2], e, r, s, l) && (!I || I(ee)) && (!z || !$r(M, ee.overlapMode))) {
                const ne = B[Q], ie = B[Q + 1], he = B[Q + 2];
                if (y.push({ key: ee, x1: ne - he, y1: ie - he, x2: ne + he, y2: ie + he }), z) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(e, r, s, l, h, y, b, I) {
          const { circle: k, seenUids: z, overlapMode: M } = b, O = this.boxCells[h];
          if (O !== null) {
            const B = this.bboxes;
            for (const G of O) if (!z.box[G]) {
              z.box[G] = !0;
              const Q = 4 * G, ee = this.boxKeys[G];
              if (this._circleAndRectCollide(k.x, k.y, k.radius, B[Q + 0], B[Q + 1], B[Q + 2], B[Q + 3]) && (!I || I(ee)) && !$r(M, ee.overlapMode)) return y.push(!0), !0;
            }
          }
          const U = this.circleCells[h];
          if (U !== null) {
            const B = this.circles;
            for (const G of U) if (!z.circle[G]) {
              z.circle[G] = !0;
              const Q = 3 * G, ee = this.circleKeys[G];
              if (this._circlesCollide(B[Q], B[Q + 1], B[Q + 2], k.x, k.y, k.radius) && (!I || I(ee)) && !$r(M, ee.overlapMode)) return y.push(!0), !0;
            }
          }
        }
        _forEachCell(e, r, s, l, h, y, b, I) {
          const k = this._convertToXCellCoord(e), z = this._convertToYCellCoord(r), M = this._convertToXCellCoord(s), O = this._convertToYCellCoord(l);
          for (let U = k; U <= M; U++) for (let B = z; B <= O; B++) if (h.call(this, e, r, s, l, this.xCellCount * B + U, y, b, I)) return;
        }
        _convertToXCellCoord(e) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
        }
        _convertToYCellCoord(e) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
        }
        _circlesCollide(e, r, s, l, h, y) {
          const b = l - e, I = h - r, k = s + y;
          return k * k > b * b + I * I;
        }
        _circleAndRectCollide(e, r, s, l, h, y, b) {
          const I = (y - l) / 2, k = Math.abs(e - (l + I));
          if (k > I + s) return !1;
          const z = (b - h) / 2, M = Math.abs(r - (h + z));
          if (M > z + s) return !1;
          if (k <= I || M <= z) return !0;
          const O = k - I, U = M - z;
          return O * O + U * U <= s * s;
        }
      }
      function Cr(a, e, r, s, l) {
        const h = c.H();
        return e ? (c.K(h, h, [1 / l, 1 / l, 1]), r || c.ad(h, h, s.angle)) : c.L(h, s.labelPlaneMatrix, a), h;
      }
      function Er(a, e, r, s, l) {
        if (e) {
          const h = c.ae(a);
          return c.K(h, h, [l, l, 1]), r || c.ad(h, h, -s.angle), h;
        }
        return s.glCoordMatrix;
      }
      function ue(a, e, r, s) {
        let l;
        s ? (l = [a, e, s(a, e), 1], c.af(l, l, r)) : (l = [a, e, 0, 1], vi(l, l, r));
        const h = l[3];
        return { point: new c.P(l[0] / h, l[1] / h), signedDistanceFromCamera: h, isOccluded: !1 };
      }
      function $(a, e) {
        return 0.5 + a / e * 0.5;
      }
      function W(a, e) {
        return a.x >= -e[0] && a.x <= e[0] && a.y >= -e[1] && a.y <= e[1];
      }
      function te(a, e, r, s, l, h, y, b, I, k, z, M, O, U, B) {
        const G = s ? a.textSizeData : a.iconSizeData, Q = c.ag(G, r.transform.zoom), ee = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], ne = s ? a.text.dynamicLayoutVertexArray : a.icon.dynamicLayoutVertexArray;
        ne.clear();
        const ie = a.lineVertexArray, he = s ? a.text.placedSymbolArray : a.icon.placedSymbolArray, we = r.transform.width / r.transform.height;
        let ve = !1;
        for (let Ue = 0; Ue < he.length; Ue++) {
          const nt = he.get(Ue);
          if (nt.hidden || nt.writingMode === c.ah.vertical && !ve) {
            Zt(nt.numGlyphs, ne);
            continue;
          }
          ve = !1;
          const ht = ue(nt.anchorX, nt.anchorY, e, B);
          if (!W(ht.point, ee)) {
            Zt(nt.numGlyphs, ne);
            continue;
          }
          const pt = $(r.transform.cameraToCenterDistance, ht.signedDistanceFromCamera), dt = c.ai(G, Q, nt), ut = y ? dt / pt : dt * pt, ft = { getElevation: B, labelPlaneMatrix: l, lineVertexArray: ie, pitchWithMap: y, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: k, tileAnchorPoint: new c.P(nt.anchorX, nt.anchorY), unwrappedTileID: z, width: M, height: O, translation: U }, Ot = Ee(ft, nt, ut, !1, b, e, h, a.glyphOffsetArray, ne, we, I);
          ve = Ot.useVertical, (Ot.notEnoughRoom || ve || Ot.needsFlipping && Ee(ft, nt, ut, !0, b, e, h, a.glyphOffsetArray, ne, we, I).notEnoughRoom) && Zt(nt.numGlyphs, ne);
        }
        s ? a.text.dynamicLayoutVertexBuffer.updateData(ne) : a.icon.dynamicLayoutVertexBuffer.updateData(ne);
      }
      function ce(a, e, r, s, l, h, y, b) {
        const I = h.glyphStartIndex + h.numGlyphs, k = h.lineStartIndex, z = h.lineStartIndex + h.lineLength, M = e.getoffsetX(h.glyphStartIndex), O = e.getoffsetX(I - 1), U = mt(a * M, r, s, l, h.segment, k, z, b, y);
        if (!U) return null;
        const B = mt(a * O, r, s, l, h.segment, k, z, b, y);
        return B ? b.projectionCache.anyProjectionOccluded ? null : { first: U, last: B } : null;
      }
      function Pe(a, e, r, s) {
        return a === c.ah.horizontal && Math.abs(r.y - e.y) > Math.abs(r.x - e.x) * s ? { useVertical: !0 } : (a === c.ah.vertical ? e.y < r.y : e.x > r.x) ? { needsFlipping: !0 } : null;
      }
      function Ee(a, e, r, s, l, h, y, b, I, k, z) {
        const M = r / 24, O = e.lineOffsetX * M, U = e.lineOffsetY * M;
        let B;
        if (e.numGlyphs > 1) {
          const G = e.glyphStartIndex + e.numGlyphs, Q = e.lineStartIndex, ee = e.lineStartIndex + e.lineLength, ne = ce(M, b, O, U, s, e, z, a);
          if (!ne) return { notEnoughRoom: !0 };
          const ie = ue(ne.first.point.x, ne.first.point.y, y, a.getElevation).point, he = ue(ne.last.point.x, ne.last.point.y, y, a.getElevation).point;
          if (l && !s) {
            const we = Pe(e.writingMode, ie, he, k);
            if (we) return we;
          }
          B = [ne.first];
          for (let we = e.glyphStartIndex + 1; we < G - 1; we++) B.push(mt(M * b.getoffsetX(we), O, U, s, e.segment, Q, ee, a, z));
          B.push(ne.last);
        } else {
          if (l && !s) {
            const Q = ue(a.tileAnchorPoint.x, a.tileAnchorPoint.y, h, a.getElevation).point, ee = e.lineStartIndex + e.segment + 1, ne = new c.P(a.lineVertexArray.getx(ee), a.lineVertexArray.gety(ee)), ie = ue(ne.x, ne.y, h, a.getElevation), he = ie.signedDistanceFromCamera > 0 ? ie.point : function(ve, Ue, nt, ht, pt, dt) {
              return Ae(ve, Ue, nt, 1, pt, dt);
            }(a.tileAnchorPoint, ne, Q, 0, h, a), we = Pe(e.writingMode, Q, he, k);
            if (we) return we;
          }
          const G = mt(M * b.getoffsetX(e.glyphStartIndex), O, U, s, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, a, z);
          if (!G || a.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          B = [G];
        }
        for (const G of B) c.aj(I, G.point, G.angle);
        return {};
      }
      function Ae(a, e, r, s, l, h) {
        const y = a.add(a.sub(e)._unit()), b = l !== void 0 ? ue(y.x, y.y, l, h.getElevation).point : Ve(y.x, y.y, h).point, I = r.sub(b);
        return r.add(I._mult(s / I.mag()));
      }
      function be(a, e, r) {
        const s = e.projectionCache;
        if (s.projections[a]) return s.projections[a];
        const l = new c.P(e.lineVertexArray.getx(a), e.lineVertexArray.gety(a)), h = Ve(l.x, l.y, e);
        if (h.signedDistanceFromCamera > 0) return s.projections[a] = h.point, s.anyProjectionOccluded = s.anyProjectionOccluded || h.isOccluded, h.point;
        const y = a - r.direction;
        return function(b, I, k, z, M) {
          return Ae(b, I, k, z, void 0, M);
        }(r.distanceFromAnchor === 0 ? e.tileAnchorPoint : new c.P(e.lineVertexArray.getx(y), e.lineVertexArray.gety(y)), l, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, e);
      }
      function Ve(a, e, r) {
        const s = a + r.translation[0], l = e + r.translation[1];
        let h;
        return !r.pitchWithMap && r.projection.useSpecialProjectionForSymbols ? (h = r.projection.projectTileCoordinates(s, l, r.unwrappedTileID, r.getElevation), h.point.x = (0.5 * h.point.x + 0.5) * r.width, h.point.y = (0.5 * -h.point.y + 0.5) * r.height) : (h = ue(s, l, r.labelPlaneMatrix, r.getElevation), h.isOccluded = !1), h;
      }
      function et(a, e, r) {
        return a._unit()._perp()._mult(e * r);
      }
      function Re(a, e, r, s, l, h, y, b, I) {
        if (b.projectionCache.offsets[a]) return b.projectionCache.offsets[a];
        const k = r.add(e);
        if (a + I.direction < s || a + I.direction >= l) return b.projectionCache.offsets[a] = k, k;
        const z = be(a + I.direction, b, I), M = et(z.sub(r), y, I.direction), O = r.add(M), U = z.add(M);
        return b.projectionCache.offsets[a] = c.ak(h, k, O, U) || k, b.projectionCache.offsets[a];
      }
      function mt(a, e, r, s, l, h, y, b, I) {
        const k = s ? a - e : a + e;
        let z = k > 0 ? 1 : -1, M = 0;
        s && (z *= -1, M = Math.PI), z < 0 && (M += Math.PI);
        let O, U = z > 0 ? h + l : h + l + 1;
        b.projectionCache.cachedAnchorPoint ? O = b.projectionCache.cachedAnchorPoint : (O = Ve(b.tileAnchorPoint.x, b.tileAnchorPoint.y, b).point, b.projectionCache.cachedAnchorPoint = O);
        let B, G, Q = O, ee = O, ne = 0, ie = 0;
        const he = Math.abs(k), we = [];
        let ve;
        for (; ne + ie <= he; ) {
          if (U += z, U < h || U >= y) return null;
          ne += ie, ee = Q, G = B;
          const ht = { absOffsetX: he, direction: z, distanceFromAnchor: ne, previousVertex: ee };
          if (Q = be(U, b, ht), r === 0) we.push(ee), ve = Q.sub(ee);
          else {
            let pt;
            const dt = Q.sub(ee);
            pt = dt.mag() === 0 ? et(be(U + z, b, ht).sub(Q), r, z) : et(dt, r, z), G || (G = ee.add(pt)), B = Re(U, pt, Q, h, y, G, r, b, ht), we.push(G), ve = B.sub(G);
          }
          ie = ve.mag();
        }
        const Ue = ve._mult((he - ne) / ie)._add(G || ee), nt = M + Math.atan2(Q.y - ee.y, Q.x - ee.x);
        return we.push(Ue), { point: Ue, angle: I ? nt : 0, path: we };
      }
      const Dt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Zt(a, e) {
        for (let r = 0; r < a; r++) {
          const s = e.length;
          e.resize(s + 4), e.float32.set(Dt, 3 * s);
        }
      }
      function vi(a, e, r) {
        const s = e[0], l = e[1];
        return a[0] = r[0] * s + r[4] * l + r[12], a[1] = r[1] * s + r[5] * l + r[13], a[3] = r[3] * s + r[7] * l + r[15], a;
      }
      const Jt = 100;
      class gi {
        constructor(e, r, s = new qi(e.width + 200, e.height + 200, 25), l = new qi(e.width + 200, e.height + 200, 25)) {
          this.transform = e, this.mapProjection = r, this.grid = s, this.ignoredGrid = l, this.pitchFactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Jt, this.screenBottomBoundary = e.height + Jt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(e, r, s, l, h, y, b, I, k, z, M) {
          const O = e.anchorPointX + I[0], U = e.anchorPointY + I[1], B = this.projectAndGetPerspectiveRatio(l, O, U, h, z), G = s * B.perspectiveRatio;
          let Q;
          if (y || b) Q = this._projectCollisionBox(e, G, l, h, y, b, I, B, z, M);
          else {
            const we = B.point.x + (M ? M.x * G : 0), ve = B.point.y + (M ? M.y * G : 0);
            Q = { allPointsOccluded: !1, box: [we + e.x1 * G, ve + e.y1 * G, we + e.x2 * G, ve + e.y2 * G] };
          }
          const [ee, ne, ie, he] = Q.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (y ? Q.allPointsOccluded : this.mapProjection.isOccluded(O, U, h)) || B.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(ee, ne, ie, he) || r !== "always" && this.grid.hitTest(ee, ne, ie, he, r, k) ? { box: [ee, ne, ie, he], placeable: !1, offscreen: !1 } : { box: [ee, ne, ie, he], placeable: !0, offscreen: this.isOffscreen(ee, ne, ie, he) };
        }
        placeCollisionCircles(e, r, s, l, h, y, b, I, k, z, M, O, U, B, G, Q) {
          const ee = [], ne = new c.P(r.anchorX, r.anchorY), ie = this.getPerspectiveRatio(y, ne.x, ne.y, b, Q), he = (M ? h / ie : h * ie) / c.ap, we = { getElevation: Q, labelPlaneMatrix: I, lineVertexArray: s, pitchWithMap: M, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: ne, unwrappedTileID: b, width: this.transform.width, height: this.transform.height, translation: G }, ve = ce(he, l, r.lineOffsetX * he, r.lineOffsetY * he, !1, r, !1, we);
          let Ue = !1, nt = !1, ht = !0;
          if (ve) {
            const pt = 0.5 * U * ie + B, dt = new c.P(-100, -100), ut = new c.P(this.screenRightBoundary, this.screenBottomBoundary), ft = new Et(), Ot = ve.first, _t = ve.last;
            let vt = [];
            for (let ii = Ot.path.length - 1; ii >= 1; ii--) vt.push(Ot.path[ii]);
            for (let ii = 1; ii < _t.path.length; ii++) vt.push(_t.path[ii]);
            const Vt = 2.5 * pt;
            if (k) {
              const ii = this.projectPathToScreenSpace(vt, we, k);
              vt = ii.some((ci) => ci.signedDistanceFromCamera <= 0) ? [] : ii.map((ci) => ci.point);
            }
            let ni = [];
            if (vt.length > 0) {
              const ii = vt[0].clone(), ci = vt[0].clone();
              for (let xi = 1; xi < vt.length; xi++) ii.x = Math.min(ii.x, vt[xi].x), ii.y = Math.min(ii.y, vt[xi].y), ci.x = Math.max(ci.x, vt[xi].x), ci.y = Math.max(ci.y, vt[xi].y);
              ni = ii.x >= dt.x && ci.x <= ut.x && ii.y >= dt.y && ci.y <= ut.y ? [vt] : ci.x < dt.x || ii.x > ut.x || ci.y < dt.y || ii.y > ut.y ? [] : c.al([vt], dt.x, dt.y, ut.x, ut.y);
            }
            for (const ii of ni) {
              ft.reset(ii, 0.25 * pt);
              let ci = 0;
              ci = ft.length <= 0.5 * pt ? 1 : Math.ceil(ft.paddedLength / Vt) + 1;
              for (let xi = 0; xi < ci; xi++) {
                const Bi = xi / Math.max(ci - 1, 1), Qi = ft.lerp(Bi), zi = Qi.x + Jt, dr = Qi.y + Jt;
                ee.push(zi, dr, pt, 0);
                const Oi = zi - pt, or = dr - pt, wr = zi + pt, hn = dr + pt;
                if (ht = ht && this.isOffscreen(Oi, or, wr, hn), nt = nt || this.isInsideGrid(Oi, or, wr, hn), e !== "always" && this.grid.hitTestCircle(zi, dr, pt, e, O) && (Ue = !0, !z)) return { circles: [], offscreen: !1, collisionDetected: Ue };
              }
            }
          }
          return { circles: !z && Ue || !nt || ie < this.perspectiveRatioCutoff ? [] : ee, offscreen: ht, collisionDetected: Ue };
        }
        projectPathToScreenSpace(e, r, s) {
          return e.map((l) => ue(l.x, l.y, s, r.getElevation));
        }
        queryRenderedSymbols(e) {
          if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const r = [];
          let s = 1 / 0, l = 1 / 0, h = -1 / 0, y = -1 / 0;
          for (const z of e) {
            const M = new c.P(z.x + Jt, z.y + Jt);
            s = Math.min(s, M.x), l = Math.min(l, M.y), h = Math.max(h, M.x), y = Math.max(y, M.y), r.push(M);
          }
          const b = this.grid.query(s, l, h, y).concat(this.ignoredGrid.query(s, l, h, y)), I = {}, k = {};
          for (const z of b) {
            const M = z.key;
            if (I[M.bucketInstanceId] === void 0 && (I[M.bucketInstanceId] = {}), I[M.bucketInstanceId][M.featureIndex]) continue;
            const O = [new c.P(z.x1, z.y1), new c.P(z.x2, z.y1), new c.P(z.x2, z.y2), new c.P(z.x1, z.y2)];
            c.am(r, O) && (I[M.bucketInstanceId][M.featureIndex] = !0, k[M.bucketInstanceId] === void 0 && (k[M.bucketInstanceId] = []), k[M.bucketInstanceId].push(M.featureIndex));
          }
          return k;
        }
        insertCollisionBox(e, r, s, l, h, y) {
          (s ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: l, featureIndex: h, collisionGroupID: y, overlapMode: r }, e[0], e[1], e[2], e[3]);
        }
        insertCollisionCircles(e, r, s, l, h, y) {
          const b = s ? this.ignoredGrid : this.grid, I = { bucketInstanceId: l, featureIndex: h, collisionGroupID: y, overlapMode: r };
          for (let k = 0; k < e.length; k += 4) b.insertCircle(I, e[k], e[k + 1], e[k + 2]);
        }
        projectAndGetPerspectiveRatio(e, r, s, l, h) {
          let y;
          h ? (y = [r, s, h(r, s), 1], c.af(y, y, e)) : (y = [r, s, 0, 1], vi(y, y, e));
          const b = y[3];
          return { point: new c.P((y[0] / b + 1) / 2 * this.transform.width + Jt, (-y[1] / b + 1) / 2 * this.transform.height + Jt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / b * 0.5, isOccluded: !1, signedDistanceFromCamera: b };
        }
        getPerspectiveRatio(e, r, s, l, h) {
          const y = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(r, s, l, h) : ue(r, s, e, h);
          return 0.5 + this.transform.cameraToCenterDistance / y.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(e, r, s, l) {
          return s < Jt || e >= this.screenRightBoundary || l < Jt || r > this.screenBottomBoundary;
        }
        isInsideGrid(e, r, s, l) {
          return s >= 0 && e < this.gridRightBoundary && l >= 0 && r < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const e = c.an([]);
          return c.J(e, e, [-100, -100, 0]), e;
        }
        _projectCollisionBox(e, r, s, l, h, y, b, I, k, z) {
          let M = new c.P(1, 0), O = new c.P(0, 1);
          const U = new c.P(e.anchorPointX + b[0], e.anchorPointY + b[1]);
          if (y && !h) {
            const ht = this.projectAndGetPerspectiveRatio(s, U.x + 1, U.y, l, k).point.sub(I.point).unit(), pt = Math.atan(ht.y / ht.x) + (ht.x < 0 ? Math.PI : 0), dt = Math.sin(pt), ut = Math.cos(pt);
            M = new c.P(ut, dt), O = new c.P(-dt, ut);
          } else if (!y && h) {
            const ht = -this.transform.angle, pt = Math.sin(ht), dt = Math.cos(ht);
            M = new c.P(dt, pt), O = new c.P(-pt, dt);
          }
          let B = I.point, G = r;
          if (h) {
            B = U;
            const ht = this.transform.zoom - Math.floor(this.transform.zoom);
            G = Math.pow(2, -ht), G *= this.mapProjection.getPitchedTextCorrection(this.transform, U, l), z || (G *= c.ac(0.5 + I.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          z && (B = B.add(M.mult(z.x * G)).add(O.mult(z.y * G)));
          const Q = e.x1 * G, ee = e.x2 * G, ne = (Q + ee) / 2, ie = e.y1 * G, he = e.y2 * G, we = (ie + he) / 2, ve = [{ offsetX: Q, offsetY: ie }, { offsetX: ne, offsetY: ie }, { offsetX: ee, offsetY: ie }, { offsetX: ee, offsetY: we }, { offsetX: ee, offsetY: he }, { offsetX: ne, offsetY: he }, { offsetX: Q, offsetY: he }, { offsetX: Q, offsetY: we }];
          let Ue = [];
          for (const { offsetX: ht, offsetY: pt } of ve) Ue.push(new c.P(B.x + M.x * ht + O.x * pt, B.y + M.y * ht + O.y * pt));
          let nt = !1;
          if (h) {
            const ht = Ue.map((pt) => this.projectAndGetPerspectiveRatio(s, pt.x, pt.y, l, k));
            nt = ht.some((pt) => !pt.isOccluded), Ue = ht.map((pt) => pt.point);
          } else nt = !0;
          return { box: c.ao(Ue), allPointsOccluded: !nt };
        }
      }
      function pi(a, e, r) {
        return e * (c.X / (a.tileSize * Math.pow(2, r - a.tileID.overscaledZ)));
      }
      class Ui {
        constructor(e, r, s, l) {
          this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? r : -r))) : l && s ? 1 : 0, this.placed = s;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Fi {
        constructor(e, r, s, l, h) {
          this.text = new Ui(e ? e.text : null, r, s, h), this.icon = new Ui(e ? e.icon : null, r, l, h);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class li {
        constructor(e, r, s) {
          this.text = e, this.icon = r, this.skipFade = s;
        }
      }
      class Di {
        constructor() {
          this.invProjMatrix = c.H(), this.viewportMatrix = c.H(), this.circles = [];
        }
      }
      class Vi {
        constructor(e, r, s, l, h) {
          this.bucketInstanceId = e, this.featureIndex = r, this.sourceLayerIndex = s, this.bucketIndex = l, this.tileID = h;
        }
      }
      class hr {
        constructor(e) {
          this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[e]) {
            const r = ++this.maxGroupID;
            this.collisionGroups[e] = { ID: r, predicate: (s) => s.collisionGroupID === r };
          }
          return this.collisionGroups[e];
        }
      }
      function fr(a, e, r, s, l) {
        const { horizontalAlign: h, verticalAlign: y } = c.au(a);
        return new c.P(-(h - 0.5) * e + s[0] * l, -(y - 0.5) * r + s[1] * l);
      }
      class Ir {
        constructor(e, r, s, l, h, y) {
          this.transform = e.clone(), this.terrain = s, this.collisionIndex = new gi(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new hr(h), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = y, y && (y.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(e) {
          const r = this.terrain;
          return r ? (s, l) => r.getElevation(e, s, l) : null;
        }
        getBucketParts(e, r, s, l) {
          const h = s.getBucket(r), y = s.latestFeatureIndex;
          if (!h || !y || r.id !== h.layerIds[0]) return;
          const b = s.collisionBoxArray, I = h.layers[0].layout, k = h.layers[0].paint, z = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ), M = s.tileSize / c.X, O = s.tileID.toUnwrapped(), U = this.transform.calculatePosMatrix(O), B = I.get("text-pitch-alignment") === "map", G = I.get("text-rotation-alignment") === "map", Q = pi(s, 1, this.transform.zoom), ee = this.collisionIndex.mapProjection.translatePosition(this.transform, s, k.get("text-translate"), k.get("text-translate-anchor")), ne = this.collisionIndex.mapProjection.translatePosition(this.transform, s, k.get("icon-translate"), k.get("icon-translate-anchor")), ie = Cr(U, B, G, this.transform, Q);
          let he = null;
          if (B) {
            const ve = Er(U, B, G, this.transform, Q);
            he = c.L([], this.transform.labelPlaneMatrix, ve);
          }
          this.retainedQueryData[h.bucketInstanceId] = new Vi(h.bucketInstanceId, y, h.sourceLayerIndex, h.index, s.tileID);
          const we = { bucket: h, layout: I, translationText: ee, translationIcon: ne, posMatrix: U, unwrappedTileID: O, textLabelPlaneMatrix: ie, labelToScreenMatrix: he, scale: z, textPixelRatio: M, holdingForFade: s.holdingForFade(), collisionBoxArray: b, partiallyEvaluatedTextSize: c.ag(h.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(h.sourceID) };
          if (l) for (const ve of h.sortKeyRanges) {
            const { sortKey: Ue, symbolInstanceStart: nt, symbolInstanceEnd: ht } = ve;
            e.push({ sortKey: Ue, symbolInstanceStart: nt, symbolInstanceEnd: ht, parameters: we });
          }
          else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: h.symbolInstances.length, parameters: we });
        }
        attemptAnchorPlacement(e, r, s, l, h, y, b, I, k, z, M, O, U, B, G, Q, ee, ne, ie) {
          const he = c.aq[e.textAnchor], we = [e.textOffset0, e.textOffset1], ve = fr(he, s, l, we, h), Ue = this.collisionIndex.placeCollisionBox(r, O, I, k, z, b, y, Q, M.predicate, ie, ve);
          if ((!ne || this.collisionIndex.placeCollisionBox(ne, O, I, k, z, b, y, ee, M.predicate, ie, ve).placeable) && Ue.placeable) {
            let nt;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (nt = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[U.crossTileID] = { textOffset: we, width: s, height: l, anchor: he, textBoxScale: h, prevAnchor: nt }, this.markUsedJustification(B, he, U, G), B.allowVerticalPlacement && (this.markUsedOrientation(B, G, U), this.placedOrientations[U.crossTileID] = G), { shift: ve, placedGlyphBoxes: Ue };
          }
        }
        placeLayerBucketPart(e, r, s) {
          const { bucket: l, layout: h, translationText: y, translationIcon: b, posMatrix: I, unwrappedTileID: k, textLabelPlaneMatrix: z, labelToScreenMatrix: M, textPixelRatio: O, holdingForFade: U, collisionBoxArray: B, partiallyEvaluatedTextSize: G, collisionGroup: Q } = e.parameters, ee = h.get("text-optional"), ne = h.get("icon-optional"), ie = c.ar(h, "text-overlap", "text-allow-overlap"), he = ie === "always", we = c.ar(h, "icon-overlap", "icon-allow-overlap"), ve = we === "always", Ue = h.get("text-rotation-alignment") === "map", nt = h.get("text-pitch-alignment") === "map", ht = h.get("icon-text-fit") !== "none", pt = h.get("symbol-z-order") === "viewport-y", dt = he && (ve || !l.hasIconData() || ne), ut = ve && (he || !l.hasTextData() || ee);
          !l.collisionArrays && B && l.deserializeCollisionBoxes(B);
          const ft = this._getTerrainElevationFunc(this.retainedQueryData[l.bucketInstanceId].tileID), Ot = (_t, vt, Vt) => {
            var ni, ii;
            if (r[_t.crossTileID]) return;
            if (U) return void (this.placements[_t.crossTileID] = new li(!1, !1, !1));
            let ci = !1, xi = !1, Bi = !0, Qi = null, zi = { box: null, placeable: !1, offscreen: null }, dr = { box: null, placeable: !1, offscreen: null }, Oi = null, or = null, wr = null, hn = 0, kn = 0, er = 0;
            vt.textFeatureIndex ? hn = vt.textFeatureIndex : _t.useRuntimeCollisionCircles && (hn = _t.featureIndex), vt.verticalTextFeatureIndex && (kn = vt.verticalTextFeatureIndex);
            const go = vt.textBox;
            if (go) {
              const Jr = (yr) => {
                let Or = c.ah.horizontal;
                if (l.allowVerticalPlacement && !yr && this.prevPlacement) {
                  const Qr = this.prevPlacement.placedOrientations[_t.crossTileID];
                  Qr && (this.placedOrientations[_t.crossTileID] = Qr, Or = Qr, this.markUsedOrientation(l, Or, _t));
                }
                return Or;
              }, un = (yr, Or) => {
                if (l.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && vt.verticalTextBox) {
                  for (const Qr of l.writingModes) if (Qr === c.ah.vertical ? (zi = Or(), dr = zi) : zi = yr(), zi && zi.placeable) break;
                } else zi = yr();
              }, Dr = _t.textAnchorOffsetStartIndex, Kr = _t.textAnchorOffsetEndIndex;
              if (Kr === Dr) {
                const yr = (Or, Qr) => {
                  const Ti = this.collisionIndex.placeCollisionBox(Or, ie, O, I, k, nt, Ue, y, Q.predicate, ft);
                  return Ti && Ti.placeable && (this.markUsedOrientation(l, Qr, _t), this.placedOrientations[_t.crossTileID] = Qr), Ti;
                };
                un(() => yr(go, c.ah.horizontal), () => {
                  const Or = vt.verticalTextBox;
                  return l.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && Or ? yr(Or, c.ah.vertical) : { box: null, offscreen: null };
                }), Jr(zi && zi.placeable);
              } else {
                let yr = c.aq[(ii = (ni = this.prevPlacement) === null || ni === void 0 ? void 0 : ni.variableOffsets[_t.crossTileID]) === null || ii === void 0 ? void 0 : ii.anchor];
                const Or = (Ti, ks, yo) => {
                  const Gs = Ti.x2 - Ti.x1, xa = Ti.y2 - Ti.y1, $c = _t.textBoxScale, dc = ht && we === "never" ? ks : null;
                  let Cs = null, Ws = ie === "never" ? 1 : 2, bl = "never";
                  yr && Ws++;
                  for (let il = 0; il < Ws; il++) {
                    for (let wl = Dr; wl < Kr; wl++) {
                      const rl = l.textAnchorOffsets.get(wl);
                      if (yr && rl.textAnchor !== yr) continue;
                      const Hs = this.attemptAnchorPlacement(rl, Ti, Gs, xa, $c, Ue, nt, O, I, k, Q, bl, _t, l, yo, y, b, dc, ft);
                      if (Hs && (Cs = Hs.placedGlyphBoxes, Cs && Cs.placeable)) return ci = !0, Qi = Hs.shift, Cs;
                    }
                    yr ? yr = null : bl = ie;
                  }
                  return s && !Cs && (Cs = { box: this.collisionIndex.placeCollisionBox(go, "always", O, I, k, nt, Ue, y, Q.predicate, ft, new c.P(0, 0)).box, offscreen: !1, placeable: !1 }), Cs;
                };
                un(() => Or(go, vt.iconBox, c.ah.horizontal), () => {
                  const Ti = vt.verticalTextBox;
                  return l.allowVerticalPlacement && (!zi || !zi.placeable) && _t.numVerticalGlyphVertices > 0 && Ti ? Or(Ti, vt.verticalIconBox, c.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), zi && (ci = zi.placeable, Bi = zi.offscreen);
                const Qr = Jr(zi && zi.placeable);
                if (!ci && this.prevPlacement) {
                  const Ti = this.prevPlacement.variableOffsets[_t.crossTileID];
                  Ti && (this.variableOffsets[_t.crossTileID] = Ti, this.markUsedJustification(l, Ti.anchor, _t, Qr));
                }
              }
            }
            if (Oi = zi, ci = Oi && Oi.placeable, Bi = Oi && Oi.offscreen, _t.useRuntimeCollisionCircles) {
              const Jr = l.text.placedSymbolArray.get(_t.centerJustifiedTextSymbolIndex), un = c.ai(l.textSizeData, G, Jr), Dr = h.get("text-padding");
              or = this.collisionIndex.placeCollisionCircles(ie, Jr, l.lineVertexArray, l.glyphOffsetArray, un, I, k, z, M, s, nt, Q.predicate, _t.collisionCircleDiameter, Dr, y, ft), or.circles.length && or.collisionDetected && !s && c.w("Collisions detected, but collision boxes are not shown"), ci = he || or.circles.length > 0 && !or.collisionDetected, Bi = Bi && or.offscreen;
            }
            if (vt.iconFeatureIndex && (er = vt.iconFeatureIndex), vt.iconBox) {
              const Jr = (un) => this.collisionIndex.placeCollisionBox(un, we, O, I, k, nt, Ue, b, Q.predicate, ft, ht && Qi ? Qi : void 0);
              dr && dr.placeable && vt.verticalIconBox ? (wr = Jr(vt.verticalIconBox), xi = wr.placeable) : (wr = Jr(vt.iconBox), xi = wr.placeable), Bi = Bi && wr.offscreen;
            }
            const Cn = ee || _t.numHorizontalGlyphVertices === 0 && _t.numVerticalGlyphVertices === 0, tl = ne || _t.numIconVertices === 0;
            Cn || tl ? tl ? Cn || (xi = xi && ci) : ci = xi && ci : xi = ci = xi && ci;
            const va = xi && wr.placeable;
            if (ci && Oi.placeable && this.collisionIndex.insertCollisionBox(Oi.box, ie, h.get("text-ignore-placement"), l.bucketInstanceId, dr && dr.placeable && kn ? kn : hn, Q.ID), va && this.collisionIndex.insertCollisionBox(wr.box, we, h.get("icon-ignore-placement"), l.bucketInstanceId, er, Q.ID), or && ci && this.collisionIndex.insertCollisionCircles(or.circles, ie, h.get("text-ignore-placement"), l.bucketInstanceId, hn, Q.ID), s && this.storeCollisionData(l.bucketInstanceId, Vt, vt, Oi, wr, or), _t.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (l.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[_t.crossTileID] = new li(ci || dt, xi || ut, Bi || l.justReloaded), r[_t.crossTileID] = !0;
          };
          if (pt) {
            if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const _t = l.getSortedSymbolIndexes(this.transform.angle);
            for (let vt = _t.length - 1; vt >= 0; --vt) {
              const Vt = _t[vt];
              Ot(l.symbolInstances.get(Vt), l.collisionArrays[Vt], Vt);
            }
          } else for (let _t = e.symbolInstanceStart; _t < e.symbolInstanceEnd; _t++) Ot(l.symbolInstances.get(_t), l.collisionArrays[_t], _t);
          if (s && l.bucketInstanceId in this.collisionCircleArrays) {
            const _t = this.collisionCircleArrays[l.bucketInstanceId];
            c.as(_t.invProjMatrix, I), _t.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          l.justReloaded = !1;
        }
        storeCollisionData(e, r, s, l, h, y) {
          if (s.textBox || s.iconBox) {
            let b, I;
            this.collisionBoxArrays.has(e) ? b = this.collisionBoxArrays.get(e) : (b = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, b)), b.has(r) ? I = b.get(r) : (I = { text: null, icon: null }, b.set(r, I)), s.textBox && (I.text = l.box), s.iconBox && (I.icon = h.box);
          }
          if (y) {
            let b = this.collisionCircleArrays[e];
            b === void 0 && (b = this.collisionCircleArrays[e] = new Di());
            for (let I = 0; I < y.circles.length; I += 4) b.circles.push(y.circles[I + 0]), b.circles.push(y.circles[I + 1]), b.circles.push(y.circles[I + 2]), b.circles.push(y.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(e, r, s, l) {
          let h;
          h = l === c.ah.vertical ? s.verticalPlacedTextSymbolIndex : { left: s.leftJustifiedTextSymbolIndex, center: s.centerJustifiedTextSymbolIndex, right: s.rightJustifiedTextSymbolIndex }[c.at(r)];
          const y = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
          for (const b of y) b >= 0 && (e.text.placedSymbolArray.get(b).crossTileID = h >= 0 && b !== h ? 0 : s.crossTileID);
        }
        markUsedOrientation(e, r, s) {
          const l = r === c.ah.horizontal || r === c.ah.horizontalOnly ? r : 0, h = r === c.ah.vertical ? r : 0, y = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
          for (const b of y) e.text.placedSymbolArray.get(b).placedOrientation = l;
          s.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = h);
        }
        commit(e) {
          this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const r = this.prevPlacement;
          let s = !1;
          this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
          const l = r ? r.symbolFadeChange(e) : 1, h = r ? r.opacities : {}, y = r ? r.variableOffsets : {}, b = r ? r.placedOrientations : {};
          for (const I in this.placements) {
            const k = this.placements[I], z = h[I];
            z ? (this.opacities[I] = new Fi(z, l, k.text, k.icon), s = s || k.text !== z.text.placed || k.icon !== z.icon.placed) : (this.opacities[I] = new Fi(null, l, k.text, k.icon, k.skipFade), s = s || k.text || k.icon);
          }
          for (const I in h) {
            const k = h[I];
            if (!this.opacities[I]) {
              const z = new Fi(k, l, !1, !1);
              z.isHidden() || (this.opacities[I] = z, s = s || k.text.placed || k.icon.placed);
            }
          }
          for (const I in y) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = y[I]);
          for (const I in b) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = b[I]);
          if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          s ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : e);
        }
        updateLayerOpacities(e, r) {
          const s = {};
          for (const l of r) {
            const h = l.getBucket(e);
            h && l.latestFeatureIndex && e.id === h.layerIds[0] && this.updateBucketOpacities(h, l.tileID, s, l.collisionBoxArray);
          }
        }
        updateBucketOpacities(e, r, s, l) {
          e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
          const h = e.layers[0], y = h.layout, b = new Fi(null, 0, !1, !1, !0), I = y.get("text-allow-overlap"), k = y.get("icon-allow-overlap"), z = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), M = y.get("text-rotation-alignment") === "map", O = y.get("text-pitch-alignment") === "map", U = y.get("icon-text-fit") !== "none", B = new Fi(null, 0, I && (k || !e.hasIconData() || y.get("icon-optional")), k && (I || !e.hasTextData() || y.get("text-optional")), !0);
          !e.collisionArrays && l && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(l);
          const G = (ee, ne, ie) => {
            for (let he = 0; he < ne / 4; he++) ee.opacityVertexArray.emplaceBack(ie);
            ee.hasVisibleVertices = ee.hasVisibleVertices || ie !== to;
          }, Q = this.collisionBoxArrays.get(e.bucketInstanceId);
          for (let ee = 0; ee < e.symbolInstances.length; ee++) {
            const ne = e.symbolInstances.get(ee), { numHorizontalGlyphVertices: ie, numVerticalGlyphVertices: he, crossTileID: we } = ne;
            let ve = this.opacities[we];
            s[we] ? ve = b : ve || (ve = B, this.opacities[we] = ve), s[we] = !0;
            const Ue = ne.numIconVertices > 0, nt = this.placedOrientations[ne.crossTileID], ht = nt === c.ah.vertical, pt = nt === c.ah.horizontal || nt === c.ah.horizontalOnly;
            if (ie > 0 || he > 0) {
              const ut = Gr(ve.text);
              G(e.text, ie, ht ? to : ut), G(e.text, he, pt ? to : ut);
              const ft = ve.text.isHidden();
              [ne.rightJustifiedTextSymbolIndex, ne.centerJustifiedTextSymbolIndex, ne.leftJustifiedTextSymbolIndex].forEach((vt) => {
                vt >= 0 && (e.text.placedSymbolArray.get(vt).hidden = ft || ht ? 1 : 0);
              }), ne.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ne.verticalPlacedTextSymbolIndex).hidden = ft || pt ? 1 : 0);
              const Ot = this.variableOffsets[ne.crossTileID];
              Ot && this.markUsedJustification(e, Ot.anchor, ne, nt);
              const _t = this.placedOrientations[ne.crossTileID];
              _t && (this.markUsedJustification(e, "left", ne, _t), this.markUsedOrientation(e, _t, ne));
            }
            if (Ue) {
              const ut = Gr(ve.icon), ft = !(U && ne.verticalPlacedIconSymbolIndex && ht);
              ne.placedIconSymbolIndex >= 0 && (G(e.icon, ne.numIconVertices, ft ? ut : to), e.icon.placedSymbolArray.get(ne.placedIconSymbolIndex).hidden = ve.icon.isHidden()), ne.verticalPlacedIconSymbolIndex >= 0 && (G(e.icon, ne.numVerticalIconVertices, ft ? to : ut), e.icon.placedSymbolArray.get(ne.verticalPlacedIconSymbolIndex).hidden = ve.icon.isHidden());
            }
            const dt = Q && Q.has(ee) ? Q.get(ee) : { text: null, icon: null };
            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
              const ut = e.collisionArrays[ee];
              if (ut) {
                let ft = new c.P(0, 0);
                if (ut.textBox || ut.verticalTextBox) {
                  let Ot = !0;
                  if (z) {
                    const _t = this.variableOffsets[we];
                    _t ? (ft = fr(_t.anchor, _t.width, _t.height, _t.textOffset, _t.textBoxScale), M && ft._rotate(O ? this.transform.angle : -this.transform.angle)) : Ot = !1;
                  }
                  if (ut.textBox || ut.verticalTextBox) {
                    let _t;
                    ut.textBox && (_t = ht), ut.verticalTextBox && (_t = pt), Ns(e.textCollisionBox.collisionVertexArray, ve.text.placed, !Ot || _t, dt.text, ft.x, ft.y);
                  }
                }
                if (ut.iconBox || ut.verticalIconBox) {
                  const Ot = !!(!pt && ut.verticalIconBox);
                  let _t;
                  ut.iconBox && (_t = Ot), ut.verticalIconBox && (_t = !Ot), Ns(e.iconCollisionBox.collisionVertexArray, ve.icon.placed, _t, dt.icon, U ? ft.x : 0, U ? ft.y : 0);
                }
              }
            }
          }
          if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
          if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
          if (e.bucketInstanceId in this.collisionCircleArrays) {
            const ee = this.collisionCircleArrays[e.bucketInstanceId];
            e.placementInvProjMatrix = ee.invProjMatrix, e.placementViewportMatrix = ee.viewportMatrix, e.collisionCircleArray = ee.circles, delete this.collisionCircleArrays[e.bucketInstanceId];
          }
        }
        symbolFadeChange(e) {
          return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e) {
          return Math.max(0, (this.transform.zoom - e) / 1.5);
        }
        hasTransitions(e) {
          return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e, r) {
          const s = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
          return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * s > e;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Ns(a, e, r, s, l, h) {
        s && s.length !== 0 || (s = [0, 0, 0, 0]);
        const y = s[0] - Jt, b = s[1] - Jt, I = s[2] - Jt, k = s[3] - Jt;
        a.emplaceBack(e ? 1 : 0, r ? 1 : 0, l || 0, h || 0, y, b), a.emplaceBack(e ? 1 : 0, r ? 1 : 0, l || 0, h || 0, I, b), a.emplaceBack(e ? 1 : 0, r ? 1 : 0, l || 0, h || 0, I, k), a.emplaceBack(e ? 1 : 0, r ? 1 : 0, l || 0, h || 0, y, k);
      }
      const Ri = Math.pow(2, 25), Na = Math.pow(2, 24), eo = Math.pow(2, 17), Zr = Math.pow(2, 16), nn = Math.pow(2, 9), Fa = Math.pow(2, 8), pn = Math.pow(2, 1);
      function Gr(a) {
        if (a.opacity === 0 && !a.placed) return 0;
        if (a.opacity === 1 && a.placed) return 4294967295;
        const e = a.placed ? 1 : 0, r = Math.floor(127 * a.opacity);
        return r * Ri + e * Na + r * eo + e * Zr + r * nn + e * Fa + r * pn + e;
      }
      const to = 0;
      function Dn() {
        return { isOccluded: (a, e, r) => !1, getPitchedTextCorrection: (a, e, r) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(a, e, r, s) {
          throw new Error("Not implemented.");
        }, translatePosition: (a, e, r, s) => function(l, h, y, b, I = !1) {
          if (!y[0] && !y[1]) return [0, 0];
          const k = I ? b === "map" ? l.angle : 0 : b === "viewport" ? -l.angle : 0;
          if (k) {
            const z = Math.sin(k), M = Math.cos(k);
            y = [y[0] * M - y[1] * z, y[0] * z + y[1] * M];
          }
          return [I ? y[0] : pi(h, y[0], l.zoom), I ? y[1] : pi(h, y[1], l.zoom)];
        }(a, e, r, s), getCircleRadiusCorrection: (a) => 1 };
      }
      class mr {
        constructor(e) {
          this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e, r, s, l, h) {
          const y = this._bucketParts;
          for (; this._currentTileIndex < e.length; ) if (r.getBucketParts(y, l, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, h()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, y.sort((b, I) => b.sortKey - I.sortKey)); this._currentPartIndex < y.length; ) if (r.placeLayerBucketPart(y[this._currentPartIndex], this._seenCrossTileIDs, s), this._currentPartIndex++, h()) return !0;
          return !1;
        }
      }
      class Ji {
        constructor(e, r, s, l, h, y, b, I) {
          this.placement = new Ir(e, Dn(), r, y, b, I), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = l, this._showCollisionBoxes = h, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e, r, s) {
          const l = j.now(), h = () => !this._forceFullPlacement && j.now() - l > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const y = r[e[this._currentPlacementIndex]], b = this.placement.collisionIndex.transform.zoom;
            if (y.type === "symbol" && (!y.minzoom || y.minzoom <= b) && (!y.maxzoom || y.maxzoom > b)) {
              if (this._inProgressLayer || (this._inProgressLayer = new mr(y)), this._inProgressLayer.continuePlacement(s[y.source], this.placement, this._showCollisionBoxes, y, h)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(e) {
          return this.placement.commit(e), this.placement;
        }
      }
      const fn = 512 / c.X / 2;
      class nr {
        constructor(e, r, s) {
          this.tileID = e, this.bucketInstanceId = s, this._symbolsByKey = {};
          const l = /* @__PURE__ */ new Map();
          for (let h = 0; h < r.length; h++) {
            const y = r.get(h), b = y.key, I = l.get(b);
            I ? I.push(y) : l.set(b, [y]);
          }
          for (const [h, y] of l) {
            const b = { positions: y.map((I) => ({ x: Math.floor(I.anchorX * fn), y: Math.floor(I.anchorY * fn) })), crossTileIDs: y.map((I) => I.crossTileID) };
            if (b.positions.length > 128) {
              const I = new c.av(b.positions.length, 16, Uint16Array);
              for (const { x: k, y: z } of b.positions) I.add(k, z);
              I.finish(), delete b.positions, b.index = I;
            }
            this._symbolsByKey[h] = b;
          }
        }
        getScaledCoordinates(e, r) {
          const { x: s, y: l, z: h } = this.tileID.canonical, { x: y, y: b, z: I } = r.canonical, k = fn / Math.pow(2, I - h), z = (b * c.X + e.anchorY) * k, M = l * c.X * fn;
          return { x: Math.floor((y * c.X + e.anchorX) * k - s * c.X * fn), y: Math.floor(z - M) };
        }
        findMatches(e, r, s) {
          const l = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
          for (let h = 0; h < e.length; h++) {
            const y = e.get(h);
            if (y.crossTileID) continue;
            const b = this._symbolsByKey[y.key];
            if (!b) continue;
            const I = this.getScaledCoordinates(y, r);
            if (b.index) {
              const k = b.index.range(I.x - l, I.y - l, I.x + l, I.y + l).sort();
              for (const z of k) {
                const M = b.crossTileIDs[z];
                if (!s[M]) {
                  s[M] = !0, y.crossTileID = M;
                  break;
                }
              }
            } else if (b.positions) for (let k = 0; k < b.positions.length; k++) {
              const z = b.positions[k], M = b.crossTileIDs[k];
              if (Math.abs(z.x - I.x) <= l && Math.abs(z.y - I.y) <= l && !s[M]) {
                s[M] = !0, y.crossTileID = M;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e);
        }
      }
      class So {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class sn {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e) {
          const r = Math.round((e - this.lng) / 360);
          if (r !== 0) for (const s in this.indexes) {
            const l = this.indexes[s], h = {};
            for (const y in l) {
              const b = l[y];
              b.tileID = b.tileID.unwrapTo(b.tileID.wrap + r), h[b.tileID.key] = b;
            }
            this.indexes[s] = h;
          }
          this.lng = e;
        }
        addBucket(e, r, s) {
          if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === r.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
          }
          for (let h = 0; h < r.symbolInstances.length; h++) r.symbolInstances.get(h).crossTileID = 0;
          this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
          const l = this.usedCrossTileIDs[e.overscaledZ];
          for (const h in this.indexes) {
            const y = this.indexes[h];
            if (Number(h) > e.overscaledZ) for (const b in y) {
              const I = y[b];
              I.tileID.isChildOf(e) && I.findMatches(r.symbolInstances, e, l);
            }
            else {
              const b = y[e.scaledTo(Number(h)).key];
              b && b.findMatches(r.symbolInstances, e, l);
            }
          }
          for (let h = 0; h < r.symbolInstances.length; h++) {
            const y = r.symbolInstances.get(h);
            y.crossTileID || (y.crossTileID = s.generate(), l[y.crossTileID] = !0);
          }
          return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new nr(e, r.symbolInstances, r.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(e, r) {
          for (const s of r.getCrossTileIDsLists()) for (const l of s) delete this.usedCrossTileIDs[e][l];
        }
        removeStaleBuckets(e) {
          let r = !1;
          for (const s in this.indexes) {
            const l = this.indexes[s];
            for (const h in l) e[l[h].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, l[h]), delete l[h], r = !0);
          }
          return r;
        }
      }
      class Ra {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new So(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e, r, s) {
          let l = this.layerIndexes[e.id];
          l === void 0 && (l = this.layerIndexes[e.id] = new sn());
          let h = !1;
          const y = {};
          l.handleWrapJump(s);
          for (const b of r) {
            const I = b.getBucket(e);
            I && e.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), l.addBucket(b.tileID, I, this.crossTileIDs) && (h = !0), y[I.bucketInstanceId] = !0);
          }
          return l.removeStaleBuckets(y) && (h = !0), h;
        }
        pruneUnusedLayers(e) {
          const r = {};
          e.forEach((s) => {
            r[s] = !0;
          });
          for (const s in this.layerIndexes) r[s] || delete this.layerIndexes[s];
        }
      }
      const _r = (a, e) => c.t(a, e && e.filter((r) => r.identifier !== "source.canvas")), Wo = c.aw();
      class Fr extends c.E {
        constructor(e, r = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const s in this.sourceCaches) {
              const l = this.sourceCaches[s].getSource().type;
              l !== "vector" && l !== "geojson" || this.sourceCaches[s].reload();
            }
          }, this.map = e, this.dispatcher = new wt(Ze(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (s, l) => this.getGlyphs(s, l)), this.dispatcher.registerMessageHandler("GI", (s, l) => this.getImages(s, l)), this.imageManager = new Le(), this.imageManager.setEventedParent(this), this.glyphManager = new Je(e._requestManager, r.localIdeographFontFamily), this.lineAtlas = new fe(256, 512), this.crossTileSymbolIndex = new Ra(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.ay()), It().on(lt, this._rtlPluginLoaded), this.on("data", (s) => {
            if (s.dataType !== "source" || s.sourceDataType !== "metadata") return;
            const l = this.sourceCaches[s.sourceId];
            if (!l) return;
            const h = l.getSource();
            if (h && h.vectorLayerIds) for (const y in this._layers) {
              const b = this._layers[y];
              b.source === h.id && this._validateLayer(b);
            }
          });
        }
        loadURL(e, r = {}, s) {
          this.fire(new c.k("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
          const l = this.map._requestManager.transformRequest(e, "Style");
          this._loadStyleRequest = new AbortController();
          const h = this._loadStyleRequest;
          c.h(l, this._loadStyleRequest).then((y) => {
            this._loadStyleRequest = null, this._load(y.data, r, s);
          }).catch((y) => {
            this._loadStyleRequest = null, y && !h.signal.aborted && this.fire(new c.j(y));
          });
        }
        loadJSON(e, r = {}, s) {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), j.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, r.validate = r.validate !== !1, this._load(e, r, s);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._load(Wo, { validate: !1 });
        }
        _load(e, r, s) {
          var l;
          const h = r.transformStyle ? r.transformStyle(s, e) : e;
          if (!r.validate || !_r(this, c.u(h))) {
            this._loaded = !0, this.stylesheet = h;
            for (const y in h.sources) this.addSource(y, h.sources[y], { validate: !1 });
            h.sprite ? this._loadSprite(h.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(h.glyphs), this._createLayers(), this.light = new Ke(this.stylesheet.light), this.sky = new J(this.stylesheet.sky), this.map.setTerrain((l = this.stylesheet.terrain) !== null && l !== void 0 ? l : null), this.fire(new c.k("data", { dataType: "style" })), this.fire(new c.k("style.load"));
          }
        }
        _createLayers() {
          const e = c.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", e), this._order = e.map((r) => r.id), this._layers = {}, this._serializedLayers = null;
          for (const r of e) {
            const s = c.aA(r);
            s.setEventedParent(this, { layer: { id: r.id } }), this._layers[r.id] = s;
          }
        }
        _loadSprite(e, r = !1, s = void 0) {
          let l;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(h, y, b, I) {
            return c._(this, void 0, void 0, function* () {
              const k = ot(h), z = b > 1 ? "@2x" : "", M = {}, O = {};
              for (const { id: U, url: B } of k) {
                const G = y.transformRequest(it(B, z, ".json"), "SpriteJSON");
                M[U] = c.h(G, I);
                const Q = y.transformRequest(it(B, z, ".png"), "SpriteImage");
                O[U] = Me.getImage(Q, I);
              }
              return yield Promise.all([...Object.values(M), ...Object.values(O)]), function(U, B) {
                return c._(this, void 0, void 0, function* () {
                  const G = {};
                  for (const Q in U) {
                    G[Q] = {};
                    const ee = j.getImageCanvasContext((yield B[Q]).data), ne = (yield U[Q]).data;
                    for (const ie in ne) {
                      const { width: he, height: we, x: ve, y: Ue, sdf: nt, pixelRatio: ht, stretchX: pt, stretchY: dt, content: ut, textFitWidth: ft, textFitHeight: Ot } = ne[ie];
                      G[Q][ie] = { data: null, pixelRatio: ht, sdf: nt, stretchX: pt, stretchY: dt, content: ut, textFitWidth: ft, textFitHeight: Ot, spriteData: { width: he, height: we, x: ve, y: Ue, context: ee } };
                    }
                  }
                  return G;
                });
              }(M, O);
            });
          }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((h) => {
            if (this._spriteRequest = null, h) for (const y in h) {
              this._spritesImagesIds[y] = [];
              const b = this._spritesImagesIds[y] ? this._spritesImagesIds[y].filter((I) => !(I in h)) : [];
              for (const I of b) this.imageManager.removeImage(I), this._changedImages[I] = !0;
              for (const I in h[y]) {
                const k = y === "default" ? I : `${y}:${I}`;
                this._spritesImagesIds[y].push(k), k in this.imageManager.images ? this.imageManager.updateImage(k, h[y][I], !1) : this.imageManager.addImage(k, h[y][I]), r && (this._changedImages[k] = !0);
              }
            }
          }).catch((h) => {
            this._spriteRequest = null, l = h, this.fire(new c.j(l));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" })), s && s(l);
          });
        }
        _unloadSprite() {
          for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        _validateLayer(e) {
          const r = this.sourceCaches[e.source];
          if (!r) return;
          const s = e.sourceLayer;
          if (!s) return;
          const l = r.getSource();
          (l.type === "geojson" || l.vectorLayerIds && l.vectorLayerIds.indexOf(s) === -1) && this.fire(new c.j(new Error(`Source layer "${s}" does not exist on source "${l.id}" as specified by style layer "${e.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(e, r = !1) {
          const s = this._serializedAllLayers();
          if (!e || e.length === 0) return Object.values(r ? c.aB(s) : s);
          const l = [];
          for (const h of e) if (s[h]) {
            const y = r ? c.aB(s[h]) : s[h];
            l.push(y);
          }
          return l;
        }
        _serializedAllLayers() {
          let e = this._serializedLayers;
          if (e) return e;
          e = this._serializedLayers = {};
          const r = Object.keys(this._layers);
          for (const s of r) {
            const l = this._layers[s];
            l.type !== "custom" && (e[s] = l.serialize());
          }
          return e;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
          for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(e) {
          if (!this._loaded) return;
          const r = this._changed;
          if (r) {
            const l = Object.keys(this._updatedLayers), h = Object.keys(this._removedLayers);
            (l.length || h.length) && this._updateWorkerLayers(l, h);
            for (const y in this._updatedSources) {
              const b = this._updatedSources[y];
              if (b === "reload") this._reloadSource(y);
              else {
                if (b !== "clear") throw new Error(`Invalid action ${b}`);
                this._clearSource(y);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const y in this._updatedPaintProps) this._layers[y].updateTransitions(e);
            this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
          }
          const s = {};
          for (const l in this.sourceCaches) {
            const h = this.sourceCaches[l];
            s[l] = h.used, h.used = !1;
          }
          for (const l of this._order) {
            const h = this._layers[l];
            h.recalculate(e, this._availableImages), !h.isHidden(e.zoom) && h.source && (this.sourceCaches[h.source].used = !0);
          }
          for (const l in s) {
            const h = this.sourceCaches[l];
            !!s[l] != !!h.used && h.fire(new c.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: l }));
          }
          this.light.recalculate(e), this.sky.recalculate(e), this.z = e.zoom, r && this.fire(new c.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e = Object.keys(this._changedImages);
          if (e.length) {
            for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], e);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(e, r) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: r });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(e, r = {}) {
          var s;
          this._checkLoaded();
          const l = this.serialize();
          if (e = r.transformStyle ? r.transformStyle(l, e) : e, ((s = r.validate) === null || s === void 0 || s) && _r(this, c.u(e))) return !1;
          (e = c.aB(e)).layers = c.az(e.layers);
          const h = c.aC(l, e), y = this._getOperationsToPerform(h);
          if (y.unimplemented.length > 0) throw new Error(`Unimplemented: ${y.unimplemented.join(", ")}.`);
          if (y.operations.length === 0) return !1;
          for (const b of y.operations) b();
          return this.stylesheet = e, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(e) {
          const r = [], s = [];
          for (const l of e) switch (l.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              r.push(() => this.addLayer.apply(this, l.args));
              break;
            case "removeLayer":
              r.push(() => this.removeLayer.apply(this, l.args));
              break;
            case "setPaintProperty":
              r.push(() => this.setPaintProperty.apply(this, l.args));
              break;
            case "setLayoutProperty":
              r.push(() => this.setLayoutProperty.apply(this, l.args));
              break;
            case "setFilter":
              r.push(() => this.setFilter.apply(this, l.args));
              break;
            case "addSource":
              r.push(() => this.addSource.apply(this, l.args));
              break;
            case "removeSource":
              r.push(() => this.removeSource.apply(this, l.args));
              break;
            case "setLayerZoomRange":
              r.push(() => this.setLayerZoomRange.apply(this, l.args));
              break;
            case "setLight":
              r.push(() => this.setLight.apply(this, l.args));
              break;
            case "setGeoJSONSourceData":
              r.push(() => this.setGeoJSONSourceData.apply(this, l.args));
              break;
            case "setGlyphs":
              r.push(() => this.setGlyphs.apply(this, l.args));
              break;
            case "setSprite":
              r.push(() => this.setSprite.apply(this, l.args));
              break;
            case "setSky":
              r.push(() => this.setSky.apply(this, l.args));
              break;
            case "setTerrain":
              r.push(() => this.map.setTerrain.apply(this, l.args));
              break;
            case "setTransition":
              r.push(() => {
              });
              break;
            default:
              s.push(l.command);
          }
          return { operations: r, unimplemented: s };
        }
        addImage(e, r) {
          if (this.getImage(e)) return this.fire(new c.j(new Error(`An image named "${e}" already exists.`)));
          this.imageManager.addImage(e, r), this._afterImageUpdated(e);
        }
        updateImage(e, r) {
          this.imageManager.updateImage(e, r);
        }
        getImage(e) {
          return this.imageManager.getImage(e);
        }
        removeImage(e) {
          if (!this.getImage(e)) return this.fire(new c.j(new Error(`An image named "${e}" does not exist.`)));
          this.imageManager.removeImage(e), this._afterImageUpdated(e);
        }
        _afterImageUpdated(e) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e, r, s = {}) {
          if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
          if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(c.u.source, `sources.${e}`, r, null, s)) return;
          this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
          const l = this.sourceCaches[e] = new kt(e, r, this.dispatcher);
          l.style = this, l.setEventedParent(this, () => ({ isSourceLoaded: l.loaded(), source: l.serialize(), sourceId: e })), l.onAdd(this.map), this._changed = !0;
        }
        removeSource(e) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
          for (const s in this._layers) if (this._layers[s].source === e) return this.fire(new c.j(new Error(`Source "${e}" cannot be removed while layer "${s}" is using it.`)));
          const r = this.sourceCaches[e];
          delete this.sourceCaches[e], delete this._updatedSources[e], r.fire(new c.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(e, r) {
          if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
          const s = this.sourceCaches[e].getSource();
          if (s.type !== "geojson") throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
          s.setData(r), this._changed = !0;
        }
        getSource(e) {
          return this.sourceCaches[e] && this.sourceCaches[e].getSource();
        }
        addLayer(e, r, s = {}) {
          this._checkLoaded();
          const l = e.id;
          if (this.getLayer(l)) return void this.fire(new c.j(new Error(`Layer "${l}" already exists on this map.`)));
          let h;
          if (e.type === "custom") {
            if (_r(this, c.aD(e))) return;
            h = c.aA(e);
          } else {
            if ("source" in e && typeof e.source == "object" && (this.addSource(l, e.source), e = c.aB(e), e = c.e(e, { source: l })), this._validate(c.u.layer, `layers.${l}`, e, { arrayIndex: -1 }, s)) return;
            h = c.aA(e), this._validateLayer(h), h.setEventedParent(this, { layer: { id: l } });
          }
          const y = r ? this._order.indexOf(r) : this._order.length;
          if (r && y === -1) this.fire(new c.j(new Error(`Cannot add layer "${l}" before non-existing layer "${r}".`)));
          else {
            if (this._order.splice(y, 0, l), this._layerOrderChanged = !0, this._layers[l] = h, this._removedLayers[l] && h.source && h.type !== "custom") {
              const b = this._removedLayers[l];
              delete this._removedLayers[l], b.type !== h.type ? this._updatedSources[h.source] = "clear" : (this._updatedSources[h.source] = "reload", this.sourceCaches[h.source].pause());
            }
            this._updateLayer(h), h.onAdd && h.onAdd(this.map);
          }
        }
        moveLayer(e, r) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new c.j(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
          if (e === r) return;
          const s = this._order.indexOf(e);
          this._order.splice(s, 1);
          const l = r ? this._order.indexOf(r) : this._order.length;
          r && l === -1 ? this.fire(new c.j(new Error(`Cannot move layer "${e}" before non-existing layer "${r}".`))) : (this._order.splice(l, 0, e), this._layerOrderChanged = !0);
        }
        removeLayer(e) {
          this._checkLoaded();
          const r = this._layers[e];
          if (!r) return void this.fire(new c.j(new Error(`Cannot remove non-existing layer "${e}".`)));
          r.setEventedParent(null);
          const s = this._order.indexOf(e);
          this._order.splice(s, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = r, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], r.onRemove && r.onRemove(this.map);
        }
        getLayer(e) {
          return this._layers[e];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(e) {
          return e in this._layers;
        }
        setLayerZoomRange(e, r, s) {
          this._checkLoaded();
          const l = this.getLayer(e);
          l ? l.minzoom === r && l.maxzoom === s || (r != null && (l.minzoom = r), s != null && (l.maxzoom = s), this._updateLayer(l)) : this.fire(new c.j(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
        }
        setFilter(e, r, s = {}) {
          this._checkLoaded();
          const l = this.getLayer(e);
          if (l) {
            if (!c.aE(l.filter, r)) return r == null ? (l.filter = void 0, void this._updateLayer(l)) : void (this._validate(c.u.filter, `layers.${l.id}.filter`, r, null, s) || (l.filter = c.aB(r), this._updateLayer(l)));
          } else this.fire(new c.j(new Error(`Cannot filter non-existing layer "${e}".`)));
        }
        getFilter(e) {
          return c.aB(this.getLayer(e).filter);
        }
        setLayoutProperty(e, r, s, l = {}) {
          this._checkLoaded();
          const h = this.getLayer(e);
          h ? c.aE(h.getLayoutProperty(r), s) || (h.setLayoutProperty(r, s, l), this._updateLayer(h)) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getLayoutProperty(e, r) {
          const s = this.getLayer(e);
          if (s) return s.getLayoutProperty(r);
          this.fire(new c.j(new Error(`Cannot get style of non-existing layer "${e}".`)));
        }
        setPaintProperty(e, r, s, l = {}) {
          this._checkLoaded();
          const h = this.getLayer(e);
          h ? c.aE(h.getPaintProperty(r), s) || (h.setPaintProperty(r, s, l) && this._updateLayer(h), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${e}".`)));
        }
        getPaintProperty(e, r) {
          return this.getLayer(e).getPaintProperty(r);
        }
        setFeatureState(e, r) {
          this._checkLoaded();
          const s = e.source, l = e.sourceLayer, h = this.sourceCaches[s];
          if (h === void 0) return void this.fire(new c.j(new Error(`The source '${s}' does not exist in the map's style.`)));
          const y = h.getSource().type;
          y === "geojson" && l ? this.fire(new c.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : y !== "vector" || l ? (e.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), h.setFeatureState(l, e.id, r)) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(e, r) {
          this._checkLoaded();
          const s = e.source, l = this.sourceCaches[s];
          if (l === void 0) return void this.fire(new c.j(new Error(`The source '${s}' does not exist in the map's style.`)));
          const h = l.getSource().type, y = h === "vector" ? e.sourceLayer : void 0;
          h !== "vector" || y ? r && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new c.j(new Error("A feature id is required to remove its specific state property."))) : l.removeFeatureState(y, e.id, r) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(e) {
          this._checkLoaded();
          const r = e.source, s = e.sourceLayer, l = this.sourceCaches[r];
          if (l !== void 0) return l.getSource().type !== "vector" || s ? (e.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), l.getFeatureState(s, e.id)) : void this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new c.j(new Error(`The source '${r}' does not exist in the map's style.`)));
        }
        getTransition() {
          return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const e = c.aF(this.sourceCaches, (h) => h.serialize()), r = this._serializeByIds(this._order, !0), s = this.map.getTerrain() || void 0, l = this.stylesheet;
          return c.aG({ version: l.version, name: l.name, metadata: l.metadata, light: l.light, sky: l.sky, center: l.center, zoom: l.zoom, bearing: l.bearing, pitch: l.pitch, sprite: l.sprite, glyphs: l.glyphs, transition: l.transition, sources: e, layers: r, terrain: s }, (h) => h !== void 0);
        }
        _updateLayer(e) {
          this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(e) {
          const r = (y) => this._layers[y].type === "fill-extrusion", s = {}, l = [];
          for (let y = this._order.length - 1; y >= 0; y--) {
            const b = this._order[y];
            if (r(b)) {
              s[b] = y;
              for (const I of e) {
                const k = I[b];
                if (k) for (const z of k) l.push(z);
              }
            }
          }
          l.sort((y, b) => b.intersectionZ - y.intersectionZ);
          const h = [];
          for (let y = this._order.length - 1; y >= 0; y--) {
            const b = this._order[y];
            if (r(b)) for (let I = l.length - 1; I >= 0; I--) {
              const k = l[I].feature;
              if (s[k.layer.id] < y) break;
              h.push(k), l.pop();
            }
            else for (const I of e) {
              const k = I[b];
              if (k) for (const z of k) h.push(z.feature);
            }
          }
          return h;
        }
        queryRenderedFeatures(e, r, s) {
          r && r.filter && this._validate(c.u.filter, "queryRenderedFeatures.filter", r.filter, null, r);
          const l = {};
          if (r && r.layers) {
            if (!Array.isArray(r.layers)) return this.fire(new c.j(new Error("parameters.layers must be an Array."))), [];
            for (const b of r.layers) {
              const I = this._layers[b];
              if (!I) return this.fire(new c.j(new Error(`The layer '${b}' does not exist in the map's style and cannot be queried for features.`))), [];
              l[I.source] = !0;
            }
          }
          const h = [];
          r.availableImages = this._availableImages;
          const y = this._serializedAllLayers();
          for (const b in this.sourceCaches) r.layers && !l[b] || h.push(Mt(this.sourceCaches[b], this._layers, y, e, r, s));
          return this.placement && h.push(function(b, I, k, z, M, O, U) {
            const B = {}, G = O.queryRenderedSymbols(z), Q = [];
            for (const ee of Object.keys(G).map(Number)) Q.push(U[ee]);
            Q.sort(Qt);
            for (const ee of Q) {
              const ne = ee.featureIndex.lookupSymbolFeatures(G[ee.bucketInstanceId], I, ee.bucketIndex, ee.sourceLayerIndex, M.filter, M.layers, M.availableImages, b);
              for (const ie in ne) {
                const he = B[ie] = B[ie] || [], we = ne[ie];
                we.sort((ve, Ue) => {
                  const nt = ee.featureSortOrder;
                  if (nt) {
                    const ht = nt.indexOf(ve.featureIndex);
                    return nt.indexOf(Ue.featureIndex) - ht;
                  }
                  return Ue.featureIndex - ve.featureIndex;
                });
                for (const ve of we) he.push(ve);
              }
            }
            for (const ee in B) B[ee].forEach((ne) => {
              const ie = ne.feature, he = k[b[ee].source].getFeatureState(ie.layer["source-layer"], ie.id);
              ie.source = ie.layer.source, ie.layer["source-layer"] && (ie.sourceLayer = ie.layer["source-layer"]), ie.state = he;
            });
            return B;
          }(this._layers, y, this.sourceCaches, e, r, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(h);
        }
        querySourceFeatures(e, r) {
          r && r.filter && this._validate(c.u.filter, "querySourceFeatures.filter", r.filter, null, r);
          const s = this.sourceCaches[e];
          return s ? function(l, h) {
            const y = l.getRenderableIds().map((k) => l.getTileByID(k)), b = [], I = {};
            for (let k = 0; k < y.length; k++) {
              const z = y[k], M = z.tileID.canonical.key;
              I[M] || (I[M] = !0, z.querySourceFeatures(b, h));
            }
            return b;
          }(s, r) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e, r = {}) {
          this._checkLoaded();
          const s = this.light.getLight();
          let l = !1;
          for (const y in e) if (!c.aE(e[y], s[y])) {
            l = !0;
            break;
          }
          if (!l) return;
          const h = { now: j.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e, r), this.light.updateTransitions(h);
        }
        getSky() {
          var e;
          return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
        }
        setSky(e, r = {}) {
          const s = this.getSky();
          let l = !1;
          if (!e && !s) return;
          if (e && !s) l = !0;
          else if (!e && s) l = !0;
          else for (const y in e) if (!c.aE(e[y], s[y])) {
            l = !0;
            break;
          }
          if (!l) return;
          const h = { now: j.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = e, this.sky.setSky(e, r), this.sky.updateTransitions(h);
        }
        _validate(e, r, s, l, h = {}) {
          return (!h || h.validate !== !1) && _r(this, e.call(c.u, c.e({ key: r, style: this.serialize(), value: s, styleSpec: c.v }, l)));
        }
        _remove(e = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), It().off(lt, this._rtlPluginLoaded);
          for (const r in this._layers) this._layers[r].setEventedParent(null);
          for (const r in this.sourceCaches) {
            const s = this.sourceCaches[r];
            s.setEventedParent(null), s.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
        }
        _clearSource(e) {
          this.sourceCaches[e].clearTiles();
        }
        _reloadSource(e) {
          this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
        }
        _updateSources(e) {
          for (const r in this.sourceCaches) this.sourceCaches[r].update(e, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const e in this.sourceCaches) this._reloadSource(e);
        }
        _updatePlacement(e, r, s, l, h = !1) {
          let y = !1, b = !1;
          const I = {};
          for (const k of this._order) {
            const z = this._layers[k];
            if (z.type !== "symbol") continue;
            if (!I[z.source]) {
              const O = this.sourceCaches[z.source];
              I[z.source] = O.getRenderableIds(!0).map((U) => O.getTileByID(U)).sort((U, B) => B.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(B.tileID) ? -1 : 1));
            }
            const M = this.crossTileSymbolIndex.addLayer(z, I[z.source], e.center.lng);
            y = y || M;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((h = h || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(j.now(), e.zoom)) && (this.pauseablePlacement = new Ji(e, this.map.terrain, this._order, h, r, s, l, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(j.now()), b = !0), y && this.pauseablePlacement.placement.setStale()), b || y) for (const k of this._order) {
            const z = this._layers[k];
            z.type === "symbol" && this.placement.updateLayerOpacities(z, I[z.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(j.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
        }
        getImages(e, r) {
          return c._(this, void 0, void 0, function* () {
            const s = yield this.imageManager.getImages(r.icons);
            this._updateTilesForChangedImages();
            const l = this.sourceCaches[r.source];
            return l && l.setDependencies(r.tileID.key, r.type, r.icons), s;
          });
        }
        getGlyphs(e, r) {
          return c._(this, void 0, void 0, function* () {
            const s = yield this.glyphManager.getGlyphs(r.stacks), l = this.sourceCaches[r.source];
            return l && l.setDependencies(r.tileID.key, r.type, [""]), s;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e, r = {}) {
          this._checkLoaded(), e && this._validate(c.u.glyphs, "glyphs", e, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
        }
        addSprite(e, r, s = {}, l) {
          this._checkLoaded();
          const h = [{ id: e, url: r }], y = [...ot(this.stylesheet.sprite), ...h];
          this._validate(c.u.sprite, "sprite", y, null, s) || (this.stylesheet.sprite = y, this._loadSprite(h, !0, l));
        }
        removeSprite(e) {
          this._checkLoaded();
          const r = ot(this.stylesheet.sprite);
          if (r.find((s) => s.id === e)) {
            if (this._spritesImagesIds[e]) for (const s of this._spritesImagesIds[e]) this.imageManager.removeImage(s), this._changedImages[s] = !0;
            r.splice(r.findIndex((s) => s.id === e), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
          } else this.fire(new c.j(new Error(`Sprite "${e}" doesn't exists on this map.`)));
        }
        getSprite() {
          return ot(this.stylesheet.sprite);
        }
        setSprite(e, r = {}, s) {
          this._checkLoaded(), e && this._validate(c.u.sprite, "sprite", e, null, r) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, s) : (this._unloadSprite(), s && s(null)));
        }
      }
      var ts = c.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const is = { prelude: Ni(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Ni(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Ni(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ni(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ni("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ni(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Ni(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ni("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ni("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Ni("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Ni(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Ni(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Ni(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Ni(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ni(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ni(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ni(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ni(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Ni(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ni(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ni(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ni(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Ni(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Ni(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ni(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ni(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ni("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ni("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ni("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Ni("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Ni(a, e) {
        const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s = e.match(/attribute ([\w]+) ([\w]+)/g), l = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), h = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), y = h ? h.concat(l) : l, b = {};
        return { fragmentSource: a = a.replace(r, (I, k, z, M, O) => (b[O] = !0, k === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
varying ${z} ${M} ${O};
#else
uniform ${z} ${M} u_${O};
#endif
` : `
#ifdef HAS_UNIFORM_u_${O}
    ${z} ${M} ${O} = u_${O};
#endif
`)), vertexSource: e = e.replace(r, (I, k, z, M, O) => {
          const U = M === "float" ? "vec2" : "vec4", B = O.match(/color/) ? "color" : U;
          return b[O] ? k === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
attribute ${z} ${U} a_${O};
varying ${z} ${M} ${O};
#else
uniform ${z} ${M} u_${O};
#endif
` : B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = a_${O};
#else
    ${z} ${M} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = unpack_mix_${B}(a_${O}, u_${O}_t);
#else
    ${z} ${M} ${O} = u_${O};
#endif
` : k === "define" ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
attribute ${z} ${U} a_${O};
#else
uniform ${z} ${M} u_${O};
#endif
` : B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${O}
    ${z} ${M} ${O} = a_${O};
#else
    ${z} ${M} ${O} = u_${O};
#endif
` : `
#ifndef HAS_UNIFORM_u_${O}
    ${z} ${M} ${O} = unpack_mix_${B}(a_${O}, u_${O}_t);
#else
    ${z} ${M} ${O} = u_${O};
#endif
`;
        }), staticAttributes: s, staticUniforms: y };
      }
      class Ho {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e, r, s, l, h, y, b, I, k) {
          this.context = e;
          let z = this.boundPaintVertexBuffers.length !== l.length;
          for (let M = 0; !z && M < l.length; M++) this.boundPaintVertexBuffers[M] !== l[M] && (z = !0);
          !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== s || z || this.boundIndexBuffer !== h || this.boundVertexOffset !== y || this.boundDynamicVertexBuffer !== b || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== k ? this.freshBind(r, s, l, h, y, b, I, k) : (e.bindVertexArray.set(this.vao), b && b.bind(), h && h.dynamicDraw && h.bind(), I && I.bind(), k && k.bind());
        }
        freshBind(e, r, s, l, h, y, b, I) {
          const k = e.numAttributes, z = this.context, M = z.gl;
          this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = s, this.boundIndexBuffer = l, this.boundVertexOffset = h, this.boundDynamicVertexBuffer = y, this.boundDynamicVertexBuffer2 = b, this.boundDynamicVertexBuffer3 = I, r.enableAttributes(M, e);
          for (const O of s) O.enableAttributes(M, e);
          y && y.enableAttributes(M, e), b && b.enableAttributes(M, e), I && I.enableAttributes(M, e), r.bind(), r.setVertexAttribPointers(M, e, h);
          for (const O of s) O.bind(), O.setVertexAttribPointers(M, e, h);
          y && (y.bind(), y.setVertexAttribPointers(M, e, h)), l && l.bind(), b && (b.bind(), b.setVertexAttribPointers(M, e, h)), I && (I.bind(), I.setVertexAttribPointers(M, e, h)), z.currentNumAttributes = k;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Ba = (a, e, r, s, l) => ({ u_matrix: a, u_texture: 0, u_ele_delta: e, u_fog_matrix: r, u_fog_color: s ? s.properties.get("fog-color") : c.aM.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: s ? s.calculateFogBlendOpacity(l) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : c.aM.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1 });
      function Fs(a) {
        const e = [];
        for (let r = 0; r < a.length; r++) {
          if (a[r] === null) continue;
          const s = a[r].split(" ");
          e.push(s.pop());
        }
        return e;
      }
      class Oa {
        constructor(e, r, s, l, h, y) {
          const b = e.gl;
          this.program = b.createProgram();
          const I = Fs(r.staticAttributes), k = s ? s.getBinderAttributes() : [], z = I.concat(k), M = is.prelude.staticUniforms ? Fs(is.prelude.staticUniforms) : [], O = r.staticUniforms ? Fs(r.staticUniforms) : [], U = s ? s.getBinderUniforms() : [], B = M.concat(O).concat(U), G = [];
          for (const ve of B) G.indexOf(ve) < 0 && G.push(ve);
          const Q = s ? s.defines() : [];
          h && Q.push("#define OVERDRAW_INSPECTOR;"), y && Q.push("#define TERRAIN3D;");
          const ee = Q.concat(is.prelude.fragmentSource, r.fragmentSource).join(`
`), ne = Q.concat(is.prelude.vertexSource, r.vertexSource).join(`
`), ie = b.createShader(b.FRAGMENT_SHADER);
          if (b.isContextLost()) return void (this.failedToCreate = !0);
          if (b.shaderSource(ie, ee), b.compileShader(ie), !b.getShaderParameter(ie, b.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${b.getShaderInfoLog(ie)}`);
          b.attachShader(this.program, ie);
          const he = b.createShader(b.VERTEX_SHADER);
          if (b.isContextLost()) return void (this.failedToCreate = !0);
          if (b.shaderSource(he, ne), b.compileShader(he), !b.getShaderParameter(he, b.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${b.getShaderInfoLog(he)}`);
          b.attachShader(this.program, he), this.attributes = {};
          const we = {};
          this.numAttributes = z.length;
          for (let ve = 0; ve < this.numAttributes; ve++) z[ve] && (b.bindAttribLocation(this.program, ve, z[ve]), this.attributes[z[ve]] = ve);
          if (b.linkProgram(this.program), !b.getProgramParameter(this.program, b.LINK_STATUS)) throw new Error(`Program failed to link: ${b.getProgramInfoLog(this.program)}`);
          b.deleteShader(he), b.deleteShader(ie);
          for (let ve = 0; ve < G.length; ve++) {
            const Ue = G[ve];
            if (Ue && !we[Ue]) {
              const nt = b.getUniformLocation(this.program, Ue);
              nt && (we[Ue] = nt);
            }
          }
          this.fixedUniforms = l(e, we), this.terrainUniforms = ((ve, Ue) => ({ u_depth: new c.aH(ve, Ue.u_depth), u_terrain: new c.aH(ve, Ue.u_terrain), u_terrain_dim: new c.aI(ve, Ue.u_terrain_dim), u_terrain_matrix: new c.aJ(ve, Ue.u_terrain_matrix), u_terrain_unpack: new c.aK(ve, Ue.u_terrain_unpack), u_terrain_exaggeration: new c.aI(ve, Ue.u_terrain_exaggeration) }))(e, we), this.binderUniforms = s ? s.getUniforms(e, we) : [];
        }
        draw(e, r, s, l, h, y, b, I, k, z, M, O, U, B, G, Q, ee, ne) {
          const ie = e.gl;
          if (this.failedToCreate) return;
          if (e.program.set(this.program), e.setDepthMode(s), e.setStencilMode(l), e.setColorMode(h), e.setCullFace(y), I) {
            e.activeTexture.set(ie.TEXTURE2), ie.bindTexture(ie.TEXTURE_2D, I.depthTexture), e.activeTexture.set(ie.TEXTURE3), ie.bindTexture(ie.TEXTURE_2D, I.texture);
            for (const we in this.terrainUniforms) this.terrainUniforms[we].set(I[we]);
          }
          for (const we in this.fixedUniforms) this.fixedUniforms[we].set(b[we]);
          G && G.setUniforms(e, this.binderUniforms, U, { zoom: B });
          let he = 0;
          switch (r) {
            case ie.LINES:
              he = 2;
              break;
            case ie.TRIANGLES:
              he = 3;
              break;
            case ie.LINE_STRIP:
              he = 1;
          }
          for (const we of O.get()) {
            const ve = we.vaos || (we.vaos = {});
            (ve[k] || (ve[k] = new Ho())).bind(e, this, z, G ? G.getPaintVertexBuffers() : [], M, we.vertexOffset, Q, ee, ne), ie.drawElements(r, we.primitiveLength * he, ie.UNSIGNED_SHORT, we.primitiveOffset * he * 2);
          }
        }
      }
      function io(a, e, r) {
        const s = 1 / pi(r, 1, e.transform.tileZoom), l = Math.pow(2, r.tileID.overscaledZ), h = r.tileSize * Math.pow(2, e.transform.tileZoom) / l, y = h * (r.tileID.canonical.x + r.tileID.wrap * l), b = h * r.tileID.canonical.y;
        return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [s, a.fromScale, a.toScale], u_fade: a.t, u_pixel_coord_upper: [y >> 16, b >> 16], u_pixel_coord_lower: [65535 & y, 65535 & b] };
      }
      const Ao = (a, e, r, s) => {
        const l = e.style.light, h = l.properties.get("position"), y = [h.x, h.y, h.z], b = function() {
          var k = new c.A(9);
          return c.A != Float32Array && (k[1] = 0, k[2] = 0, k[3] = 0, k[5] = 0, k[6] = 0, k[7] = 0), k[0] = 1, k[4] = 1, k[8] = 1, k;
        }();
        l.properties.get("anchor") === "viewport" && function(k, z) {
          var M = Math.sin(z), O = Math.cos(z);
          k[0] = O, k[1] = M, k[2] = 0, k[3] = -M, k[4] = O, k[5] = 0, k[6] = 0, k[7] = 0, k[8] = 1;
        }(b, -e.transform.angle), function(k, z, M) {
          var O = z[0], U = z[1], B = z[2];
          k[0] = O * M[0] + U * M[3] + B * M[6], k[1] = O * M[1] + U * M[4] + B * M[7], k[2] = O * M[2] + U * M[5] + B * M[8];
        }(y, y, b);
        const I = l.properties.get("color");
        return { u_matrix: a, u_lightpos: y, u_lightintensity: l.properties.get("intensity"), u_lightcolor: [I.r, I.g, I.b], u_vertical_gradient: +r, u_opacity: s };
      }, Xo = (a, e, r, s, l, h, y) => c.e(Ao(a, e, r, s), io(h, e, y), { u_height_factor: -Math.pow(2, l.overscaledZ) / y.tileSize / 8 }), ro = (a) => ({ u_matrix: a }), ys = (a, e, r, s) => c.e(ro(a), io(r, e, s)), Yo = (a, e) => ({ u_matrix: a, u_world: e }), Po = (a, e, r, s, l) => c.e(ys(a, e, r, s), { u_world: l }), hl = (a, e, r, s) => {
        const l = a.transform;
        let h, y;
        if (s.paint.get("circle-pitch-alignment") === "map") {
          const b = pi(r, 1, l.zoom);
          h = !0, y = [b, b];
        } else h = !1, y = l.pixelsToGLUnits;
        return { u_camera_to_center_distance: l.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_matrix: a.translatePosMatrix(e.posMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")), u_pitch_with_map: +h, u_device_pixel_ratio: a.pixelRatio, u_extrude_scale: y };
      }, gr = (a, e, r) => ({ u_matrix: a, u_inv_matrix: e, u_camera_to_center_distance: r.cameraToCenterDistance, u_viewport_size: [r.width, r.height] }), Io = (a, e, r = 1) => ({ u_matrix: a, u_color: e, u_overlay: 0, u_overlay_scale: r }), Rr = (a) => ({ u_matrix: a }), Xt = (a, e, r, s) => ({ u_matrix: a, u_extrude_scale: pi(e, 1, r), u_intensity: s }), Jo = (a, e, r, s) => {
        const l = c.H();
        c.aP(l, 0, a.width, a.height, 0, 0, 1);
        const h = a.context.gl;
        return { u_matrix: l, u_world: [h.drawingBufferWidth, h.drawingBufferHeight], u_image: r, u_color_ramp: s, u_opacity: e.paint.get("heatmap-opacity") };
      };
      function Ko(a, e) {
        const r = Math.pow(2, e.canonical.z), s = e.canonical.y;
        return [new c.Z(0, s / r).toLngLat().lat, new c.Z(0, (s + 1) / r).toLngLat().lat];
      }
      const Sn = (a, e, r, s) => {
        const l = a.transform;
        return { u_matrix: ul(a, e, r, s), u_ratio: 1 / pi(e, 1, l.zoom), u_device_pixel_ratio: a.pixelRatio, u_units_to_pixels: [1 / l.pixelsToGLUnits[0], 1 / l.pixelsToGLUnits[1]] };
      }, ja = (a, e, r, s, l) => c.e(Sn(a, e, r, l), { u_image: 0, u_image_height: s }), Rs = (a, e, r, s, l) => {
        const h = a.transform, y = ea(e, h);
        return { u_matrix: ul(a, e, r, l), u_texsize: e.imageAtlasTexture.size, u_ratio: 1 / pi(e, 1, h.zoom), u_device_pixel_ratio: a.pixelRatio, u_image: 0, u_scale: [y, s.fromScale, s.toScale], u_fade: s.t, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] };
      }, Qo = (a, e, r, s, l, h) => {
        const y = a.lineAtlas, b = ea(e, a.transform), I = r.layout.get("line-cap") === "round", k = y.getDash(s.from, I), z = y.getDash(s.to, I), M = k.width * l.fromScale, O = z.width * l.toScale;
        return c.e(Sn(a, e, r, h), { u_patternscale_a: [b / M, -k.height / 2], u_patternscale_b: [b / O, -z.height / 2], u_sdfgamma: y.width / (256 * Math.min(M, O) * a.pixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: z.y, u_mix: l.t });
      };
      function ea(a, e) {
        return 1 / pi(a, 1, e.tileZoom);
      }
      function ul(a, e, r, s) {
        return a.translatePosMatrix(s ? s.posMatrix : e.tileID.posMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
      }
      const Nl = (a, e, r, s, l) => {
        return { u_matrix: a, u_tl_parent: e, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * l.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: l.paint.get("raster-brightness-min"), u_brightness_high: l.paint.get("raster-brightness-max"), u_saturation_factor: (y = l.paint.get("raster-saturation"), y > 0 ? 1 - 1 / (1.001 - y) : -y), u_contrast_factor: (h = l.paint.get("raster-contrast"), h > 0 ? 1 / (1 - h) : 1 + h), u_spin_weights: Fl(l.paint.get("raster-hue-rotate")) };
        var h, y;
      };
      function Fl(a) {
        a *= Math.PI / 180;
        const e = Math.sin(a), r = Math.cos(a);
        return [(2 * r + 1) / 3, (-Math.sqrt(3) * e - r + 1) / 3, (Math.sqrt(3) * e - r + 1) / 3];
      }
      const ta = (a, e, r, s, l, h, y, b, I, k, z, M, O, U) => {
        const B = y.transform;
        return { u_is_size_zoom_constant: +(a === "constant" || a === "source"), u_is_size_feature_constant: +(a === "constant" || a === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: B.cameraToCenterDistance, u_pitch: B.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: B.width / B.height, u_fade_change: y.options.fadeDuration ? y.symbolFadeChange : 1, u_matrix: b, u_label_plane_matrix: I, u_coord_matrix: k, u_is_text: +M, u_pitch_with_map: +s, u_is_along_line: l, u_is_variable_anchor: h, u_texsize: O, u_texture: 0, u_translation: z, u_pitched_scale: U };
      }, rs = (a, e, r, s, l, h, y, b, I, k, z, M, O, U, B) => {
        const G = y.transform;
        return c.e(ta(a, e, r, s, l, h, y, b, I, k, z, M, O, B), { u_gamma_scale: s ? Math.cos(G._pitch) * G.cameraToCenterDistance : 1, u_device_pixel_ratio: y.pixelRatio, u_is_halo: +U });
      }, _s = (a, e, r, s, l, h, y, b, I, k, z, M, O, U) => c.e(rs(a, e, r, s, l, h, y, b, I, k, z, !0, M, !0, U), { u_texsize_icon: O, u_texture_icon: 1 }), ia = (a, e, r) => ({ u_matrix: a, u_opacity: e, u_color: r }), Bs = (a, e, r, s, l, h) => c.e(function(y, b, I, k) {
        const z = I.imageManager.getPattern(y.from.toString()), M = I.imageManager.getPattern(y.to.toString()), { width: O, height: U } = I.imageManager.getPixelSize(), B = Math.pow(2, k.tileID.overscaledZ), G = k.tileSize * Math.pow(2, I.transform.tileZoom) / B, Q = G * (k.tileID.canonical.x + k.tileID.wrap * B), ee = G * k.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: z.tl, u_pattern_br_a: z.br, u_pattern_tl_b: M.tl, u_pattern_br_b: M.br, u_texsize: [O, U], u_mix: b.t, u_pattern_size_a: z.displaySize, u_pattern_size_b: M.displaySize, u_scale_a: b.fromScale, u_scale_b: b.toScale, u_tile_units_to_pixels: 1 / pi(k, 1, I.transform.tileZoom), u_pixel_coord_upper: [Q >> 16, ee >> 16], u_pixel_coord_lower: [65535 & Q, 65535 & ee] };
      }(s, h, r, l), { u_matrix: a, u_opacity: e }), Lo = { fillExtrusion: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_lightpos: new c.aN(a, e.u_lightpos), u_lightintensity: new c.aI(a, e.u_lightintensity), u_lightcolor: new c.aN(a, e.u_lightcolor), u_vertical_gradient: new c.aI(a, e.u_vertical_gradient), u_opacity: new c.aI(a, e.u_opacity) }), fillExtrusionPattern: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_lightpos: new c.aN(a, e.u_lightpos), u_lightintensity: new c.aI(a, e.u_lightintensity), u_lightcolor: new c.aN(a, e.u_lightcolor), u_vertical_gradient: new c.aI(a, e.u_vertical_gradient), u_height_factor: new c.aI(a, e.u_height_factor), u_image: new c.aH(a, e.u_image), u_texsize: new c.aO(a, e.u_texsize), u_pixel_coord_upper: new c.aO(a, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(a, e.u_pixel_coord_lower), u_scale: new c.aN(a, e.u_scale), u_fade: new c.aI(a, e.u_fade), u_opacity: new c.aI(a, e.u_opacity) }), fill: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix) }), fillPattern: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_image: new c.aH(a, e.u_image), u_texsize: new c.aO(a, e.u_texsize), u_pixel_coord_upper: new c.aO(a, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(a, e.u_pixel_coord_lower), u_scale: new c.aN(a, e.u_scale), u_fade: new c.aI(a, e.u_fade) }), fillOutline: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_world: new c.aO(a, e.u_world) }), fillOutlinePattern: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_world: new c.aO(a, e.u_world), u_image: new c.aH(a, e.u_image), u_texsize: new c.aO(a, e.u_texsize), u_pixel_coord_upper: new c.aO(a, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(a, e.u_pixel_coord_lower), u_scale: new c.aN(a, e.u_scale), u_fade: new c.aI(a, e.u_fade) }), circle: (a, e) => ({ u_camera_to_center_distance: new c.aI(a, e.u_camera_to_center_distance), u_scale_with_map: new c.aH(a, e.u_scale_with_map), u_pitch_with_map: new c.aH(a, e.u_pitch_with_map), u_extrude_scale: new c.aO(a, e.u_extrude_scale), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_matrix: new c.aJ(a, e.u_matrix) }), collisionBox: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_pixel_extrude_scale: new c.aO(a, e.u_pixel_extrude_scale) }), collisionCircle: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_inv_matrix: new c.aJ(a, e.u_inv_matrix), u_camera_to_center_distance: new c.aI(a, e.u_camera_to_center_distance), u_viewport_size: new c.aO(a, e.u_viewport_size) }), debug: (a, e) => ({ u_color: new c.aL(a, e.u_color), u_matrix: new c.aJ(a, e.u_matrix), u_overlay: new c.aH(a, e.u_overlay), u_overlay_scale: new c.aI(a, e.u_overlay_scale) }), clippingMask: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix) }), heatmap: (a, e) => ({ u_extrude_scale: new c.aI(a, e.u_extrude_scale), u_intensity: new c.aI(a, e.u_intensity), u_matrix: new c.aJ(a, e.u_matrix) }), heatmapTexture: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_world: new c.aO(a, e.u_world), u_image: new c.aH(a, e.u_image), u_color_ramp: new c.aH(a, e.u_color_ramp), u_opacity: new c.aI(a, e.u_opacity) }), hillshade: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_image: new c.aH(a, e.u_image), u_latrange: new c.aO(a, e.u_latrange), u_light: new c.aO(a, e.u_light), u_shadow: new c.aL(a, e.u_shadow), u_highlight: new c.aL(a, e.u_highlight), u_accent: new c.aL(a, e.u_accent) }), hillshadePrepare: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_image: new c.aH(a, e.u_image), u_dimension: new c.aO(a, e.u_dimension), u_zoom: new c.aI(a, e.u_zoom), u_unpack: new c.aK(a, e.u_unpack) }), line: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_ratio: new c.aI(a, e.u_ratio), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_units_to_pixels: new c.aO(a, e.u_units_to_pixels) }), lineGradient: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_ratio: new c.aI(a, e.u_ratio), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_units_to_pixels: new c.aO(a, e.u_units_to_pixels), u_image: new c.aH(a, e.u_image), u_image_height: new c.aI(a, e.u_image_height) }), linePattern: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_texsize: new c.aO(a, e.u_texsize), u_ratio: new c.aI(a, e.u_ratio), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_image: new c.aH(a, e.u_image), u_units_to_pixels: new c.aO(a, e.u_units_to_pixels), u_scale: new c.aN(a, e.u_scale), u_fade: new c.aI(a, e.u_fade) }), lineSDF: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_ratio: new c.aI(a, e.u_ratio), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_units_to_pixels: new c.aO(a, e.u_units_to_pixels), u_patternscale_a: new c.aO(a, e.u_patternscale_a), u_patternscale_b: new c.aO(a, e.u_patternscale_b), u_sdfgamma: new c.aI(a, e.u_sdfgamma), u_image: new c.aH(a, e.u_image), u_tex_y_a: new c.aI(a, e.u_tex_y_a), u_tex_y_b: new c.aI(a, e.u_tex_y_b), u_mix: new c.aI(a, e.u_mix) }), raster: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_tl_parent: new c.aO(a, e.u_tl_parent), u_scale_parent: new c.aI(a, e.u_scale_parent), u_buffer_scale: new c.aI(a, e.u_buffer_scale), u_fade_t: new c.aI(a, e.u_fade_t), u_opacity: new c.aI(a, e.u_opacity), u_image0: new c.aH(a, e.u_image0), u_image1: new c.aH(a, e.u_image1), u_brightness_low: new c.aI(a, e.u_brightness_low), u_brightness_high: new c.aI(a, e.u_brightness_high), u_saturation_factor: new c.aI(a, e.u_saturation_factor), u_contrast_factor: new c.aI(a, e.u_contrast_factor), u_spin_weights: new c.aN(a, e.u_spin_weights) }), symbolIcon: (a, e) => ({ u_is_size_zoom_constant: new c.aH(a, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(a, e.u_is_size_feature_constant), u_size_t: new c.aI(a, e.u_size_t), u_size: new c.aI(a, e.u_size), u_camera_to_center_distance: new c.aI(a, e.u_camera_to_center_distance), u_pitch: new c.aI(a, e.u_pitch), u_rotate_symbol: new c.aH(a, e.u_rotate_symbol), u_aspect_ratio: new c.aI(a, e.u_aspect_ratio), u_fade_change: new c.aI(a, e.u_fade_change), u_matrix: new c.aJ(a, e.u_matrix), u_label_plane_matrix: new c.aJ(a, e.u_label_plane_matrix), u_coord_matrix: new c.aJ(a, e.u_coord_matrix), u_is_text: new c.aH(a, e.u_is_text), u_pitch_with_map: new c.aH(a, e.u_pitch_with_map), u_is_along_line: new c.aH(a, e.u_is_along_line), u_is_variable_anchor: new c.aH(a, e.u_is_variable_anchor), u_texsize: new c.aO(a, e.u_texsize), u_texture: new c.aH(a, e.u_texture), u_translation: new c.aO(a, e.u_translation), u_pitched_scale: new c.aI(a, e.u_pitched_scale) }), symbolSDF: (a, e) => ({ u_is_size_zoom_constant: new c.aH(a, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(a, e.u_is_size_feature_constant), u_size_t: new c.aI(a, e.u_size_t), u_size: new c.aI(a, e.u_size), u_camera_to_center_distance: new c.aI(a, e.u_camera_to_center_distance), u_pitch: new c.aI(a, e.u_pitch), u_rotate_symbol: new c.aH(a, e.u_rotate_symbol), u_aspect_ratio: new c.aI(a, e.u_aspect_ratio), u_fade_change: new c.aI(a, e.u_fade_change), u_matrix: new c.aJ(a, e.u_matrix), u_label_plane_matrix: new c.aJ(a, e.u_label_plane_matrix), u_coord_matrix: new c.aJ(a, e.u_coord_matrix), u_is_text: new c.aH(a, e.u_is_text), u_pitch_with_map: new c.aH(a, e.u_pitch_with_map), u_is_along_line: new c.aH(a, e.u_is_along_line), u_is_variable_anchor: new c.aH(a, e.u_is_variable_anchor), u_texsize: new c.aO(a, e.u_texsize), u_texture: new c.aH(a, e.u_texture), u_gamma_scale: new c.aI(a, e.u_gamma_scale), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_is_halo: new c.aH(a, e.u_is_halo), u_translation: new c.aO(a, e.u_translation), u_pitched_scale: new c.aI(a, e.u_pitched_scale) }), symbolTextAndIcon: (a, e) => ({ u_is_size_zoom_constant: new c.aH(a, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(a, e.u_is_size_feature_constant), u_size_t: new c.aI(a, e.u_size_t), u_size: new c.aI(a, e.u_size), u_camera_to_center_distance: new c.aI(a, e.u_camera_to_center_distance), u_pitch: new c.aI(a, e.u_pitch), u_rotate_symbol: new c.aH(a, e.u_rotate_symbol), u_aspect_ratio: new c.aI(a, e.u_aspect_ratio), u_fade_change: new c.aI(a, e.u_fade_change), u_matrix: new c.aJ(a, e.u_matrix), u_label_plane_matrix: new c.aJ(a, e.u_label_plane_matrix), u_coord_matrix: new c.aJ(a, e.u_coord_matrix), u_is_text: new c.aH(a, e.u_is_text), u_pitch_with_map: new c.aH(a, e.u_pitch_with_map), u_is_along_line: new c.aH(a, e.u_is_along_line), u_is_variable_anchor: new c.aH(a, e.u_is_variable_anchor), u_texsize: new c.aO(a, e.u_texsize), u_texsize_icon: new c.aO(a, e.u_texsize_icon), u_texture: new c.aH(a, e.u_texture), u_texture_icon: new c.aH(a, e.u_texture_icon), u_gamma_scale: new c.aI(a, e.u_gamma_scale), u_device_pixel_ratio: new c.aI(a, e.u_device_pixel_ratio), u_is_halo: new c.aH(a, e.u_is_halo), u_translation: new c.aO(a, e.u_translation), u_pitched_scale: new c.aI(a, e.u_pitched_scale) }), background: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_opacity: new c.aI(a, e.u_opacity), u_color: new c.aL(a, e.u_color) }), backgroundPattern: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_opacity: new c.aI(a, e.u_opacity), u_image: new c.aH(a, e.u_image), u_pattern_tl_a: new c.aO(a, e.u_pattern_tl_a), u_pattern_br_a: new c.aO(a, e.u_pattern_br_a), u_pattern_tl_b: new c.aO(a, e.u_pattern_tl_b), u_pattern_br_b: new c.aO(a, e.u_pattern_br_b), u_texsize: new c.aO(a, e.u_texsize), u_mix: new c.aI(a, e.u_mix), u_pattern_size_a: new c.aO(a, e.u_pattern_size_a), u_pattern_size_b: new c.aO(a, e.u_pattern_size_b), u_scale_a: new c.aI(a, e.u_scale_a), u_scale_b: new c.aI(a, e.u_scale_b), u_pixel_coord_upper: new c.aO(a, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(a, e.u_pixel_coord_lower), u_tile_units_to_pixels: new c.aI(a, e.u_tile_units_to_pixels) }), terrain: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_texture: new c.aH(a, e.u_texture), u_ele_delta: new c.aI(a, e.u_ele_delta), u_fog_matrix: new c.aJ(a, e.u_fog_matrix), u_fog_color: new c.aL(a, e.u_fog_color), u_fog_ground_blend: new c.aI(a, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.aI(a, e.u_fog_ground_blend_opacity), u_horizon_color: new c.aL(a, e.u_horizon_color), u_horizon_fog_blend: new c.aI(a, e.u_horizon_fog_blend) }), terrainDepth: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_ele_delta: new c.aI(a, e.u_ele_delta) }), terrainCoords: (a, e) => ({ u_matrix: new c.aJ(a, e.u_matrix), u_texture: new c.aH(a, e.u_texture), u_terrain_coords_id: new c.aI(a, e.u_terrain_coords_id), u_ele_delta: new c.aI(a, e.u_ele_delta) }), sky: (a, e) => ({ u_sky_color: new c.aL(a, e.u_sky_color), u_horizon_color: new c.aL(a, e.u_horizon_color), u_horizon: new c.aI(a, e.u_horizon), u_sky_horizon_blend: new c.aI(a, e.u_sky_horizon_blend) }) };
      class on {
        constructor(e, r, s) {
          this.context = e;
          const l = e.gl;
          this.buffer = l.createBuffer(), this.dynamicDraw = !!s, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), l.bufferData(l.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? l.DYNAMIC_DRAW : l.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e) {
          const r = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const dl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class ra {
        constructor(e, r, s, l) {
          this.length = r.length, this.attributes = s, this.itemSize = r.bytesPerElement, this.dynamicDraw = l, this.context = e;
          const h = e.gl;
          this.buffer = h.createBuffer(), e.bindVertexBuffer.set(this.buffer), h.bufferData(h.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e) {
          if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
          const r = this.context.gl;
          this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, e.arrayBuffer);
        }
        enableAttributes(e, r) {
          for (let s = 0; s < this.attributes.length; s++) {
            const l = r.attributes[this.attributes[s].name];
            l !== void 0 && e.enableVertexAttribArray(l);
          }
        }
        setVertexAttribPointers(e, r, s) {
          for (let l = 0; l < this.attributes.length; l++) {
            const h = this.attributes[l], y = r.attributes[h.name];
            y !== void 0 && e.vertexAttribPointer(y, h.components, e[dl[h.type]], !1, this.itemSize, h.offset + this.itemSize * (s || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const vs = /* @__PURE__ */ new WeakMap();
      function ns(a) {
        var e;
        if (vs.has(a)) return vs.get(a);
        {
          const r = (e = a.getParameter(a.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
          return vs.set(a, r), r;
        }
      }
      class Pi {
        constructor(e) {
          this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(e) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class ss extends Pi {
        getDefault() {
          return c.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class Rl extends Pi {
        getDefault() {
          return 1;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
        }
      }
      class An extends Pi {
        getDefault() {
          return 0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
        }
      }
      class os extends Pi {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class na extends Pi {
        getDefault() {
          return !0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
        }
      }
      class To extends Pi {
        getDefault() {
          return 255;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
        }
      }
      class pl extends Pi {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e) {
          const r = this.current;
          (e.func !== r.func || e.ref !== r.ref || e.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
        }
      }
      class no extends Pi {
        getDefault() {
          const e = this.gl;
          return [e.KEEP, e.KEEP, e.KEEP];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
        }
      }
      class fl extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = e, this.dirty = !1;
        }
      }
      class sa extends Pi {
        getDefault() {
          return [0, 1];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class oa extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = e, this.dirty = !1;
        }
      }
      class qa extends Pi {
        getDefault() {
          return this.gl.LESS;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
        }
      }
      class Nn extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = e, this.dirty = !1;
        }
      }
      class aa extends Pi {
        getDefault() {
          const e = this.gl;
          return [e.ONE, e.ZERO];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
        }
      }
      class Va extends Pi {
        getDefault() {
          return c.aM.transparent;
        }
        set(e) {
          const r = this.current;
          (e.r !== r.r || e.g !== r.g || e.b !== r.b || e.a !== r.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
        }
      }
      class Ua extends Pi {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
        }
      }
      class ko extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          e ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = e, this.dirty = !1;
        }
      }
      class la extends Pi {
        getDefault() {
          return this.gl.BACK;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
        }
      }
      class xs extends Pi {
        getDefault() {
          return this.gl.CCW;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
        }
      }
      class $a extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
        }
      }
      class so extends Pi {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
        }
      }
      class ca extends Pi {
        getDefault() {
          const e = this.gl;
          return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
        }
        set(e) {
          const r = this.current;
          (e[0] !== r[0] || e[1] !== r[1] || e[2] !== r[2] || e[3] !== r[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
        }
      }
      class T extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindFramebuffer(r.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class X extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindRenderbuffer(r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class me extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindTexture(r.TEXTURE_2D, e), this.current = e, this.dirty = !1;
        }
      }
      class ke extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindBuffer(r.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Fe extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          const r = this.gl;
          r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Xe extends Pi {
        getDefault() {
          return null;
        }
        set(e) {
          var r;
          if (e === this.current && !this.dirty) return;
          const s = this.gl;
          ns(s) ? s.bindVertexArray(e) : (r = s.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
        }
      }
      class xt extends Pi {
        getDefault() {
          return 4;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
        }
      }
      class Rt extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class ti extends Pi {
        getDefault() {
          return !1;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
        }
      }
      class mi extends Pi {
        constructor(e, r) {
          super(e), this.context = e, this.parent = r;
        }
        getDefault() {
          return null;
        }
      }
      class wi extends mi {
        setDirty() {
          this.dirty = !0;
        }
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
        }
      }
      class Ii extends mi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class Ki extends mi {
        set(e) {
          if (e === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, e), this.current = e, this.dirty = !1;
        }
      }
      class vr {
        constructor(e, r, s, l, h) {
          this.context = e, this.width = r, this.height = s;
          const y = e.gl, b = this.framebuffer = y.createFramebuffer();
          if (this.colorAttachment = new wi(e, b), l) this.depthAttachment = h ? new Ki(e, b) : new Ii(e, b);
          else if (h) throw new Error("Stencil cannot be set without depth");
          if (y.checkFramebufferStatus(y.FRAMEBUFFER) !== y.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const e = this.context.gl, r = this.colorAttachment.get();
          if (r && e.deleteTexture(r), this.depthAttachment) {
            const s = this.depthAttachment.get();
            s && e.deleteRenderbuffer(s);
          }
          e.deleteFramebuffer(this.framebuffer);
        }
      }
      class Si {
        constructor(e, r, s) {
          this.blendFunction = e, this.blendColor = r, this.mask = s;
        }
      }
      Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, c.aM.transparent, [!1, !1, !1, !1]), Si.unblended = new Si(Si.Replace, c.aM.transparent, [!0, !0, !0, !0]), Si.alphaBlended = new Si([1, 771], c.aM.transparent, [!0, !0, !0, !0]);
      class Wr {
        constructor(e) {
          var r, s;
          if (this.gl = e, this.clearColor = new ss(this), this.clearDepth = new Rl(this), this.clearStencil = new An(this), this.colorMask = new os(this), this.depthMask = new na(this), this.stencilMask = new To(this), this.stencilFunc = new pl(this), this.stencilOp = new no(this), this.stencilTest = new fl(this), this.depthRange = new sa(this), this.depthTest = new oa(this), this.depthFunc = new qa(this), this.blend = new Nn(this), this.blendFunc = new aa(this), this.blendColor = new Va(this), this.blendEquation = new Ua(this), this.cullFace = new ko(this), this.cullFaceSide = new la(this), this.frontFace = new xs(this), this.program = new $a(this), this.activeTexture = new so(this), this.viewport = new ca(this), this.bindFramebuffer = new T(this), this.bindRenderbuffer = new X(this), this.bindTexture = new me(this), this.bindVertexBuffer = new ke(this), this.bindElementBuffer = new Fe(this), this.bindVertexArray = new Xe(this), this.pixelStoreUnpack = new xt(this), this.pixelStoreUnpackPremultiplyAlpha = new Rt(this), this.pixelStoreUnpackFlipY = new ti(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), ns(e)) {
            this.HALF_FLOAT = e.HALF_FLOAT;
            const l = e.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (r = e.RGBA16F) !== null && r !== void 0 ? r : l == null ? void 0 : l.RGBA16F_EXT, this.RGB16F = (s = e.RGB16F) !== null && s !== void 0 ? s : l == null ? void 0 : l.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
          } else {
            e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
            const l = e.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = l == null ? void 0 : l.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(e, r) {
          return new on(this, e, r);
        }
        createVertexBuffer(e, r, s) {
          return new ra(this, e, r, s);
        }
        createRenderbuffer(e, r, s) {
          const l = this.gl, h = l.createRenderbuffer();
          return this.bindRenderbuffer.set(h), l.renderbufferStorage(l.RENDERBUFFER, e, r, s), this.bindRenderbuffer.set(null), h;
        }
        createFramebuffer(e, r, s, l) {
          return new vr(this, e, r, s, l);
        }
        clear({ color: e, depth: r, stencil: s }) {
          const l = this.gl;
          let h = 0;
          e && (h |= l.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (h |= l.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), s !== void 0 && (h |= l.STENCIL_BUFFER_BIT, this.clearStencil.set(s), this.stencilMask.set(255)), l.clear(h);
        }
        setCullFace(e) {
          e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
        }
        setDepthMode(e) {
          e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
        }
        setStencilMode(e) {
          e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(e) {
          c.aE(e.blendFunction, Si.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
        }
        createVertexArray() {
          var e;
          return ns(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
        }
        deleteVertexArray(e) {
          var r;
          return ns(this.gl) ? this.gl.deleteVertexArray(e) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(e);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Yt {
        constructor(e, r, s) {
          this.func = e, this.mask = r, this.range = s;
        }
      }
      Yt.ReadOnly = !1, Yt.ReadWrite = !0, Yt.disabled = new Yt(519, Yt.ReadOnly, [0, 1]);
      const mn = 7680;
      class ki {
        constructor(e, r, s, l, h, y) {
          this.test = e, this.ref = r, this.mask = s, this.fail = l, this.depthFail = h, this.pass = y;
        }
      }
      ki.disabled = new ki({ func: 519, mask: 0 }, 0, 0, mn, mn, mn);
      class Mi {
        constructor(e, r, s) {
          this.enable = e, this.mode = r, this.frontFace = s;
        }
      }
      let bs;
      function Os(a, e, r, s, l) {
        const h = a.context, y = h.gl, b = a.useProgram("collisionBox"), I = [];
        let k = 0, z = 0;
        for (let ee = 0; ee < s.length; ee++) {
          const ne = s[ee], ie = e.getTile(ne).getBucket(r);
          if (!ie) continue;
          const he = l ? ie.textCollisionBox : ie.iconCollisionBox, we = ie.collisionCircleArray;
          if (we.length > 0) {
            const ve = c.H();
            c.aQ(ve, ie.placementInvProjMatrix, a.transform.glCoordMatrix), c.aQ(ve, ve, ie.placementViewportMatrix), I.push({ circleArray: we, circleOffset: z, transform: ne.posMatrix, invTransform: ve, coord: ne }), k += we.length / 4, z = k;
          }
          he && b.draw(h, y.LINES, Yt.disabled, ki.disabled, a.colorModeForRenderPass(), Mi.disabled, { u_matrix: ne.posMatrix, u_pixel_extrude_scale: [1 / (M = a.transform).width, 1 / M.height] }, a.style.map.terrain && a.style.map.terrain.getTerrainData(ne), r.id, he.layoutVertexBuffer, he.indexBuffer, he.segments, null, a.transform.zoom, null, null, he.collisionVertexBuffer);
        }
        var M;
        if (!l || !I.length) return;
        const O = a.useProgram("collisionCircle"), U = new c.aR();
        U.resize(4 * k), U._trim();
        let B = 0;
        for (const ee of I) for (let ne = 0; ne < ee.circleArray.length / 4; ne++) {
          const ie = 4 * ne, he = ee.circleArray[ie + 0], we = ee.circleArray[ie + 1], ve = ee.circleArray[ie + 2], Ue = ee.circleArray[ie + 3];
          U.emplace(B++, he, we, ve, Ue, 0), U.emplace(B++, he, we, ve, Ue, 1), U.emplace(B++, he, we, ve, Ue, 2), U.emplace(B++, he, we, ve, Ue, 3);
        }
        (!bs || bs.length < 2 * k) && (bs = function(ee) {
          const ne = 2 * ee, ie = new c.aT();
          ie.resize(ne), ie._trim();
          for (let he = 0; he < ne; he++) {
            const we = 6 * he;
            ie.uint16[we + 0] = 4 * he + 0, ie.uint16[we + 1] = 4 * he + 1, ie.uint16[we + 2] = 4 * he + 2, ie.uint16[we + 3] = 4 * he + 2, ie.uint16[we + 4] = 4 * he + 3, ie.uint16[we + 5] = 4 * he + 0;
          }
          return ie;
        }(k));
        const G = h.createIndexBuffer(bs, !0), Q = h.createVertexBuffer(U, c.aS.members, !0);
        for (const ee of I) {
          const ne = gr(ee.transform, ee.invTransform, a.transform);
          O.draw(h, y.TRIANGLES, Yt.disabled, ki.disabled, a.colorModeForRenderPass(), Mi.disabled, ne, a.style.map.terrain && a.style.map.terrain.getTerrainData(ee.coord), r.id, Q, G, c.a0.simpleSegment(0, 2 * ee.circleOffset, ee.circleArray.length, ee.circleArray.length / 2), null, a.transform.zoom, null, null, null);
        }
        Q.destroy(), G.destroy();
      }
      Mi.disabled = new Mi(!1, 1029, 2305), Mi.backCCW = new Mi(!0, 1029, 2305);
      const js = c.an(new Float32Array(16));
      function oo(a, e, r, s, l, h) {
        const { horizontalAlign: y, verticalAlign: b } = c.au(a);
        return new c.P((-(y - 0.5) * e / l + s[0]) * h, (-(b - 0.5) * r / l + s[1]) * h);
      }
      function as(a, e, r, s, l, h) {
        const y = e.tileAnchorPoint.add(new c.P(e.translation[0], e.translation[1]));
        if (e.pitchWithMap) {
          let b = s.mult(h);
          r || (b = b.rotate(-l));
          const I = y.add(b);
          return ue(I.x, I.y, e.labelPlaneMatrix, e.getElevation).point;
        }
        if (r) {
          const b = Ve(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(a), I = Math.atan(b.y / b.x) + (b.x < 0 ? Math.PI : 0);
          return a.add(s.rotate(I));
        }
        return a.add(s);
      }
      function ws(a, e, r, s, l, h, y, b, I, k, z, M, O, U) {
        const B = a.text.placedSymbolArray, G = a.text.dynamicLayoutVertexArray, Q = a.icon.dynamicLayoutVertexArray, ee = {};
        G.clear();
        for (let ne = 0; ne < B.length; ne++) {
          const ie = B.get(ne), he = ie.hidden || !ie.crossTileID || a.allowVerticalPlacement && !ie.placedOrientation ? null : s[ie.crossTileID];
          if (he) {
            const we = new c.P(ie.anchorX, ie.anchorY), ve = { getElevation: U, width: l.width, height: l.height, labelPlaneMatrix: h, lineVertexArray: null, pitchWithMap: r, projection: z, projectionCache: null, tileAnchorPoint: we, translation: M, unwrappedTileID: O }, Ue = r ? ue(we.x, we.y, y, U) : Ve(we.x, we.y, ve), nt = $(l.cameraToCenterDistance, Ue.signedDistanceFromCamera);
            let ht = c.ai(a.textSizeData, I, ie) * nt / c.ap;
            r && (ht *= a.tilePixelRatio / b);
            const { width: pt, height: dt, anchor: ut, textOffset: ft, textBoxScale: Ot } = he, _t = oo(ut, pt, dt, ft, Ot, ht), vt = z.getPitchedTextCorrection(l, we.add(new c.P(M[0], M[1])), O), Vt = as(Ue.point, ve, e, _t, l.angle, vt), ni = a.allowVerticalPlacement && ie.placedOrientation === c.ah.vertical ? Math.PI / 2 : 0;
            for (let ii = 0; ii < ie.numGlyphs; ii++) c.aj(G, Vt, ni);
            k && ie.associatedIconIndex >= 0 && (ee[ie.associatedIconIndex] = { shiftedAnchor: Vt, angle: ni });
          } else Zt(ie.numGlyphs, G);
        }
        if (k) {
          Q.clear();
          const ne = a.icon.placedSymbolArray;
          for (let ie = 0; ie < ne.length; ie++) {
            const he = ne.get(ie);
            if (he.hidden) Zt(he.numGlyphs, Q);
            else {
              const we = ee[ie];
              if (we) for (let ve = 0; ve < he.numGlyphs; ve++) c.aj(Q, we.shiftedAnchor, we.angle);
              else Zt(he.numGlyphs, Q);
            }
          }
          a.icon.dynamicLayoutVertexBuffer.updateData(Q);
        }
        a.text.dynamicLayoutVertexBuffer.updateData(G);
      }
      function Br(a, e, r) {
        return r.iconsInText && e ? "symbolTextAndIcon" : a ? "symbolSDF" : "symbolIcon";
      }
      function Hr(a, e, r, s, l, h, y, b, I, k, z, M) {
        const O = a.context, U = O.gl, B = a.transform, G = Dn(), Q = b === "map", ee = I === "map", ne = b !== "viewport" && r.layout.get("symbol-placement") !== "point", ie = Q && !ee && !ne, he = !ee && ne, we = !r.layout.get("symbol-sort-key").isConstant();
        let ve = !1;
        const Ue = a.depthModeForSublayer(0, Yt.ReadOnly), nt = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), ht = [], pt = G.getCircleRadiusCorrection(B);
        for (const dt of s) {
          const ut = e.getTile(dt), ft = ut.getBucket(r);
          if (!ft) continue;
          const Ot = l ? ft.text : ft.icon;
          if (!Ot || !Ot.segments.get().length || !Ot.hasVisibleVertices) continue;
          const _t = Ot.programConfigurations.get(r.id), vt = l || ft.sdfIcons, Vt = l ? ft.textSizeData : ft.iconSizeData, ni = ee || B.pitch !== 0, ii = a.useProgram(Br(vt, l, ft), _t), ci = c.ag(Vt, B.zoom), xi = a.style.map.terrain && a.style.map.terrain.getTerrainData(dt);
          let Bi, Qi, zi, dr, Oi = [0, 0], or = null;
          if (l) Qi = ut.glyphAtlasTexture, zi = U.LINEAR, Bi = ut.glyphAtlasTexture.size, ft.iconsInText && (Oi = ut.imageAtlasTexture.size, or = ut.imageAtlasTexture, dr = ni || a.options.rotating || a.options.zooming || Vt.kind === "composite" || Vt.kind === "camera" ? U.LINEAR : U.NEAREST);
          else {
            const Ti = r.layout.get("icon-size").constantOr(0) !== 1 || ft.iconsNeedLinear;
            Qi = ut.imageAtlasTexture, zi = vt || a.options.rotating || a.options.zooming || Ti || ni ? U.LINEAR : U.NEAREST, Bi = ut.imageAtlasTexture.size;
          }
          const wr = pi(ut, 1, a.transform.zoom), hn = he ? dt.posMatrix : js, kn = Cr(hn, ee, Q, a.transform, wr), er = Er(hn, ee, Q, a.transform, wr), go = Er(dt.posMatrix, ee, Q, a.transform, wr), Cn = G.translatePosition(a.transform, ut, h, y), tl = nt && ft.hasTextData(), va = r.layout.get("icon-text-fit") !== "none" && tl && ft.hasIconData();
          if (ne) {
            const Ti = a.style.map.terrain ? (yo, Gs) => a.style.map.terrain.getElevation(dt, yo, Gs) : null, ks = r.layout.get("text-rotation-alignment") === "map";
            te(ft, dt.posMatrix, a, l, kn, go, ee, k, ks, G, dt.toUnwrapped(), B.width, B.height, Cn, Ti);
          }
          const Jr = dt.posMatrix, un = l && nt || va, Dr = ne || un ? js : kn, Kr = er, yr = vt && r.paint.get(l ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Or;
          Or = vt ? ft.iconsInText ? _s(Vt.kind, ci, ie, ee, ne, un, a, Jr, Dr, Kr, Cn, Bi, Oi, pt) : rs(Vt.kind, ci, ie, ee, ne, un, a, Jr, Dr, Kr, Cn, l, Bi, !0, pt) : ta(Vt.kind, ci, ie, ee, ne, un, a, Jr, Dr, Kr, Cn, l, Bi, pt);
          const Qr = { program: ii, buffers: Ot, uniformValues: Or, atlasTexture: Qi, atlasTextureIcon: or, atlasInterpolation: zi, atlasInterpolationIcon: dr, isSDF: vt, hasHalo: yr };
          if (we && ft.canOverlap) {
            ve = !0;
            const Ti = Ot.segments.get();
            for (const ks of Ti) ht.push({ segments: new c.a0([ks]), sortKey: ks.sortKey, state: Qr, terrainData: xi });
          } else ht.push({ segments: Ot.segments, sortKey: 0, state: Qr, terrainData: xi });
        }
        ve && ht.sort((dt, ut) => dt.sortKey - ut.sortKey);
        for (const dt of ht) {
          const ut = dt.state;
          if (O.activeTexture.set(U.TEXTURE0), ut.atlasTexture.bind(ut.atlasInterpolation, U.CLAMP_TO_EDGE), ut.atlasTextureIcon && (O.activeTexture.set(U.TEXTURE1), ut.atlasTextureIcon && ut.atlasTextureIcon.bind(ut.atlasInterpolationIcon, U.CLAMP_TO_EDGE)), ut.isSDF) {
            const ft = ut.uniformValues;
            ut.hasHalo && (ft.u_is_halo = 1, ao(ut.buffers, dt.segments, r, a, ut.program, Ue, z, M, ft, dt.terrainData)), ft.u_is_halo = 0;
          }
          ao(ut.buffers, dt.segments, r, a, ut.program, Ue, z, M, ut.uniformValues, dt.terrainData);
        }
      }
      function ao(a, e, r, s, l, h, y, b, I, k) {
        const z = s.context;
        l.draw(z, z.gl.TRIANGLES, h, y, b, Mi.disabled, I, k, r.id, a.layoutVertexBuffer, a.indexBuffer, e, r.paint, s.transform.zoom, a.programConfigurations.get(r.id), a.dynamicLayoutVertexBuffer, a.opacityVertexBuffer);
      }
      function lo(a, e, r, s) {
        const l = a.context, h = l.gl, y = ki.disabled, b = new Si([h.ONE, h.ONE], c.aM.transparent, [!0, !0, !0, !0]), I = e.getBucket(r);
        if (!I) return;
        const k = s.key;
        let z = r.heatmapFbos.get(k);
        z || (z = qs(l, e.tileSize, e.tileSize), r.heatmapFbos.set(k, z)), l.bindFramebuffer.set(z.framebuffer), l.viewport.set([0, 0, e.tileSize, e.tileSize]), l.clear({ color: c.aM.transparent });
        const M = I.programConfigurations.get(r.id), O = a.useProgram("heatmap", M), U = a.style.map.terrain.getTerrainData(s);
        O.draw(l, h.TRIANGLES, Yt.disabled, y, b, Mi.disabled, Xt(s.posMatrix, e, a.transform.zoom, r.paint.get("heatmap-intensity")), U, r.id, I.layoutVertexBuffer, I.indexBuffer, I.segments, r.paint, a.transform.zoom, M);
      }
      function Fn(a, e, r) {
        const s = a.context, l = s.gl;
        s.setColorMode(a.colorModeForRenderPass());
        const h = Mr(s, e), y = r.key, b = e.heatmapFbos.get(y);
        b && (s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, b.colorAttachment.get()), s.activeTexture.set(l.TEXTURE1), h.bind(l.LINEAR, l.CLAMP_TO_EDGE), a.useProgram("heatmapTexture").draw(s, l.TRIANGLES, Yt.disabled, ki.disabled, a.colorModeForRenderPass(), Mi.disabled, Jo(a, e, 0, 1), null, e.id, a.rasterBoundsBuffer, a.quadTriangleIndexBuffer, a.rasterBoundsSegments, e.paint, a.transform.zoom), b.destroy(), e.heatmapFbos.delete(y));
      }
      function qs(a, e, r) {
        var s, l;
        const h = a.gl, y = h.createTexture();
        h.bindTexture(h.TEXTURE_2D, y), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
        const b = (s = a.HALF_FLOAT) !== null && s !== void 0 ? s : h.UNSIGNED_BYTE, I = (l = a.RGBA16F) !== null && l !== void 0 ? l : h.RGBA;
        h.texImage2D(h.TEXTURE_2D, 0, I, e, r, 0, h.RGBA, b, null);
        const k = a.createFramebuffer(e, r, !1, !1);
        return k.colorAttachment.set(y), k;
      }
      function Mr(a, e) {
        return e.colorRampTexture || (e.colorRampTexture = new oe(a, e.colorRamp, a.gl.RGBA)), e.colorRampTexture;
      }
      function co(a, e, r, s, l) {
        if (!r || !s || !s.imageAtlas) return;
        const h = s.imageAtlas.patternPositions;
        let y = h[r.to.toString()], b = h[r.from.toString()];
        if (!y && b && (y = b), !b && y && (b = y), !y || !b) {
          const I = l.getPaintProperty(e);
          y = h[I], b = h[I];
        }
        y && b && a.setConstantPatternPositions(y, b);
      }
      function Vs(a, e, r, s, l, h, y) {
        const b = a.context.gl, I = "fill-pattern", k = r.paint.get(I), z = k && k.constantOr(1), M = r.getCrossfadeParameters();
        let O, U, B, G, Q;
        y ? (U = z && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", O = b.LINES) : (U = z ? "fillPattern" : "fill", O = b.TRIANGLES);
        const ee = k.constantOr(null);
        for (const ne of s) {
          const ie = e.getTile(ne);
          if (z && !ie.patternsLoaded()) continue;
          const he = ie.getBucket(r);
          if (!he) continue;
          const we = he.programConfigurations.get(r.id), ve = a.useProgram(U, we), Ue = a.style.map.terrain && a.style.map.terrain.getTerrainData(ne);
          z && (a.context.activeTexture.set(b.TEXTURE0), ie.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE), we.updatePaintBuffers(M)), co(we, I, ee, ie, r);
          const nt = Ue ? ne : null, ht = a.translatePosMatrix(nt ? nt.posMatrix : ne.posMatrix, ie, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
          if (y) {
            G = he.indexBuffer2, Q = he.segments2;
            const pt = [b.drawingBufferWidth, b.drawingBufferHeight];
            B = U === "fillOutlinePattern" && z ? Po(ht, a, M, ie, pt) : Yo(ht, pt);
          } else G = he.indexBuffer, Q = he.segments, B = z ? ys(ht, a, M, ie) : ro(ht);
          ve.draw(a.context, O, l, a.stencilModeForClipping(ne), h, Mi.disabled, B, Ue, r.id, he.layoutVertexBuffer, G, Q, r.paint, a.transform.zoom, we);
        }
      }
      function Co(a, e, r, s, l, h, y) {
        const b = a.context, I = b.gl, k = "fill-extrusion-pattern", z = r.paint.get(k), M = z.constantOr(1), O = r.getCrossfadeParameters(), U = r.paint.get("fill-extrusion-opacity"), B = z.constantOr(null);
        for (const G of s) {
          const Q = e.getTile(G), ee = Q.getBucket(r);
          if (!ee) continue;
          const ne = a.style.map.terrain && a.style.map.terrain.getTerrainData(G), ie = ee.programConfigurations.get(r.id), he = a.useProgram(M ? "fillExtrusionPattern" : "fillExtrusion", ie);
          M && (a.context.activeTexture.set(I.TEXTURE0), Q.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), ie.updatePaintBuffers(O)), co(ie, k, B, Q, r);
          const we = a.translatePosMatrix(G.posMatrix, Q, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), ve = r.paint.get("fill-extrusion-vertical-gradient"), Ue = M ? Xo(we, a, ve, U, G, O, Q) : Ao(we, a, ve, U);
          he.draw(b, b.gl.TRIANGLES, l, h, y, Mi.backCCW, Ue, ne, r.id, ee.layoutVertexBuffer, ee.indexBuffer, ee.segments, r.paint, a.transform.zoom, ie, a.style.map.terrain && ee.centroidVertexBuffer);
        }
      }
      function Xr(a, e, r, s, l, h, y) {
        const b = a.context, I = b.gl, k = r.fbo;
        if (!k) return;
        const z = a.useProgram("hillshade"), M = a.style.map.terrain && a.style.map.terrain.getTerrainData(e);
        b.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, k.colorAttachment.get()), z.draw(b, I.TRIANGLES, l, h, y, Mi.disabled, ((O, U, B, G) => {
          const Q = B.paint.get("hillshade-shadow-color"), ee = B.paint.get("hillshade-highlight-color"), ne = B.paint.get("hillshade-accent-color");
          let ie = B.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          B.paint.get("hillshade-illumination-anchor") === "viewport" && (ie -= O.transform.angle);
          const he = !O.options.moving;
          return { u_matrix: G ? G.posMatrix : O.transform.calculatePosMatrix(U.tileID.toUnwrapped(), he), u_image: 0, u_latrange: Ko(0, U.tileID), u_light: [B.paint.get("hillshade-exaggeration"), ie], u_shadow: Q, u_highlight: ee, u_accent: ne };
        })(a, r, s, M ? e : null), M, s.id, a.rasterBoundsBuffer, a.quadTriangleIndexBuffer, a.rasterBoundsSegments);
      }
      function Ss(a, e, r, s, l, h) {
        const y = a.context, b = y.gl, I = e.dem;
        if (I && I.data) {
          const k = I.dim, z = I.stride, M = I.getPixels();
          if (y.activeTexture.set(b.TEXTURE1), y.pixelStoreUnpackPremultiplyAlpha.set(!1), e.demTexture = e.demTexture || a.getTileTexture(z), e.demTexture) {
            const U = e.demTexture;
            U.update(M, { premultiply: !1 }), U.bind(b.NEAREST, b.CLAMP_TO_EDGE);
          } else e.demTexture = new oe(y, M, b.RGBA, { premultiply: !1 }), e.demTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE);
          y.activeTexture.set(b.TEXTURE0);
          let O = e.fbo;
          if (!O) {
            const U = new oe(y, { width: k, height: k, data: null }, b.RGBA);
            U.bind(b.LINEAR, b.CLAMP_TO_EDGE), O = e.fbo = y.createFramebuffer(k, k, !0, !1), O.colorAttachment.set(U.texture);
          }
          y.bindFramebuffer.set(O.framebuffer), y.viewport.set([0, 0, k, k]), a.useProgram("hillshadePrepare").draw(y, b.TRIANGLES, s, l, h, Mi.disabled, ((U, B) => {
            const G = B.stride, Q = c.H();
            return c.aP(Q, 0, c.X, -c.X, 0, 0, 1), c.J(Q, Q, [0, -c.X, 0]), { u_matrix: Q, u_image: 1, u_dimension: [G, G], u_zoom: U.overscaledZ, u_unpack: B.getUnpackVector() };
          })(e.tileID, I), null, r.id, a.rasterBoundsBuffer, a.quadTriangleIndexBuffer, a.rasterBoundsSegments), e.needsHillshadePrepare = !1;
        }
      }
      function ml(a, e, r, s, l, h) {
        const y = s.paint.get("raster-fade-duration");
        if (!h && y > 0) {
          const b = j.now(), I = (b - a.timeAdded) / y, k = e ? (b - e.timeAdded) / y : -1, z = r.getSource(), M = l.coveringZoomLevel({ tileSize: z.tileSize, roundZoom: z.roundZoom }), O = !e || Math.abs(e.tileID.overscaledZ - M) > Math.abs(a.tileID.overscaledZ - M), U = O && a.refreshedUponExpiration ? 1 : c.ac(O ? I : 1 - k, 0, 1);
          return a.refreshedUponExpiration && I >= 1 && (a.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - U } : { opacity: U, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const Za = new c.aM(1, 0, 0, 1), Ai = new c.aM(0, 1, 0, 1), an = new c.aM(0, 0, 1, 1), ls = new c.aM(1, 0, 1, 1), Us = new c.aM(0, 1, 1, 1);
      function ln(a, e, r, s) {
        $s(a, 0, e + r / 2, a.transform.width, r, s);
      }
      function As(a, e, r, s) {
        $s(a, e - r / 2, 0, r, a.transform.height, s);
      }
      function $s(a, e, r, s, l, h) {
        const y = a.context, b = y.gl;
        b.enable(b.SCISSOR_TEST), b.scissor(e * a.pixelRatio, r * a.pixelRatio, s * a.pixelRatio, l * a.pixelRatio), y.clear({ color: h }), b.disable(b.SCISSOR_TEST);
      }
      function Rn(a, e, r) {
        const s = a.context, l = s.gl, h = r.posMatrix, y = a.useProgram("debug"), b = Yt.disabled, I = ki.disabled, k = a.colorModeForRenderPass(), z = "$debug", M = a.style.map.terrain && a.style.map.terrain.getTerrainData(r);
        s.activeTexture.set(l.TEXTURE0);
        const O = e.getTileByID(r.key).latestRawTileData, U = Math.floor((O && O.byteLength || 0) / 1024), B = e.getTile(r).tileSize, G = 512 / Math.min(B, 512) * (r.overscaledZ / a.transform.zoom) * 0.5;
        let Q = r.canonical.toString();
        r.overscaledZ !== r.canonical.z && (Q += ` => ${r.overscaledZ}`), function(ee, ne) {
          ee.initDebugOverlayCanvas();
          const ie = ee.debugOverlayCanvas, he = ee.context.gl, we = ee.debugOverlayCanvas.getContext("2d");
          we.clearRect(0, 0, ie.width, ie.height), we.shadowColor = "white", we.shadowBlur = 2, we.lineWidth = 1.5, we.strokeStyle = "white", we.textBaseline = "top", we.font = "bold 36px Open Sans, sans-serif", we.fillText(ne, 5, 5), we.strokeText(ne, 5, 5), ee.debugOverlayTexture.update(ie), ee.debugOverlayTexture.bind(he.LINEAR, he.CLAMP_TO_EDGE);
        }(a, `${Q} ${U}kB`), y.draw(s, l.TRIANGLES, b, I, Si.alphaBlended, Mi.disabled, Io(h, c.aM.transparent, G), null, z, a.debugBuffer, a.quadTriangleIndexBuffer, a.debugSegments), y.draw(s, l.LINE_STRIP, b, I, k, Mi.disabled, Io(h, c.aM.red), M, z, a.debugBuffer, a.tileBorderIndexBuffer, a.debugSegments);
      }
      function Eo(a, e, r) {
        const s = a.context, l = s.gl, h = a.colorModeForRenderPass(), y = new Yt(l.LEQUAL, Yt.ReadWrite, a.depthRangeFor3D), b = a.useProgram("terrain"), I = e.getTerrainMesh();
        s.bindFramebuffer.set(null), s.viewport.set([0, 0, a.width, a.height]);
        for (const k of r) {
          const z = a.renderToTexture.getTexture(k), M = e.getTerrainData(k.tileID);
          s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, z.texture);
          const O = a.transform.calculatePosMatrix(k.tileID.toUnwrapped()), U = e.getMeshFrameDelta(a.transform.zoom), B = a.transform.calculateFogMatrix(k.tileID.toUnwrapped()), G = Ba(O, U, B, a.style.sky, a.transform.pitch);
          b.draw(s, l.TRIANGLES, y, ki.disabled, h, Mi.backCCW, G, M, "terrain", I.vertexBuffer, I.indexBuffer, I.segments);
        }
      }
      class ho {
        constructor(e, r, s) {
          this.vertexBuffer = e, this.indexBuffer = r, this.segments = s;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class cs {
        constructor(e, r) {
          this.context = new Wr(e), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = kt.maxUnderzooming + kt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ra();
        }
        resize(e, r, s) {
          if (this.width = Math.floor(e * s), this.height = Math.floor(r * s), this.pixelRatio = s, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const l of this.style._order) this.style._layers[l].resize();
        }
        setup() {
          const e = this.context, r = new c.aX();
          r.emplaceBack(0, 0), r.emplaceBack(c.X, 0), r.emplaceBack(0, c.X), r.emplaceBack(c.X, c.X), this.tileExtentBuffer = e.createVertexBuffer(r, ts.members), this.tileExtentSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const s = new c.aX();
          s.emplaceBack(0, 0), s.emplaceBack(c.X, 0), s.emplaceBack(0, c.X), s.emplaceBack(c.X, c.X), this.debugBuffer = e.createVertexBuffer(s, ts.members), this.debugSegments = c.a0.simpleSegment(0, 0, 4, 5);
          const l = new c.$();
          l.emplaceBack(0, 0, 0, 0), l.emplaceBack(c.X, 0, c.X, 0), l.emplaceBack(0, c.X, 0, c.X), l.emplaceBack(c.X, c.X, c.X, c.X), this.rasterBoundsBuffer = e.createVertexBuffer(l, Pt.members), this.rasterBoundsSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const h = new c.aX();
          h.emplaceBack(0, 0), h.emplaceBack(1, 0), h.emplaceBack(0, 1), h.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(h, ts.members), this.viewportSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const y = new c.aZ();
          y.emplaceBack(0), y.emplaceBack(1), y.emplaceBack(3), y.emplaceBack(2), y.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(y);
          const b = new c.aY();
          b.emplaceBack(0, 1, 2), b.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(b);
          const I = this.context.gl;
          this.stencilClearMode = new ki({ func: I.ALWAYS, mask: 0 }, 0, 255, I.ZERO, I.ZERO, I.ZERO);
        }
        clearStencil() {
          const e = this.context, r = e.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const s = c.H();
          c.aP(s, 0, this.width, this.height, 0, 0, 1), c.K(s, s, [r.drawingBufferWidth, r.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, r.TRIANGLES, Yt.disabled, this.stencilClearMode, Si.disabled, Mi.disabled, Rr(s), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(e, r) {
          if (this.currentStencilSource === e.source || !e.isTileClipped() || !r || !r.length) return;
          this.currentStencilSource = e.source;
          const s = this.context, l = s.gl;
          this.nextStencilID + r.length > 256 && this.clearStencil(), s.setColorMode(Si.disabled), s.setDepthMode(Yt.disabled);
          const h = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const y of r) {
            const b = this._tileClippingMaskIDs[y.key] = this.nextStencilID++, I = this.style.map.terrain && this.style.map.terrain.getTerrainData(y);
            h.draw(s, l.TRIANGLES, Yt.disabled, new ki({ func: l.ALWAYS, mask: 0 }, b, 255, l.KEEP, l.KEEP, l.REPLACE), Si.disabled, Mi.disabled, Rr(y.posMatrix), I, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const e = this.nextStencilID++, r = this.context.gl;
          return new ki({ func: r.NOTEQUAL, mask: 255 }, e, 255, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilModeForClipping(e) {
          const r = this.context.gl;
          return new ki({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilConfigForOverlap(e) {
          const r = this.context.gl, s = e.sort((y, b) => b.overscaledZ - y.overscaledZ), l = s[s.length - 1].overscaledZ, h = s[0].overscaledZ - l + 1;
          if (h > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + h > 256 && this.clearStencil();
            const y = {};
            for (let b = 0; b < h; b++) y[b + l] = new ki({ func: r.GEQUAL, mask: 255 }, b + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
            return this.nextStencilID += h, [y, s];
          }
          return [{ [l]: ki.disabled }, s];
        }
        colorModeForRenderPass() {
          const e = this.context.gl;
          return this._showOverdrawInspector ? new Si([e.CONSTANT_COLOR, e.ONE], new c.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Si.unblended : Si.alphaBlended;
        }
        depthModeForSublayer(e, r, s) {
          if (!this.opaquePassEnabledForLayer()) return Yt.disabled;
          const l = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
          return new Yt(s || this.context.gl.LEQUAL, r, [l, l]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e, r) {
          this.style = e, this.options = r, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(j.now()), this.imageManager.beginFrame();
          const s = this.style._order, l = this.style.sourceCaches, h = {}, y = {}, b = {};
          for (const I in l) {
            const k = l[I];
            k.used && k.prepare(this.context), h[I] = k.getVisibleCoordinates(), y[I] = h[I].slice().reverse(), b[I] = k.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let I = 0; I < s.length; I++) if (this.style._layers[s[I]].is3D()) {
            this.opaquePassCutoff = I;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const I of s) {
            const k = this.style._layers[I];
            if (!k.hasOffscreenPass() || k.isHidden(this.transform.zoom)) continue;
            const z = y[k.source];
            (k.type === "custom" || z.length) && this.renderLayer(this, l[k.source], k, z);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? c.aM.black : c.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(I, k) {
            const z = I.context, M = z.gl, O = ((ee, ne, ie) => ({ u_sky_color: ee.properties.get("sky-color"), u_horizon_color: ee.properties.get("horizon-color"), u_horizon: (ne.height / 2 + ne.getHorizon()) * ie, u_sky_horizon_blend: ee.properties.get("sky-horizon-blend") * ne.height / 2 * ie }))(k, I.style.map.transform, I.pixelRatio), U = new Yt(M.LEQUAL, Yt.ReadWrite, [0, 1]), B = ki.disabled, G = I.colorModeForRenderPass(), Q = I.useProgram("sky");
            if (!k.mesh) {
              const ee = new c.aX();
              ee.emplaceBack(-1, -1), ee.emplaceBack(1, -1), ee.emplaceBack(1, 1), ee.emplaceBack(-1, 1);
              const ne = new c.aY();
              ne.emplaceBack(0, 1, 2), ne.emplaceBack(0, 2, 3), k.mesh = new ho(z.createVertexBuffer(ee, ts.members), z.createIndexBuffer(ne), c.a0.simpleSegment(0, 0, ee.length, ne.length));
            }
            Q.draw(z, M.TRIANGLES, U, B, G, Mi.disabled, O, void 0, "sky", k.mesh.vertexBuffer, k.mesh.indexBuffer, k.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = s.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const I = this.style._layers[s[this.currentLayer]], k = l[I.source], z = h[I.source];
            this._renderTileClippingMasks(I, z), this.renderLayer(this, k, I, z);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s.length; this.currentLayer++) {
            const I = this.style._layers[s[this.currentLayer]], k = l[I.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(I)) continue;
            const z = (I.type === "symbol" ? b : y)[I.source];
            this._renderTileClippingMasks(I, h[I.source]), this.renderLayer(this, k, I, z);
          }
          if (this.options.showTileBoundaries) {
            const I = function(k, z) {
              let M = null;
              const O = Object.values(k._layers).flatMap((Q) => Q.source && !Q.isHidden(z) ? [k.sourceCaches[Q.source]] : []), U = O.filter((Q) => Q.getSource().type === "vector"), B = O.filter((Q) => Q.getSource().type !== "vector"), G = (Q) => {
                (!M || M.getSource().maxzoom < Q.getSource().maxzoom) && (M = Q);
              };
              return U.forEach((Q) => G(Q)), M || B.forEach((Q) => G(Q)), M;
            }(this.style, this.transform.zoom);
            I && function(k, z, M) {
              for (let O = 0; O < M.length; O++) Rn(k, z, M[O]);
            }(this, I, I.getVisibleCoordinates());
          }
          this.options.showPadding && function(I) {
            const k = I.transform.padding;
            ln(I, I.transform.height - (k.top || 0), 3, Za), ln(I, k.bottom || 0, 3, Ai), As(I, k.left || 0, 3, an), As(I, I.transform.width - (k.right || 0), 3, ls);
            const z = I.transform.centerPoint;
            (function(M, O, U, B) {
              $s(M, O - 1, U - 10, 2, 20, B), $s(M, O - 10, U - 1, 20, 2, B);
            })(I, z.x, I.transform.height - z.y, Us);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(e) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const r = this.terrainFacilitator.matrix, s = this.transform.modelViewProjectionMatrix;
          let l = this.terrainFacilitator.dirty;
          l || (l = e ? !c.a_(r, s) : !c.a$(r, s)), l || (l = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), l && (c.b0(r, s), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(h, y) {
            const b = h.context, I = b.gl, k = Si.unblended, z = new Yt(I.LEQUAL, Yt.ReadWrite, [0, 1]), M = y.getTerrainMesh(), O = y.sourceCache.getRenderableTiles(), U = h.useProgram("terrainDepth");
            b.bindFramebuffer.set(y.getFramebuffer("depth").framebuffer), b.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), b.clear({ color: c.aM.transparent, depth: 1 });
            for (const B of O) {
              const G = y.getTerrainData(B.tileID), Q = { u_matrix: h.transform.calculatePosMatrix(B.tileID.toUnwrapped()), u_ele_delta: y.getMeshFrameDelta(h.transform.zoom) };
              U.draw(b, I.TRIANGLES, z, ki.disabled, k, Mi.backCCW, Q, G, "terrain", M.vertexBuffer, M.indexBuffer, M.segments);
            }
            b.bindFramebuffer.set(null), b.viewport.set([0, 0, h.width, h.height]);
          }(this, this.style.map.terrain), function(h, y) {
            const b = h.context, I = b.gl, k = Si.unblended, z = new Yt(I.LEQUAL, Yt.ReadWrite, [0, 1]), M = y.getTerrainMesh(), O = y.getCoordsTexture(), U = y.sourceCache.getRenderableTiles(), B = h.useProgram("terrainCoords");
            b.bindFramebuffer.set(y.getFramebuffer("coords").framebuffer), b.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), b.clear({ color: c.aM.transparent, depth: 1 }), y.coordsIndex = [];
            for (const G of U) {
              const Q = y.getTerrainData(G.tileID);
              b.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, O.texture);
              const ee = { u_matrix: h.transform.calculatePosMatrix(G.tileID.toUnwrapped()), u_terrain_coords_id: (255 - y.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: y.getMeshFrameDelta(h.transform.zoom) };
              B.draw(b, I.TRIANGLES, z, ki.disabled, k, Mi.backCCW, ee, Q, "terrain", M.vertexBuffer, M.indexBuffer, M.segments), y.coordsIndex.push(G.tileID.key);
            }
            b.bindFramebuffer.set(null), b.viewport.set([0, 0, h.width, h.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(e, r, s, l) {
          if (!s.isHidden(this.transform.zoom) && (s.type === "background" || s.type === "custom" || (l || []).length)) switch (this.id = s.id, s.type) {
            case "symbol":
              (function(h, y, b, I, k) {
                if (h.renderPass !== "translucent") return;
                const z = ki.disabled, M = h.colorModeForRenderPass();
                (b._unevaluatedLayout.hasValue("text-variable-anchor") || b._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(O, U, B, G, Q, ee, ne, ie, he) {
                  const we = U.transform, ve = Dn(), Ue = Q === "map", nt = ee === "map";
                  for (const ht of O) {
                    const pt = G.getTile(ht), dt = pt.getBucket(B);
                    if (!dt || !dt.text || !dt.text.segments.get().length) continue;
                    const ut = c.ag(dt.textSizeData, we.zoom), ft = pi(pt, 1, U.transform.zoom), Ot = Cr(ht.posMatrix, nt, Ue, U.transform, ft), _t = B.layout.get("icon-text-fit") !== "none" && dt.hasIconData();
                    if (ut) {
                      const vt = Math.pow(2, we.zoom - pt.tileID.overscaledZ), Vt = U.style.map.terrain ? (ii, ci) => U.style.map.terrain.getElevation(ht, ii, ci) : null, ni = ve.translatePosition(we, pt, ne, ie);
                      ws(dt, Ue, nt, he, we, Ot, ht.posMatrix, vt, ut, _t, ve, ni, ht.toUnwrapped(), Vt);
                    }
                  }
                }(I, h, b, y, b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), k), b.paint.get("icon-opacity").constantOr(1) !== 0 && Hr(h, y, b, I, !1, b.paint.get("icon-translate"), b.paint.get("icon-translate-anchor"), b.layout.get("icon-rotation-alignment"), b.layout.get("icon-pitch-alignment"), b.layout.get("icon-keep-upright"), z, M), b.paint.get("text-opacity").constantOr(1) !== 0 && Hr(h, y, b, I, !0, b.paint.get("text-translate"), b.paint.get("text-translate-anchor"), b.layout.get("text-rotation-alignment"), b.layout.get("text-pitch-alignment"), b.layout.get("text-keep-upright"), z, M), y.map.showCollisionBoxes && (Os(h, y, b, I, !0), Os(h, y, b, I, !1));
              })(e, r, s, l, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(h, y, b, I) {
                if (h.renderPass !== "translucent") return;
                const k = b.paint.get("circle-opacity"), z = b.paint.get("circle-stroke-width"), M = b.paint.get("circle-stroke-opacity"), O = !b.layout.get("circle-sort-key").isConstant();
                if (k.constantOr(1) === 0 && (z.constantOr(1) === 0 || M.constantOr(1) === 0)) return;
                const U = h.context, B = U.gl, G = h.depthModeForSublayer(0, Yt.ReadOnly), Q = ki.disabled, ee = h.colorModeForRenderPass(), ne = [];
                for (let ie = 0; ie < I.length; ie++) {
                  const he = I[ie], we = y.getTile(he), ve = we.getBucket(b);
                  if (!ve) continue;
                  const Ue = ve.programConfigurations.get(b.id), nt = h.useProgram("circle", Ue), ht = ve.layoutVertexBuffer, pt = ve.indexBuffer, dt = h.style.map.terrain && h.style.map.terrain.getTerrainData(he), ut = { programConfiguration: Ue, program: nt, layoutVertexBuffer: ht, indexBuffer: pt, uniformValues: hl(h, he, we, b), terrainData: dt };
                  if (O) {
                    const ft = ve.segments.get();
                    for (const Ot of ft) ne.push({ segments: new c.a0([Ot]), sortKey: Ot.sortKey, state: ut });
                  } else ne.push({ segments: ve.segments, sortKey: 0, state: ut });
                }
                O && ne.sort((ie, he) => ie.sortKey - he.sortKey);
                for (const ie of ne) {
                  const { programConfiguration: he, program: we, layoutVertexBuffer: ve, indexBuffer: Ue, uniformValues: nt, terrainData: ht } = ie.state;
                  we.draw(U, B.TRIANGLES, G, Q, ee, Mi.disabled, nt, ht, b.id, ve, Ue, ie.segments, b.paint, h.transform.zoom, he);
                }
              })(e, r, s, l);
              break;
            case "heatmap":
              (function(h, y, b, I) {
                if (b.paint.get("heatmap-opacity") === 0) return;
                const k = h.context;
                if (h.style.map.terrain) {
                  for (const z of I) {
                    const M = y.getTile(z);
                    y.hasRenderableParent(z) || (h.renderPass === "offscreen" ? lo(h, M, b, z) : h.renderPass === "translucent" && Fn(h, b, z));
                  }
                  k.viewport.set([0, 0, h.width, h.height]);
                } else h.renderPass === "offscreen" ? function(z, M, O, U) {
                  const B = z.context, G = B.gl, Q = ki.disabled, ee = new Si([G.ONE, G.ONE], c.aM.transparent, [!0, !0, !0, !0]);
                  (function(ne, ie, he) {
                    const we = ne.gl;
                    ne.activeTexture.set(we.TEXTURE1), ne.viewport.set([0, 0, ie.width / 4, ie.height / 4]);
                    let ve = he.heatmapFbos.get(c.aU);
                    ve ? (we.bindTexture(we.TEXTURE_2D, ve.colorAttachment.get()), ne.bindFramebuffer.set(ve.framebuffer)) : (ve = qs(ne, ie.width / 4, ie.height / 4), he.heatmapFbos.set(c.aU, ve));
                  })(B, z, O), B.clear({ color: c.aM.transparent });
                  for (let ne = 0; ne < U.length; ne++) {
                    const ie = U[ne];
                    if (M.hasRenderableParent(ie)) continue;
                    const he = M.getTile(ie), we = he.getBucket(O);
                    if (!we) continue;
                    const ve = we.programConfigurations.get(O.id), Ue = z.useProgram("heatmap", ve), { zoom: nt } = z.transform;
                    Ue.draw(B, G.TRIANGLES, Yt.disabled, Q, ee, Mi.disabled, Xt(ie.posMatrix, he, nt, O.paint.get("heatmap-intensity")), null, O.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, O.paint, z.transform.zoom, ve);
                  }
                  B.viewport.set([0, 0, z.width, z.height]);
                }(h, y, b, I) : h.renderPass === "translucent" && function(z, M) {
                  const O = z.context, U = O.gl;
                  O.setColorMode(z.colorModeForRenderPass());
                  const B = M.heatmapFbos.get(c.aU);
                  B && (O.activeTexture.set(U.TEXTURE0), U.bindTexture(U.TEXTURE_2D, B.colorAttachment.get()), O.activeTexture.set(U.TEXTURE1), Mr(O, M).bind(U.LINEAR, U.CLAMP_TO_EDGE), z.useProgram("heatmapTexture").draw(O, U.TRIANGLES, Yt.disabled, ki.disabled, z.colorModeForRenderPass(), Mi.disabled, Jo(z, M, 0, 1), null, M.id, z.viewportBuffer, z.quadTriangleIndexBuffer, z.viewportSegments, M.paint, z.transform.zoom));
                }(h, b);
              })(e, r, s, l);
              break;
            case "line":
              (function(h, y, b, I) {
                if (h.renderPass !== "translucent") return;
                const k = b.paint.get("line-opacity"), z = b.paint.get("line-width");
                if (k.constantOr(1) === 0 || z.constantOr(1) === 0) return;
                const M = h.depthModeForSublayer(0, Yt.ReadOnly), O = h.colorModeForRenderPass(), U = b.paint.get("line-dasharray"), B = b.paint.get("line-pattern"), G = B.constantOr(1), Q = b.paint.get("line-gradient"), ee = b.getCrossfadeParameters(), ne = G ? "linePattern" : U ? "lineSDF" : Q ? "lineGradient" : "line", ie = h.context, he = ie.gl;
                let we = !0;
                for (const ve of I) {
                  const Ue = y.getTile(ve);
                  if (G && !Ue.patternsLoaded()) continue;
                  const nt = Ue.getBucket(b);
                  if (!nt) continue;
                  const ht = nt.programConfigurations.get(b.id), pt = h.context.program.get(), dt = h.useProgram(ne, ht), ut = we || dt.program !== pt, ft = h.style.map.terrain && h.style.map.terrain.getTerrainData(ve), Ot = B.constantOr(null);
                  if (Ot && Ue.imageAtlas) {
                    const Vt = Ue.imageAtlas, ni = Vt.patternPositions[Ot.to.toString()], ii = Vt.patternPositions[Ot.from.toString()];
                    ni && ii && ht.setConstantPatternPositions(ni, ii);
                  }
                  const _t = ft ? ve : null, vt = G ? Rs(h, Ue, b, ee, _t) : U ? Qo(h, Ue, b, U, ee, _t) : Q ? ja(h, Ue, b, nt.lineClipsArray.length, _t) : Sn(h, Ue, b, _t);
                  if (G) ie.activeTexture.set(he.TEXTURE0), Ue.imageAtlasTexture.bind(he.LINEAR, he.CLAMP_TO_EDGE), ht.updatePaintBuffers(ee);
                  else if (U && (ut || h.lineAtlas.dirty)) ie.activeTexture.set(he.TEXTURE0), h.lineAtlas.bind(ie);
                  else if (Q) {
                    const Vt = nt.gradients[b.id];
                    let ni = Vt.texture;
                    if (b.gradientVersion !== Vt.version) {
                      let ii = 256;
                      if (b.stepInterpolant) {
                        const ci = y.getSource().maxzoom, xi = ve.canonical.z === ci ? Math.ceil(1 << h.transform.maxZoom - ve.canonical.z) : 1;
                        ii = c.ac(c.aV(nt.maxLineLength / c.X * 1024 * xi), 256, ie.maxTextureSize);
                      }
                      Vt.gradient = c.aW({ expression: b.gradientExpression(), evaluationKey: "lineProgress", resolution: ii, image: Vt.gradient || void 0, clips: nt.lineClipsArray }), Vt.texture ? Vt.texture.update(Vt.gradient) : Vt.texture = new oe(ie, Vt.gradient, he.RGBA), Vt.version = b.gradientVersion, ni = Vt.texture;
                    }
                    ie.activeTexture.set(he.TEXTURE0), ni.bind(b.stepInterpolant ? he.NEAREST : he.LINEAR, he.CLAMP_TO_EDGE);
                  }
                  dt.draw(ie, he.TRIANGLES, M, h.stencilModeForClipping(ve), O, Mi.disabled, vt, ft, b.id, nt.layoutVertexBuffer, nt.indexBuffer, nt.segments, b.paint, h.transform.zoom, ht, nt.layoutVertexBuffer2), we = !1;
                }
              })(e, r, s, l);
              break;
            case "fill":
              (function(h, y, b, I) {
                const k = b.paint.get("fill-color"), z = b.paint.get("fill-opacity");
                if (z.constantOr(1) === 0) return;
                const M = h.colorModeForRenderPass(), O = b.paint.get("fill-pattern"), U = h.opaquePassEnabledForLayer() && !O.constantOr(1) && k.constantOr(c.aM.transparent).a === 1 && z.constantOr(0) === 1 ? "opaque" : "translucent";
                if (h.renderPass === U) {
                  const B = h.depthModeForSublayer(1, h.renderPass === "opaque" ? Yt.ReadWrite : Yt.ReadOnly);
                  Vs(h, y, b, I, B, M, !1);
                }
                if (h.renderPass === "translucent" && b.paint.get("fill-antialias")) {
                  const B = h.depthModeForSublayer(b.getPaintProperty("fill-outline-color") ? 2 : 0, Yt.ReadOnly);
                  Vs(h, y, b, I, B, M, !0);
                }
              })(e, r, s, l);
              break;
            case "fill-extrusion":
              (function(h, y, b, I) {
                const k = b.paint.get("fill-extrusion-opacity");
                if (k !== 0 && h.renderPass === "translucent") {
                  const z = new Yt(h.context.gl.LEQUAL, Yt.ReadWrite, h.depthRangeFor3D);
                  if (k !== 1 || b.paint.get("fill-extrusion-pattern").constantOr(1)) Co(h, y, b, I, z, ki.disabled, Si.disabled), Co(h, y, b, I, z, h.stencilModeFor3D(), h.colorModeForRenderPass());
                  else {
                    const M = h.colorModeForRenderPass();
                    Co(h, y, b, I, z, ki.disabled, M);
                  }
                }
              })(e, r, s, l);
              break;
            case "hillshade":
              (function(h, y, b, I) {
                if (h.renderPass !== "offscreen" && h.renderPass !== "translucent") return;
                const k = h.context, z = h.depthModeForSublayer(0, Yt.ReadOnly), M = h.colorModeForRenderPass(), [O, U] = h.renderPass === "translucent" ? h.stencilConfigForOverlap(I) : [{}, I];
                for (const B of U) {
                  const G = y.getTile(B);
                  G.needsHillshadePrepare !== void 0 && G.needsHillshadePrepare && h.renderPass === "offscreen" ? Ss(h, G, b, z, ki.disabled, M) : h.renderPass === "translucent" && Xr(h, B, G, b, z, O[B.overscaledZ], M);
                }
                k.viewport.set([0, 0, h.width, h.height]);
              })(e, r, s, l);
              break;
            case "raster":
              (function(h, y, b, I) {
                if (h.renderPass !== "translucent" || b.paint.get("raster-opacity") === 0 || !I.length) return;
                const k = h.context, z = k.gl, M = y.getSource(), O = h.useProgram("raster"), U = h.colorModeForRenderPass(), [B, G] = M instanceof Gt ? [{}, I] : h.stencilConfigForOverlap(I), Q = G[G.length - 1].overscaledZ, ee = !h.options.moving;
                for (const ne of G) {
                  const ie = h.depthModeForSublayer(ne.overscaledZ - Q, b.paint.get("raster-opacity") === 1 ? Yt.ReadWrite : Yt.ReadOnly, z.LESS), he = y.getTile(ne);
                  he.registerFadeDuration(b.paint.get("raster-fade-duration"));
                  const we = y.findLoadedParent(ne, 0), ve = y.findLoadedSibling(ne), Ue = ml(he, we || ve || null, y, b, h.transform, h.style.map.terrain);
                  let nt, ht;
                  const pt = b.paint.get("raster-resampling") === "nearest" ? z.NEAREST : z.LINEAR;
                  k.activeTexture.set(z.TEXTURE0), he.texture.bind(pt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), k.activeTexture.set(z.TEXTURE1), we ? (we.texture.bind(pt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), nt = Math.pow(2, we.tileID.overscaledZ - he.tileID.overscaledZ), ht = [he.tileID.canonical.x * nt % 1, he.tileID.canonical.y * nt % 1]) : he.texture.bind(pt, z.CLAMP_TO_EDGE, z.LINEAR_MIPMAP_NEAREST), he.texture.useMipmap && k.extTextureFilterAnisotropic && h.transform.pitch > 20 && z.texParameterf(z.TEXTURE_2D, k.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, k.extTextureFilterAnisotropicMax);
                  const dt = h.style.map.terrain && h.style.map.terrain.getTerrainData(ne), ut = dt ? ne : null, ft = ut ? ut.posMatrix : h.transform.calculatePosMatrix(ne.toUnwrapped(), ee), Ot = Nl(ft, ht || [0, 0], nt || 1, Ue, b);
                  M instanceof Gt ? O.draw(k, z.TRIANGLES, ie, ki.disabled, U, Mi.disabled, Ot, dt, b.id, M.boundsBuffer, h.quadTriangleIndexBuffer, M.boundsSegments) : O.draw(k, z.TRIANGLES, ie, B[ne.overscaledZ], U, Mi.disabled, Ot, dt, b.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments);
                }
              })(e, r, s, l);
              break;
            case "background":
              (function(h, y, b, I) {
                const k = b.paint.get("background-color"), z = b.paint.get("background-opacity");
                if (z === 0) return;
                const M = h.context, O = M.gl, U = h.transform, B = U.tileSize, G = b.paint.get("background-pattern");
                if (h.isPatternMissing(G)) return;
                const Q = !G && k.a === 1 && z === 1 && h.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (h.renderPass !== Q) return;
                const ee = ki.disabled, ne = h.depthModeForSublayer(0, Q === "opaque" ? Yt.ReadWrite : Yt.ReadOnly), ie = h.colorModeForRenderPass(), he = h.useProgram(G ? "backgroundPattern" : "background"), we = I || U.coveringTiles({ tileSize: B, terrain: h.style.map.terrain });
                G && (M.activeTexture.set(O.TEXTURE0), h.imageManager.bind(h.context));
                const ve = b.getCrossfadeParameters();
                for (const Ue of we) {
                  const nt = I ? Ue.posMatrix : h.transform.calculatePosMatrix(Ue.toUnwrapped()), ht = G ? Bs(nt, z, h, G, { tileID: Ue, tileSize: B }, ve) : ia(nt, z, k), pt = h.style.map.terrain && h.style.map.terrain.getTerrainData(Ue);
                  he.draw(M, O.TRIANGLES, ne, ee, ie, Mi.disabled, ht, pt, b.id, h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments);
                }
              })(e, 0, s, l);
              break;
            case "custom":
              (function(h, y, b) {
                const I = h.context, k = b.implementation;
                if (h.renderPass === "offscreen") {
                  const z = k.prerender;
                  z && (h.setCustomLayerDefaults(), I.setColorMode(h.colorModeForRenderPass()), z.call(k, I.gl, h.transform.customLayerMatrix()), I.setDirty(), h.setBaseState());
                } else if (h.renderPass === "translucent") {
                  h.setCustomLayerDefaults(), I.setColorMode(h.colorModeForRenderPass()), I.setStencilMode(ki.disabled);
                  const z = k.renderingMode === "3d" ? new Yt(h.context.gl.LEQUAL, Yt.ReadWrite, h.depthRangeFor3D) : h.depthModeForSublayer(0, Yt.ReadOnly);
                  I.setDepthMode(z), k.render(I.gl, h.transform.customLayerMatrix(), { farZ: h.transform.farZ, nearZ: h.transform.nearZ, fov: h.transform._fov, modelViewProjectionMatrix: h.transform.modelViewProjectionMatrix, projectionMatrix: h.transform.projectionMatrix }), I.setDirty(), h.setBaseState(), I.bindFramebuffer.set(null);
                }
              })(e, 0, s);
          }
        }
        translatePosMatrix(e, r, s, l, h) {
          if (!s[0] && !s[1]) return e;
          const y = h ? l === "map" ? this.transform.angle : 0 : l === "viewport" ? -this.transform.angle : 0;
          if (y) {
            const k = Math.sin(y), z = Math.cos(y);
            s = [s[0] * z - s[1] * k, s[0] * k + s[1] * z];
          }
          const b = [h ? s[0] : pi(r, s[0], this.transform.zoom), h ? s[1] : pi(r, s[1], this.transform.zoom), 0], I = new Float32Array(16);
          return c.J(I, e, b), I;
        }
        saveTileTexture(e) {
          const r = this._tileTextures[e.size[0]];
          r ? r.push(e) : this._tileTextures[e.size[0]] = [e];
        }
        getTileTexture(e) {
          const r = this._tileTextures[e];
          return r && r.length > 0 ? r.pop() : null;
        }
        isPatternMissing(e) {
          if (!e) return !1;
          if (!e.from || !e.to) return !0;
          const r = this.imageManager.getPattern(e.from.toString()), s = this.imageManager.getPattern(e.to.toString());
          return !r || !s;
        }
        useProgram(e, r) {
          this.cache = this.cache || {};
          const s = e + (r ? r.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[s] || (this.cache[s] = new Oa(this.context, is[e], r, Lo[e], this._showOverdrawInspector, this.style.map.terrain)), this.cache[s];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new oe(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: e, drawingBufferHeight: r } = this.context.gl;
          return this.width !== e || this.height !== r;
        }
      }
      class Yr {
        constructor(e, r) {
          this.points = e, this.planes = r;
        }
        static fromInvProjectionMatrix(e, r, s) {
          const l = Math.pow(2, s), h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((b) => {
            const I = 1 / (b = c.af([], b, e))[3] / r * l;
            return c.b1(b, b, [I, I, 1 / b[3], I]);
          }), y = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((b) => {
            const I = function(O, U) {
              var B = U[0], G = U[1], Q = U[2], ee = B * B + G * G + Q * Q;
              return ee > 0 && (ee = 1 / Math.sqrt(ee)), O[0] = U[0] * ee, O[1] = U[1] * ee, O[2] = U[2] * ee, O;
            }([], function(O, U, B) {
              var G = U[0], Q = U[1], ee = U[2], ne = B[0], ie = B[1], he = B[2];
              return O[0] = Q * he - ee * ie, O[1] = ee * ne - G * he, O[2] = G * ie - Q * ne, O;
            }([], Be([], h[b[0]], h[b[1]]), Be([], h[b[2]], h[b[1]]))), k = -((z = I)[0] * (M = h[b[1]])[0] + z[1] * M[1] + z[2] * M[2]);
            var z, M;
            return I.concat(k);
          });
          return new Yr(h, y);
        }
      }
      class gn {
        constructor(e, r) {
          this.min = e, this.max = r, this.center = function(s, l, h) {
            return s[0] = 0.5 * l[0], s[1] = 0.5 * l[1], s[2] = 0.5 * l[2], s;
          }([], function(s, l, h) {
            return s[0] = l[0] + h[0], s[1] = l[1] + h[1], s[2] = l[2] + h[2], s;
          }([], this.min, this.max));
        }
        quadrant(e) {
          const r = [e % 2 == 0, e < 2], s = $e(this.min), l = $e(this.max);
          for (let h = 0; h < r.length; h++) s[h] = r[h] ? this.min[h] : this.center[h], l[h] = r[h] ? this.center[h] : this.max[h];
          return l[2] = this.max[2], new gn(s, l);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        intersects(e) {
          const r = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let s = !0;
          for (let l = 0; l < e.planes.length; l++) {
            const h = e.planes[l];
            let y = 0;
            for (let b = 0; b < r.length; b++) c.b2(h, r[b]) >= 0 && y++;
            if (y === 0) return 0;
            y !== r.length && (s = !1);
          }
          if (s) return 2;
          for (let l = 0; l < 3; l++) {
            let h = Number.MAX_VALUE, y = -Number.MAX_VALUE;
            for (let b = 0; b < e.points.length; b++) {
              const I = e.points[b][l] - this.min[l];
              h = Math.min(h, I), y = Math.max(y, I);
            }
            if (y < 0 || h > this.max[l] - this.min[l]) return 0;
          }
          return 1;
        }
      }
      class Bn {
        constructor(e = 0, r = 0, s = 0, l = 0) {
          if (isNaN(e) || e < 0 || isNaN(r) || r < 0 || isNaN(s) || s < 0 || isNaN(l) || l < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e, this.bottom = r, this.left = s, this.right = l;
        }
        interpolate(e, r, s) {
          return r.top != null && e.top != null && (this.top = c.y.number(e.top, r.top, s)), r.bottom != null && e.bottom != null && (this.bottom = c.y.number(e.bottom, r.bottom, s)), r.left != null && e.left != null && (this.left = c.y.number(e.left, r.left, s)), r.right != null && e.right != null && (this.right = c.y.number(e.right, r.right, s)), this;
        }
        getCenter(e, r) {
          const s = c.ac((this.left + e - this.right) / 2, 0, e), l = c.ac((this.top + r - this.bottom) / 2, 0, r);
          return new c.P(s, l);
        }
        equals(e) {
          return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
        }
        clone() {
          return new Bn(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const uo = 85.051129;
      class On {
        constructor(e, r, s, l, h) {
          this.tileSize = 512, this._renderWorldCopies = h === void 0 || !!h, this._minZoom = e || 0, this._maxZoom = r || 22, this._minPitch = s ?? 0, this._maxPitch = l ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new c.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new Bn(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const e = new On(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return e.apply(this), e;
        }
        apply(e) {
          this.tileSize = e.tileSize, this.latRange = e.latRange, this.lngRange = e.lngRange, this.width = e.width, this.height = e.height, this._center = e._center, this._elevation = e._elevation, this.minElevationForCurrentTile = e.minElevationForCurrentTile, this.zoom = e.zoom, this.angle = e.angle, this._fov = e._fov, this._pitch = e._pitch, this._unmodified = e._unmodified, this._edgeInsets = e._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e) {
          this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e) {
          this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e) {
          this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e) {
          this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(e) {
          e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new c.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(e) {
          const r = -c.b3(e, -180, 180) * Math.PI / 180;
          this.angle !== r && (this._unmodified = !1, this.angle = r, this._calcMatrices(), this.rotationMatrix = function() {
            var s = new c.A(4);
            return c.A != Float32Array && (s[1] = 0, s[2] = 0), s[0] = 1, s[3] = 1, s;
          }(), function(s, l, h) {
            var y = l[0], b = l[1], I = l[2], k = l[3], z = Math.sin(h), M = Math.cos(h);
            s[0] = y * M + I * z, s[1] = b * M + k * z, s[2] = y * -z + I * M, s[3] = b * -z + k * M;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(e) {
          const r = c.ac(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== r && (this._unmodified = !1, this._pitch = r, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(e) {
          e = Math.max(0.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e) {
          const r = Math.min(Math.max(e, this.minZoom), this.maxZoom);
          this._zoom !== r && (this._unmodified = !1, this._zoom = r, this.tileZoom = Math.max(0, Math.floor(r)), this.scale = this.zoomScale(r), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(e) {
          e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e) {
          e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e) {
          this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(e) {
          return this._edgeInsets.equals(e);
        }
        interpolatePadding(e, r, s) {
          this._unmodified = !1, this._edgeInsets.interpolate(e, r, s), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e) {
          const r = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
          return Math.max(0, r);
        }
        getVisibleUnwrappedCoordinates(e) {
          const r = [new c.b4(0, e)];
          if (this._renderWorldCopies) {
            const s = this.pointCoordinate(new c.P(0, 0)), l = this.pointCoordinate(new c.P(this.width, 0)), h = this.pointCoordinate(new c.P(this.width, this.height)), y = this.pointCoordinate(new c.P(0, this.height)), b = Math.floor(Math.min(s.x, l.x, h.x, y.x)), I = Math.floor(Math.max(s.x, l.x, h.x, y.x)), k = 1;
            for (let z = b - k; z <= I + k; z++) z !== 0 && r.push(new c.b4(z, e));
          }
          return r;
        }
        coveringTiles(e) {
          var r, s;
          let l = this.coveringZoomLevel(e);
          const h = l;
          if (e.minzoom !== void 0 && l < e.minzoom) return [];
          e.maxzoom !== void 0 && l > e.maxzoom && (l = e.maxzoom);
          const y = this.pointCoordinate(this.getCameraPoint()), b = c.Z.fromLngLat(this.center), I = Math.pow(2, l), k = [I * y.x, I * y.y, 0], z = [I * b.x, I * b.y, 0], M = Yr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, l);
          let O = e.minzoom || 0;
          !e.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (O = l);
          const U = e.terrain ? 2 / Math.min(this.tileSize, e.tileSize) * this.tileSize : 3, B = (ie) => ({ aabb: new gn([ie * I, 0, 0], [(ie + 1) * I, I, 0]), zoom: 0, x: 0, y: 0, wrap: ie, fullyVisible: !1 }), G = [], Q = [], ee = l, ne = e.reparseOverscaled ? h : l;
          if (this._renderWorldCopies) for (let ie = 1; ie <= 3; ie++) G.push(B(-ie)), G.push(B(ie));
          for (G.push(B(0)); G.length > 0; ) {
            const ie = G.pop(), he = ie.x, we = ie.y;
            let ve = ie.fullyVisible;
            if (!ve) {
              const dt = ie.aabb.intersects(M);
              if (dt === 0) continue;
              ve = dt === 2;
            }
            const Ue = e.terrain ? k : z, nt = ie.aabb.distanceX(Ue), ht = ie.aabb.distanceY(Ue), pt = Math.max(Math.abs(nt), Math.abs(ht));
            if (ie.zoom === ee || pt > U + (1 << ee - ie.zoom) - 2 && ie.zoom >= O) {
              const dt = ee - ie.zoom, ut = k[0] - 0.5 - (he << dt), ft = k[1] - 0.5 - (we << dt);
              Q.push({ tileID: new c.S(ie.zoom === ee ? ne : ie.zoom, ie.wrap, ie.zoom, he, we), distanceSq: Ie([z[0] - 0.5 - he, z[1] - 0.5 - we]), tileDistanceToCamera: Math.sqrt(ut * ut + ft * ft) });
            } else for (let dt = 0; dt < 4; dt++) {
              const ut = (he << 1) + dt % 2, ft = (we << 1) + (dt >> 1), Ot = ie.zoom + 1;
              let _t = ie.aabb.quadrant(dt);
              if (e.terrain) {
                const vt = new c.S(Ot, ie.wrap, Ot, ut, ft), Vt = e.terrain.getMinMaxElevation(vt), ni = (r = Vt.minElevation) !== null && r !== void 0 ? r : this.elevation, ii = (s = Vt.maxElevation) !== null && s !== void 0 ? s : this.elevation;
                _t = new gn([_t.min[0], _t.min[1], ni], [_t.max[0], _t.max[1], ii]);
              }
              G.push({ aabb: _t, zoom: Ot, x: ut, y: ft, wrap: ie.wrap, fullyVisible: ve });
            }
          }
          return Q.sort((ie, he) => ie.distanceSq - he.distanceSq).map((ie) => ie.tileID);
        }
        resize(e, r) {
          this.width = e, this.height = r, this.pixelsToGLUnits = [2 / e, -2 / r], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e) {
          return Math.pow(2, e);
        }
        scaleZoom(e) {
          return Math.log(e) / Math.LN2;
        }
        project(e) {
          const r = c.ac(e.lat, -85.051129, uo);
          return new c.P(c.O(e.lng) * this.worldSize, c.Q(r) * this.worldSize);
        }
        unproject(e) {
          return new c.Z(e.x / this.worldSize, e.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(e) {
          const r = this.elevation, s = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, l = this.pointLocation(this.centerPoint, e), h = e.getElevationForLngLatZoom(l, this.tileZoom);
          if (!(this.elevation - h)) return;
          const y = s + r - h, b = Math.cos(this._pitch) * this.cameraToCenterDistance / y / c.b5(1, l.lat), I = this.scaleZoom(b / this.tileSize);
          this._elevation = h, this._center = l, this.zoom = I;
        }
        setLocationAtPoint(e, r) {
          const s = this.pointCoordinate(r), l = this.pointCoordinate(this.centerPoint), h = this.locationCoordinate(e), y = new c.Z(h.x - (s.x - l.x), h.y - (s.y - l.y));
          this.center = this.coordinateLocation(y), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(e, r) {
          return r ? this.coordinatePoint(this.locationCoordinate(e), r.getElevationForLngLatZoom(e, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e));
        }
        pointLocation(e, r) {
          return this.coordinateLocation(this.pointCoordinate(e, r));
        }
        locationCoordinate(e) {
          return c.Z.fromLngLat(e);
        }
        coordinateLocation(e) {
          return e && e.toLngLat();
        }
        pointCoordinate(e, r) {
          if (r) {
            const O = r.pointCoordinate(e);
            if (O != null) return O;
          }
          const s = [e.x, e.y, 0, 1], l = [e.x, e.y, 1, 1];
          c.af(s, s, this.pixelMatrixInverse), c.af(l, l, this.pixelMatrixInverse);
          const h = s[3], y = l[3], b = s[1] / h, I = l[1] / y, k = s[2] / h, z = l[2] / y, M = k === z ? 0 : (0 - k) / (z - k);
          return new c.Z(c.y.number(s[0] / h, l[0] / y, M) / this.worldSize, c.y.number(b, I, M) / this.worldSize);
        }
        coordinatePoint(e, r = 0, s = this.pixelMatrix) {
          const l = [e.x * this.worldSize, e.y * this.worldSize, r, 1];
          return c.af(l, l, s), new c.P(l[0] / l[3], l[1] / l[3]);
        }
        getBounds() {
          const e = Math.max(0, this.height / 2 - this.getHorizon());
          return new Y().extend(this.pointLocation(new c.P(0, e))).extend(this.pointLocation(new c.P(this.width, e))).extend(this.pointLocation(new c.P(this.width, this.height))).extend(this.pointLocation(new c.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Y([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(e) {
          e ? (this.lngRange = [e.getWest(), e.getEast()], this.latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, uo]);
        }
        calculateTileMatrix(e) {
          const r = e.canonical, s = this.worldSize / this.zoomScale(r.z), l = r.x + Math.pow(2, r.z) * e.wrap, h = c.an(new Float64Array(16));
          return c.J(h, h, [l * s, r.y * s, 0]), c.K(h, h, [s / c.X, s / c.X, 1]), h;
        }
        calculatePosMatrix(e, r = !1) {
          const s = e.key, l = r ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (l[s]) return l[s];
          const h = this.calculateTileMatrix(e);
          return c.L(h, r ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, h), l[s] = new Float32Array(h), l[s];
        }
        calculateFogMatrix(e) {
          const r = e.key, s = this._fogMatrixCache;
          if (s[r]) return s[r];
          const l = this.calculateTileMatrix(e);
          return c.L(l, this.fogMatrix, l), s[r] = new Float32Array(l), s[r];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(e, r) {
          r = c.ac(+r, this.minZoom, this.maxZoom);
          const s = { center: new c.N(e.lng, e.lat), zoom: r };
          let l = this.lngRange;
          if (!this._renderWorldCopies && l === null) {
            const ie = 179.9999999999;
            l = [-ie, ie];
          }
          const h = this.tileSize * this.zoomScale(s.zoom);
          let y = 0, b = h, I = 0, k = h, z = 0, M = 0;
          const { x: O, y: U } = this.size;
          if (this.latRange) {
            const ie = this.latRange;
            y = c.Q(ie[1]) * h, b = c.Q(ie[0]) * h, b - y < U && (z = U / (b - y));
          }
          l && (I = c.b3(c.O(l[0]) * h, 0, h), k = c.b3(c.O(l[1]) * h, 0, h), k < I && (k += h), k - I < O && (M = O / (k - I)));
          const { x: B, y: G } = this.project.call({ worldSize: h }, e);
          let Q, ee;
          const ne = Math.max(M || 0, z || 0);
          if (ne) {
            const ie = new c.P(M ? (k + I) / 2 : B, z ? (b + y) / 2 : G);
            return s.center = this.unproject.call({ worldSize: h }, ie).wrap(), s.zoom += this.scaleZoom(ne), s;
          }
          if (this.latRange) {
            const ie = U / 2;
            G - ie < y && (ee = y + ie), G + ie > b && (ee = b - ie);
          }
          if (l) {
            const ie = (I + k) / 2;
            let he = B;
            this._renderWorldCopies && (he = c.b3(B, ie - h / 2, ie + h / 2));
            const we = O / 2;
            he - we < I && (Q = I + we), he + we > k && (Q = k - we);
          }
          if (Q !== void 0 || ee !== void 0) {
            const ie = new c.P(Q ?? B, ee ?? G);
            s.center = this.unproject.call({ worldSize: h }, ie).wrap();
          }
          return s;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const e = this._unmodified, { center: r, zoom: s } = this.getConstrained(this.center, this.zoom);
          this.center = r, this.zoom = s, this._unmodified = e, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const e = this.centerOffset, r = this.point.x, s = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = c.b5(1, this.center.lat) * this.worldSize;
          let l = c.an(new Float64Array(16));
          c.K(l, l, [this.width / 2, -this.height / 2, 1]), c.J(l, l, [1, -1, 0]), this.labelPlaneMatrix = l, l = c.an(new Float64Array(16)), c.K(l, l, [1, -1, 1]), c.J(l, l, [-1, -1, 0]), c.K(l, l, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = l;
          const h = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), y = Math.min(this.elevation, this.minElevationForCurrentTile), b = h - y * this._pixelPerMeter / Math.cos(this._pitch), I = y < 0 ? b : h, k = Math.PI / 2 + this._pitch, z = this._fov * (0.5 + e.y / this.height), M = Math.sin(z) * I / Math.sin(c.ac(Math.PI - k - z, 0.01, Math.PI - 0.01)), O = this.getHorizon(), U = 2 * Math.atan(O / this.cameraToCenterDistance) * (0.5 + e.y / (2 * O)), B = Math.sin(U) * I / Math.sin(c.ac(Math.PI - k - U, 0.01, Math.PI - 0.01)), G = Math.min(M, B);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * G + I), this.nearZ = this.height / 50, l = new Float64Array(16), c.b6(l, this._fov, this.width / this.height, this.nearZ, this.farZ), l[8] = 2 * -e.x / this.width, l[9] = 2 * e.y / this.height, this.projectionMatrix = c.ae(l), c.K(l, l, [1, -1, 1]), c.J(l, l, [0, 0, -this.cameraToCenterDistance]), c.b7(l, l, this._pitch), c.ad(l, l, this.angle), c.J(l, l, [-r, -s, 0]), this.mercatorMatrix = c.K([], l, [this.worldSize, this.worldSize, this.worldSize]), c.K(l, l, [1, 1, this._pixelPerMeter]), this.pixelMatrix = c.L(new Float64Array(16), this.labelPlaneMatrix, l), c.J(l, l, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = l, this.invModelViewProjectionMatrix = c.as([], l), this.fogMatrix = new Float64Array(16), c.b6(this.fogMatrix, this._fov, this.width / this.height, h, this.farZ), this.fogMatrix[8] = 2 * -e.x / this.width, this.fogMatrix[9] = 2 * e.y / this.height, c.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.b7(this.fogMatrix, this.fogMatrix, this._pitch), c.ad(this.fogMatrix, this.fogMatrix, this.angle), c.J(this.fogMatrix, this.fogMatrix, [-r, -s, 0]), c.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = c.L(new Float64Array(16), this.labelPlaneMatrix, l);
          const Q = this.width % 2 / 2, ee = this.height % 2 / 2, ne = Math.cos(this.angle), ie = Math.sin(this.angle), he = r - Math.round(r) + ne * Q + ie * ee, we = s - Math.round(s) + ne * ee + ie * Q, ve = new Float64Array(l);
          if (c.J(ve, ve, [he > 0.5 ? he - 1 : he, we > 0.5 ? we - 1 : we, 0]), this.alignedModelViewProjectionMatrix = ve, l = c.as(new Float64Array(16), this.pixelMatrix), !l) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = l, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const e = this.pointCoordinate(new c.P(0, 0)), r = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
          return c.af(r, r, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new c.P(0, e));
        }
        getCameraQueryGeometry(e) {
          const r = this.getCameraPoint();
          if (e.length === 1) return [e[0], r];
          {
            let s = r.x, l = r.y, h = r.x, y = r.y;
            for (const b of e) s = Math.min(s, b.x), l = Math.min(l, b.y), h = Math.max(h, b.x), y = Math.max(y, b.y);
            return [new c.P(s, l), new c.P(h, l), new c.P(h, y), new c.P(s, y), new c.P(s, l)];
          }
        }
        lngLatToCameraDepth(e, r) {
          const s = this.locationCoordinate(e), l = [s.x * this.worldSize, s.y * this.worldSize, r, 1];
          return c.af(l, l, this.modelViewProjectionMatrix), l[2] / l[3];
        }
      }
      function jn(a, e) {
        let r, s = !1, l = null, h = null;
        const y = () => {
          l = null, s && (a.apply(h, r), l = setTimeout(y, e), s = !1);
        };
        return (...b) => (s = !0, h = this, r = b, l || y(), l);
      }
      class po {
        constructor(e) {
          this._getCurrentHash = () => {
            const r = window.location.hash.replace("#", "");
            if (this._hashName) {
              let s;
              return r.split("&").map((l) => l.split("=")).forEach((l) => {
                l[0] === this._hashName && (s = l);
              }), (s && s[1] || "").split("/");
            }
            return r.split("/");
          }, this._onHashChange = () => {
            const r = this._getCurrentHash();
            if (r.length >= 3 && !r.some((s) => isNaN(s))) {
              const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: s, pitch: +(r[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, r);
          }, this._removeHash = () => {
            const r = this._getCurrentHash();
            if (r.length === 0) return;
            const s = r.join("/");
            let l = s;
            l.split("&").length > 0 && (l = l.split("&")[0]), this._hashName && (l = `${this._hashName}=${s}`);
            let h = window.location.hash.replace(l, "");
            h.startsWith("#&") ? h = h.slice(0, 1) + h.slice(2) : h === "#" && (h = "");
            let y = window.location.href.replace(/(#.+)?$/, h);
            y = y.replace("&&", "&"), window.history.replaceState(window.history.state, null, y);
          }, this._updateHash = jn(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
        }
        addTo(e) {
          return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(e) {
          const r = this._map.getCenter(), s = Math.round(100 * this._map.getZoom()) / 100, l = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), h = Math.pow(10, l), y = Math.round(r.lng * h) / h, b = Math.round(r.lat * h) / h, I = this._map.getBearing(), k = this._map.getPitch();
          let z = "";
          if (z += e ? `/${y}/${b}/${s}` : `${s}/${b}/${y}`, (I || k) && (z += "/" + Math.round(10 * I) / 10), k && (z += `/${Math.round(k)}`), this._hashName) {
            const M = this._hashName;
            let O = !1;
            const U = window.location.hash.slice(1).split("&").map((B) => {
              const G = B.split("=")[0];
              return G === M ? (O = !0, `${G}=${z}`) : B;
            }).filter((B) => B);
            return O || U.push(`${M}=${z}`), `#${U.join("&")}`;
          }
          return `#${z}`;
        }
      }
      const cn = { linearity: 0.3, easing: c.b8(0, 0, 0.3, 1) }, hs = c.e({ deceleration: 2500, maxSpeed: 1400 }, cn), Xi = c.e({ deceleration: 20, maxSpeed: 1400 }, cn), Zi = c.e({ deceleration: 1e3, maxSpeed: 360 }, cn), sr = c.e({ deceleration: 1e3, maxSpeed: 90 }, cn);
      class xr {
        constructor(e) {
          this._map = e, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: j.now(), settings: e });
        }
        _drainInertiaBuffer() {
          const e = this._inertiaBuffer, r = j.now();
          for (; e.length > 0 && r - e[0].time > 160; ) e.shift();
        }
        _onMoveEnd(e) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const r = { zoom: 0, bearing: 0, pitch: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: h } of this._inertiaBuffer) r.zoom += h.zoomDelta || 0, r.bearing += h.bearingDelta || 0, r.pitch += h.pitchDelta || 0, h.panDelta && r.pan._add(h.panDelta), h.around && (r.around = h.around), h.pinchAround && (r.pinchAround = h.pinchAround);
          const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, l = {};
          if (r.pan.mag()) {
            const h = qn(r.pan.mag(), s, c.e({}, hs, e || {}));
            l.offset = r.pan.mult(h.amount / r.pan.mag()), l.center = this._map.transform.center, Pn(l, h);
          }
          if (r.zoom) {
            const h = qn(r.zoom, s, Xi);
            l.zoom = this._map.transform.zoom + h.amount, Pn(l, h);
          }
          if (r.bearing) {
            const h = qn(r.bearing, s, Zi);
            l.bearing = this._map.transform.bearing + c.ac(h.amount, -179, 179), Pn(l, h);
          }
          if (r.pitch) {
            const h = qn(r.pitch, s, sr);
            l.pitch = this._map.transform.pitch + h.amount, Pn(l, h);
          }
          if (l.zoom || l.bearing) {
            const h = r.pinchAround === void 0 ? r.around : r.pinchAround;
            l.around = h ? this._map.unproject(h) : this._map.getCenter();
          }
          return this.clear(), c.e(l, { noMoveStart: !0 });
        }
      }
      function Pn(a, e) {
        (!a.duration || a.duration < e.duration) && (a.duration = e.duration, a.easing = e.easing);
      }
      function qn(a, e, r) {
        const { maxSpeed: s, linearity: l, deceleration: h } = r, y = c.ac(a * l / (e / 1e3), -s, s), b = Math.abs(y) / (h * l);
        return { easing: r.easing, duration: 1e3 * b, amount: y * (b / 2) };
      }
      class br extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, s, l = {}) {
          const h = V.mousePos(r.getCanvas(), s), y = r.unproject(h);
          super(e, c.e({ point: h, lngLat: y, originalEvent: s }, l)), this._defaultPrevented = !1, this.target = r;
        }
      }
      class Ps extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, s) {
          const l = e === "touchend" ? s.changedTouches : s.touches, h = V.touchPos(r.getCanvasContainer(), l), y = h.map((I) => r.unproject(I)), b = h.reduce((I, k, z, M) => I.add(k.div(M.length)), new c.P(0, 0));
          super(e, { points: h, point: b, lngLats: y, lngLat: r.unproject(b), originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class Bl extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e, r, s) {
          super(e, { originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class Ol {
        constructor(e, r) {
          this._map = e, this._clickTolerance = r.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e) {
          return this._firePreventable(new Bl(e.type, this._map, e));
        }
        mousedown(e, r) {
          return this._mousedownPos = r, this._firePreventable(new br(e.type, this._map, e));
        }
        mouseup(e) {
          this._map.fire(new br(e.type, this._map, e));
        }
        click(e, r) {
          this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new br(e.type, this._map, e));
        }
        dblclick(e) {
          return this._firePreventable(new br(e.type, this._map, e));
        }
        mouseover(e) {
          this._map.fire(new br(e.type, this._map, e));
        }
        mouseout(e) {
          this._map.fire(new br(e.type, this._map, e));
        }
        touchstart(e) {
          return this._firePreventable(new Ps(e.type, this._map, e));
        }
        touchmove(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        touchend(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        touchcancel(e) {
          this._map.fire(new Ps(e.type, this._map, e));
        }
        _firePreventable(e) {
          if (this._map.fire(e), e.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class ur {
        constructor(e) {
          this._map = e;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(e) {
          this._map.fire(new br(e.type, this._map, e));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new br("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e) {
          this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new br(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Vn {
        constructor(e) {
          this._map = e;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e) {
          return this.transform.pointLocation(c.P.convert(e), this._map.terrain);
        }
      }
      class yn {
        constructor(e, r) {
          this._map = e, this._tr = new Vn(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = r.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(e, r) {
          this.isEnabled() && e.shiftKey && e.button === 0 && (V.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
        }
        mousemoveWindow(e, r) {
          if (!this._active) return;
          const s = r;
          if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance) return;
          const l = this._startPos;
          this._lastPos = s, this._box || (this._box = V.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
          const h = Math.min(l.x, s.x), y = Math.max(l.x, s.x), b = Math.min(l.y, s.y), I = Math.max(l.y, s.y);
          V.setTransform(this._box, `translate(${h}px,${b}px)`), this._box.style.width = y - h + "px", this._box.style.height = I - b + "px";
        }
        mouseupWindow(e, r) {
          if (!this._active || e.button !== 0) return;
          const s = this._startPos, l = r;
          if (this.reset(), V.suppressClick(), s.x !== l.x || s.y !== l.y) return this._map.fire(new c.k("boxzoomend", { originalEvent: e })), { cameraAnimation: (h) => h.fitScreenCoordinates(s, l, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", e);
        }
        keydown(e) {
          this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (V.remove(this._box), this._box = null), V.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e, r) {
          return this._map.fire(new c.k(e, { originalEvent: r }));
        }
      }
      function ha(a, e) {
        if (a.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${a.length}, points ${e.length}`);
        const r = {};
        for (let s = 0; s < a.length; s++) r[a[s].identifier] = e[s];
        return r;
      }
      class Ga {
        constructor(e) {
          this.reset(), this.numTouches = e.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(e, r, s) {
          (this.centroid || s.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), s.length === this.numTouches && (this.centroid = function(l) {
            const h = new c.P(0, 0);
            for (const y of l) h._add(y);
            return h.div(l.length);
          }(r), this.touches = ha(s, r)));
        }
        touchmove(e, r, s) {
          if (this.aborted || !this.centroid) return;
          const l = ha(s, r);
          for (const h in this.touches) {
            const y = l[h];
            (!y || y.dist(this.touches[h]) > 30) && (this.aborted = !0);
          }
        }
        touchend(e, r, s) {
          if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), s.length === 0) {
            const l = !this.aborted && this.centroid;
            if (this.reset(), l) return l;
          }
        }
      }
      class Mo {
        constructor(e) {
          this.singleTap = new Ga(e), this.numTaps = e.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e, r, s) {
          this.singleTap.touchstart(e, r, s);
        }
        touchmove(e, r, s) {
          this.singleTap.touchmove(e, r, s);
        }
        touchend(e, r, s) {
          const l = this.singleTap.touchend(e, r, s);
          if (l) {
            const h = e.timeStamp - this.lastTime < 500, y = !this.lastTap || this.lastTap.dist(l) < 30;
            if (h && y || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = l, this.count === this.numTaps) return this.reset(), l;
          }
        }
      }
      class zr {
        constructor(e) {
          this._tr = new Vn(e), this._zoomIn = new Mo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Mo({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e, r, s) {
          this._zoomIn.touchstart(e, r, s), this._zoomOut.touchstart(e, r, s);
        }
        touchmove(e, r, s) {
          this._zoomIn.touchmove(e, r, s), this._zoomOut.touchmove(e, r, s);
        }
        touchend(e, r, s) {
          const l = this._zoomIn.touchend(e, r, s), h = this._zoomOut.touchend(e, r, s), y = this._tr;
          return l ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (b) => b.easeTo({ duration: 300, zoom: y.zoom + 1, around: y.unproject(l) }, { originalEvent: e }) }) : h ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (b) => b.easeTo({ duration: 300, zoom: y.zoom - 1, around: y.unproject(h) }, { originalEvent: e }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Lr {
        constructor(e) {
          this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
        }
        reset(e) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
        }
        _move(...e) {
          const r = this._moveFunction(...e);
          if (r.bearingDelta || r.pitchDelta || r.around || r.panDelta) return this._active = !0, r;
        }
        dragStart(e, r) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = r.length ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(e, r) {
          if (!this.isEnabled()) return;
          const s = this._lastPoint;
          if (!s) return;
          if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
          const l = r.length ? r[0] : r;
          return !this._moved && l.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = l, this._move(s, l));
        }
        dragEnd(e) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && V.suppressClick(), this.reset(e));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const ua = { 0: 1, 2: 2 };
      class zo {
        constructor(e) {
          this._correctEvent = e.checkCorrectEvent;
        }
        startMove(e) {
          const r = V.mouseButton(e);
          this._eventButton = r;
        }
        endMove(e) {
          delete this._eventButton;
        }
        isValidStartEvent(e) {
          return this._correctEvent(e);
        }
        isValidMoveEvent(e) {
          return !function(r, s) {
            const l = ua[s];
            return r.buttons === void 0 || (r.buttons & l) !== l;
          }(e, this._eventButton);
        }
        isValidEndEvent(e) {
          return V.mouseButton(e) === this._eventButton;
        }
      }
      class gl {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(e) {
          return e.targetTouches.length === 1;
        }
        _isSameTouchEvent(e) {
          return e.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(e) {
          this._firstTouch = e.targetTouches[0].identifier;
        }
        endMove(e) {
          delete this._firstTouch;
        }
        isValidStartEvent(e) {
          return this._isOneFingerTouch(e);
        }
        isValidMoveEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
        isValidEndEvent(e) {
          return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
        }
      }
      const Do = (a) => {
        a.mousedown = a.dragStart, a.mousemoveWindow = a.dragMove, a.mouseup = a.dragEnd, a.contextmenu = (e) => {
          e.preventDefault();
        };
      }, da = ({ enable: a, clickTolerance: e, bearingDegreesPerPixelMoved: r = 0.8 }) => {
        const s = new zo({ checkCorrectEvent: (l) => V.mouseButton(l) === 0 && l.ctrlKey || V.mouseButton(l) === 2 });
        return new Lr({ clickTolerance: e, move: (l, h) => ({ bearingDelta: (h.x - l.x) * r }), moveStateManager: s, enable: a, assignEvents: Do });
      }, Wa = ({ enable: a, clickTolerance: e, pitchDegreesPerPixelMoved: r = -0.5 }) => {
        const s = new zo({ checkCorrectEvent: (l) => V.mouseButton(l) === 0 && l.ctrlKey || V.mouseButton(l) === 2 });
        return new Lr({ clickTolerance: e, move: (l, h) => ({ pitchDelta: (h.y - l.y) * r }), moveStateManager: s, enable: a, assignEvents: Do });
      };
      class fo {
        constructor(e, r) {
          this._clickTolerance = e.clickTolerance || 1, this._map = r, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new c.P(0, 0);
        }
        _shouldBePrevented(e) {
          return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(e, r, s) {
          return this._calculateTransform(e, r, s);
        }
        touchmove(e, r, s) {
          if (this._active) {
            if (!this._shouldBePrevented(s.length)) return e.preventDefault(), this._calculateTransform(e, r, s);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
          }
        }
        touchend(e, r, s) {
          this._calculateTransform(e, r, s), this._active && this._shouldBePrevented(s.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e, r, s) {
          s.length > 0 && (this._active = !0);
          const l = ha(s, r), h = new c.P(0, 0), y = new c.P(0, 0);
          let b = 0;
          for (const k in l) {
            const z = l[k], M = this._touches[k];
            M && (h._add(z), y._add(z.sub(M)), b++, l[k] = z);
          }
          if (this._touches = l, this._shouldBePrevented(b) || !y.mag()) return;
          const I = y.div(b);
          return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : { around: h.div(b), panDelta: I };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class pa {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(e, r, s) {
          this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier], this._start([r[0], r[1]]));
        }
        touchmove(e, r, s) {
          if (!this._firstTwoTouches) return;
          e.preventDefault();
          const [l, h] = this._firstTwoTouches, y = No(s, r, l), b = No(s, r, h);
          if (!y || !b) return;
          const I = this._aroundCenter ? null : y.add(b).div(2);
          return this._move([y, b], I, e);
        }
        touchend(e, r, s) {
          if (!this._firstTwoTouches) return;
          const [l, h] = this._firstTwoTouches, y = No(s, r, l), b = No(s, r, h);
          y && b || (this._active && V.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e) {
          this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function No(a, e, r) {
        for (let s = 0; s < a.length; s++) if (a[s].identifier === r) return e[s];
      }
      function fa(a, e) {
        return Math.log(a / e) / Math.LN2;
      }
      class Ha extends pa {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e) {
          this._startDistance = this._distance = e[0].dist(e[1]);
        }
        _move(e, r) {
          const s = this._distance;
          if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(fa(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: fa(this._distance, s), pinchAround: r };
        }
      }
      function jl(a, e) {
        return 180 * a.angleWith(e) / Math.PI;
      }
      class ql extends pa {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e) {
          this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
        }
        _move(e, r, s) {
          const l = this._vector;
          if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: jl(this._vector, l), pinchAround: r };
        }
        _isBelowThreshold(e) {
          this._minDiameter = Math.min(this._minDiameter, e.mag());
          const r = 25 / (Math.PI * this._minDiameter) * 360, s = jl(e, this._startVector);
          return Math.abs(s) < r;
        }
      }
      function Xa(a) {
        return Math.abs(a.y) > Math.abs(a.x);
      }
      class ma extends pa {
        constructor(e) {
          super(), this._currentTouchCount = 0, this._map = e;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(e, r, s) {
          super.touchstart(e, r, s), this._currentTouchCount = s.length;
        }
        _start(e) {
          this._lastPoints = e, Xa(e[0].sub(e[1])) && (this._valid = !1);
        }
        _move(e, r, s) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const l = e[0].sub(this._lastPoints[0]), h = e[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(l, h, s.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (l.y + h.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(e, r, s) {
          if (this._valid !== void 0) return this._valid;
          const l = e.mag() >= 2, h = r.mag() >= 2;
          if (!l && !h) return;
          if (!l || !h) return this._firstMove === void 0 && (this._firstMove = s), s - this._firstMove < 100 && void 0;
          const y = e.y > 0 == r.y > 0;
          return Xa(e) && Xa(r) && y;
        }
      }
      const ac = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Un {
        constructor(e) {
          this._tr = new Vn(e);
          const r = ac;
          this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) return;
          let r = 0, s = 0, l = 0, h = 0, y = 0;
          switch (e.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              r = 1;
              break;
            case 189:
            case 109:
            case 173:
              r = -1;
              break;
            case 37:
              e.shiftKey ? s = -1 : (e.preventDefault(), h = -1);
              break;
            case 39:
              e.shiftKey ? s = 1 : (e.preventDefault(), h = 1);
              break;
            case 38:
              e.shiftKey ? l = 1 : (e.preventDefault(), y = -1);
              break;
            case 40:
              e.shiftKey ? l = -1 : (e.preventDefault(), y = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (s = 0, l = 0), { cameraAnimation: (b) => {
            const I = this._tr;
            b.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Is, zoom: r ? Math.round(I.zoom) + r * (e.shiftKey ? 2 : 1) : I.zoom, bearing: I.bearing + s * this._bearingStep, pitch: I.pitch + l * this._pitchStep, offset: [-h * this._panStep, -y * this._panStep], center: I.center }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Is(a) {
        return a * (2 - a);
      }
      const Vl = 4.000244140625;
      class In {
        constructor(e, r) {
          this._onTimeout = (s) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(s);
          }, this._map = e, this._tr = new Vn(e), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(e) {
          this._defaultZoomRate = e;
        }
        setWheelZoomRate(e) {
          this._wheelZoomRate = e;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(e) {
          return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
        }
        wheel(e) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
          let r = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
          const s = j.now(), l = s - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = s, r !== 0 && r % Vl == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : l > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(l * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), e.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = e, this._delta -= r, this._active || this._start(e)), e.preventDefault();
        }
        _start(e) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const r = V.mousePos(this._map.getCanvas(), e), s = this._tr;
          this._around = r.y > s.transform.height / 2 - s.transform.getHorizon() ? c.N.convert(this._aroundCenter ? s.center : s.unproject(r)) : c.N.convert(s.center), this._aroundPoint = s.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const e = this._tr.transform;
          if (this._delta !== 0) {
            const I = this._type === "wheel" && Math.abs(this._delta) > Vl ? this._wheelZoomRate : this._defaultZoomRate;
            let k = 2 / (1 + Math.exp(-Math.abs(this._delta * I)));
            this._delta < 0 && k !== 0 && (k = 1 / k);
            const z = typeof this._targetZoom == "number" ? e.zoomScale(this._targetZoom) : e.scale;
            this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(z * k))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const r = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, s = this._startZoom, l = this._easing;
          let h, y = !1;
          const b = j.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && s && l && b) {
            const I = Math.min(b / 200, 1), k = l(I);
            h = c.y.number(s, r, k), I < 1 ? this._frameId || (this._frameId = !0) : y = !0;
          } else h = r, y = !0;
          return this._active = !0, y && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !y, zoomDelta: h - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e) {
          let r = c.b9;
          if (this._prevEase) {
            const s = this._prevEase, l = (j.now() - s.start) / s.duration, h = s.easing(l + 0.01) - s.easing(l), y = 0.27 / Math.sqrt(h * h + 1e-4) * 0.01, b = Math.sqrt(0.0729 - y * y);
            r = c.b8(y, b, 0.25, 1);
          }
          return this._prevEase = { start: j.now(), duration: e, easing: r }, r;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Zs {
        constructor(e, r) {
          this._clickZoom = e, this._tapZoom = r;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ya {
        constructor(e) {
          this._tr = new Vn(e), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(e, r) {
          return e.preventDefault(), { cameraAnimation: (s) => {
            s.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: e });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Vc {
        constructor() {
          this._tap = new Mo({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(e, r, s) {
          if (!this._swipePoint) if (this._tapTime) {
            const l = r[0], h = e.timeStamp - this._tapTime < 500, y = this._tapPoint.dist(l) < 30;
            h && y ? s.length > 0 && (this._swipePoint = l, this._swipeTouch = s[0].identifier) : this.reset();
          } else this._tap.touchstart(e, r, s);
        }
        touchmove(e, r, s) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (s[0].identifier !== this._swipeTouch) return;
              const l = r[0], h = l.y - this._swipePoint.y;
              return this._swipePoint = l, e.preventDefault(), this._active = !0, { zoomDelta: h / 128 };
            }
          } else this._tap.touchmove(e, r, s);
        }
        touchend(e, r, s) {
          if (this._tapTime) this._swipePoint && s.length === 0 && this.reset();
          else {
            const l = this._tap.touchend(e, r, s);
            l && (this._tapTime = e.timeStamp, this._tapPoint = l);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class lc {
        constructor(e, r, s) {
          this._el = e, this._mousePan = r, this._touchPan = s;
        }
        enable(e) {
          this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Ul {
        constructor(e, r, s) {
          this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = r, this._mousePitch = s;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class $l {
        constructor(e, r, s, l) {
          this._el = e, this._touchZoom = r, this._touchRotate = s, this._tapDragZoom = l, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(e) {
          this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class ga {
        constructor(e, r) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = r, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const e = this._map.getCanvasContainer();
          e.classList.add("maplibregl-cooperative-gestures"), this._container = V.create("div", "maplibregl-cooperative-gesture-screen", e);
          let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), l = document.createElement("div");
          l.className = "maplibregl-desktop-message", l.textContent = r, this._container.appendChild(l);
          const h = document.createElement("div");
          h.className = "maplibregl-mobile-message", h.textContent = s, this._container.appendChild(h), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (V.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(e) {
          return e[this._bypassKey];
        }
        notifyGestureBlocked(e, r) {
          this._enabled && (this._map.fire(new c.k("cooperativegestureprevented", { gestureType: e, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const $n = (a) => a.zoom || a.drag || a.pitch || a.rotate;
      class Nt extends c.k {
      }
      function us(a) {
        return a.panDelta && a.panDelta.mag() || a.zoomDelta || a.bearingDelta || a.pitchDelta;
      }
      class Ln {
        constructor(e, r) {
          this.handleWindowEvent = (l) => {
            this.handleEvent(l, `${l.type}Window`);
          }, this.handleEvent = (l, h) => {
            if (l.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const y = l.type === "renderFrame" ? void 0 : l, b = { needsRenderFrame: !1 }, I = {}, k = {}, z = l.touches, M = z ? this._getMapTouches(z) : void 0, O = M ? V.touchPos(this._map.getCanvas(), M) : V.mousePos(this._map.getCanvas(), l);
            for (const { handlerName: G, handler: Q, allowed: ee } of this._handlers) {
              if (!Q.isEnabled()) continue;
              let ne;
              this._blockedByActive(k, ee, G) ? Q.reset() : Q[h || l.type] && (ne = Q[h || l.type](l, O, M), this.mergeHandlerResult(b, I, ne, G, y), ne && ne.needsRenderFrame && this._triggerRenderFrame()), (ne || Q.isActive()) && (k[G] = Q);
            }
            const U = {};
            for (const G in this._previousActiveHandlers) k[G] || (U[G] = y);
            this._previousActiveHandlers = k, (Object.keys(U).length || us(b)) && (this._changes.push([b, I, U]), this._triggerRenderFrame()), (Object.keys(k).length || us(b)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: B } = b;
            B && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], B(this._map));
          }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new xr(e), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
          const s = this._el;
          this._listeners = [[s, "touchstart", { passive: !0 }], [s, "touchmove", { passive: !1 }], [s, "touchend", void 0], [s, "touchcancel", void 0], [s, "mousedown", void 0], [s, "mousemove", void 0], [s, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [s, "mouseover", void 0], [s, "mouseout", void 0], [s, "dblclick", void 0], [s, "click", void 0], [s, "keydown", { capture: !1 }], [s, "keyup", void 0], [s, "wheel", { passive: !1 }], [s, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [l, h, y] of this._listeners) V.addEventListener(l, h, l === document ? this.handleWindowEvent : this.handleEvent, y);
        }
        destroy() {
          for (const [e, r, s] of this._listeners) V.removeEventListener(e, r, e === document ? this.handleWindowEvent : this.handleEvent, s);
        }
        _addDefaultHandlers(e) {
          const r = this._map, s = r.getCanvasContainer();
          this._add("mapEvent", new Ol(r, e));
          const l = r.boxZoom = new yn(r, e);
          this._add("boxZoom", l), e.interactive && e.boxZoom && l.enable();
          const h = r.cooperativeGestures = new ga(r, e.cooperativeGestures);
          this._add("cooperativeGestures", h), e.cooperativeGestures && h.enable();
          const y = new zr(r), b = new Ya(r);
          r.doubleClickZoom = new Zs(b, y), this._add("tapZoom", y), this._add("clickZoom", b), e.interactive && e.doubleClickZoom && r.doubleClickZoom.enable();
          const I = new Vc();
          this._add("tapDragZoom", I);
          const k = r.touchPitch = new ma(r);
          this._add("touchPitch", k), e.interactive && e.touchPitch && r.touchPitch.enable(e.touchPitch);
          const z = da(e), M = Wa(e);
          r.dragRotate = new Ul(e, z, M), this._add("mouseRotate", z, ["mousePitch"]), this._add("mousePitch", M, ["mouseRotate"]), e.interactive && e.dragRotate && r.dragRotate.enable();
          const O = (({ enable: ne, clickTolerance: ie }) => {
            const he = new zo({ checkCorrectEvent: (we) => V.mouseButton(we) === 0 && !we.ctrlKey });
            return new Lr({ clickTolerance: ie, move: (we, ve) => ({ around: ve, panDelta: ve.sub(we) }), activateOnStart: !0, moveStateManager: he, enable: ne, assignEvents: Do });
          })(e), U = new fo(e, r);
          r.dragPan = new lc(s, O, U), this._add("mousePan", O), this._add("touchPan", U, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && r.dragPan.enable(e.dragPan);
          const B = new ql(), G = new Ha();
          r.touchZoomRotate = new $l(s, G, B, I), this._add("touchRotate", B, ["touchPan", "touchZoom"]), this._add("touchZoom", G, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && r.touchZoomRotate.enable(e.touchZoomRotate);
          const Q = r.scrollZoom = new In(r, () => this._triggerRenderFrame());
          this._add("scrollZoom", Q, ["mousePan"]), e.interactive && e.scrollZoom && r.scrollZoom.enable(e.scrollZoom);
          const ee = r.keyboard = new Un(r);
          this._add("keyboard", ee), e.interactive && e.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new ur(r));
        }
        _add(e, r, s) {
          this._handlers.push({ handlerName: e, handler: r, allowed: s }), this._handlersById[e] = r;
        }
        stop(e) {
          if (!this._updatingCamera) {
            for (const { handler: r } of this._handlers) r.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e } of this._handlers) if (e.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!$n(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(e, r, s) {
          for (const l in e) if (l !== s && (!r || r.indexOf(l) < 0)) return !0;
          return !1;
        }
        _getMapTouches(e) {
          const r = [];
          for (const s of e) this._el.contains(s.target) && r.push(s);
          return r;
        }
        mergeHandlerResult(e, r, s, l, h) {
          if (!s) return;
          c.e(e, s);
          const y = { handlerName: l, originalEvent: s.originalEvent || h };
          s.zoomDelta !== void 0 && (r.zoom = y), s.panDelta !== void 0 && (r.drag = y), s.pitchDelta !== void 0 && (r.pitch = y), s.bearingDelta !== void 0 && (r.rotate = y);
        }
        _applyChanges() {
          const e = {}, r = {}, s = {};
          for (const [l, h, y] of this._changes) l.panDelta && (e.panDelta = (e.panDelta || new c.P(0, 0))._add(l.panDelta)), l.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + l.zoomDelta), l.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + l.bearingDelta), l.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + l.pitchDelta), l.around !== void 0 && (e.around = l.around), l.pinchAround !== void 0 && (e.pinchAround = l.pinchAround), l.noInertia && (e.noInertia = l.noInertia), c.e(r, h), c.e(s, y);
          this._updateMapTransform(e, r, s), this._changes = [];
        }
        _updateMapTransform(e, r, s) {
          const l = this._map, h = l._getTransformForUpdate(), y = l.terrain;
          if (!(us(e) || y && this._terrainMovement)) return this._fireEvents(r, s, !0);
          let { panDelta: b, zoomDelta: I, bearingDelta: k, pitchDelta: z, around: M, pinchAround: O } = e;
          O !== void 0 && (M = O), l._stop(!0), M = M || l.transform.centerPoint;
          const U = h.pointLocation(b ? M.sub(b) : M);
          k && (h.bearing += k), z && (h.pitch += z), I && (h.zoom += I), y ? this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? h.center = h.pointLocation(h.centerPoint.sub(b)) : h.setLocationAtPoint(U, M) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, h.setLocationAtPoint(U, M)) : h.setLocationAtPoint(U, M), l._applyUpdatedTransform(h), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(r, s, !0);
        }
        _fireEvents(e, r, s) {
          const l = $n(this._eventsInProgress), h = $n(e), y = {};
          for (const M in e) {
            const { originalEvent: O } = e[M];
            this._eventsInProgress[M] || (y[`${M}start`] = O), this._eventsInProgress[M] = e[M];
          }
          !l && h && this._fireEvent("movestart", h.originalEvent);
          for (const M in y) this._fireEvent(M, y[M]);
          h && this._fireEvent("move", h.originalEvent);
          for (const M in e) {
            const { originalEvent: O } = e[M];
            this._fireEvent(M, O);
          }
          const b = {};
          let I;
          for (const M in this._eventsInProgress) {
            const { handlerName: O, originalEvent: U } = this._eventsInProgress[M];
            this._handlersById[O].isActive() || (delete this._eventsInProgress[M], I = r[O] || U, b[`${M}end`] = I);
          }
          for (const M in b) this._fireEvent(M, b[M]);
          const k = $n(this._eventsInProgress), z = (l || h) && !k;
          if (z && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const M = this._map._getTransformForUpdate();
            M.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(M);
          }
          if (s && z) {
            this._updatingCamera = !0;
            const M = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), O = (U) => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
            !M || !M.essential && j.prefersReducedMotion ? (this._map.fire(new c.k("moveend", { originalEvent: I })), O(this._map.getBearing()) && this._map.resetNorth()) : (O(M.bearing || this._map.getBearing()) && (M.bearing = 0), M.freezeElevation = !0, this._map.easeTo(M, { originalEvent: I })), this._updatingCamera = !1;
          }
        }
        _fireEvent(e, r) {
          this._map.fire(new c.k(e, r ? { originalEvent: r } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e) => {
            delete this._frameId, this.handleEvent(new Nt("renderFrame", { timeStamp: e })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Ls extends c.E {
        constructor(e, r) {
          super(), this._renderFrameCallback = () => {
            const s = Math.min((j.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(s)), s < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = r.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new c.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e, r) {
          return this.jumpTo({ center: e }, r);
        }
        panBy(e, r, s) {
          return e = c.P.convert(e).mult(-1), this.panTo(this.transform.center, c.e({ offset: e }, r), s);
        }
        panTo(e, r, s) {
          return this.easeTo(c.e({ center: e }, r), s);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e, r) {
          return this.jumpTo({ zoom: e }, r), this;
        }
        zoomTo(e, r, s) {
          return this.easeTo(c.e({ zoom: e }, r), s);
        }
        zoomIn(e, r) {
          return this.zoomTo(this.getZoom() + 1, e, r), this;
        }
        zoomOut(e, r) {
          return this.zoomTo(this.getZoom() - 1, e, r), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e, r) {
          return this.jumpTo({ bearing: e }, r), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e, r) {
          return this.jumpTo({ padding: e }, r), this;
        }
        rotateTo(e, r, s) {
          return this.easeTo(c.e({ bearing: e }, r), s);
        }
        resetNorth(e, r) {
          return this.rotateTo(0, c.e({ duration: 1e3 }, e), r), this;
        }
        resetNorthPitch(e, r) {
          return this.easeTo(c.e({ bearing: 0, pitch: 0, duration: 1e3 }, e), r), this;
        }
        snapToNorth(e, r) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, r) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e, r) {
          return this.jumpTo({ pitch: e }, r), this;
        }
        cameraForBounds(e, r) {
          e = Y.convert(e).adjustAntiMeridian();
          const s = r && r.bearing || 0;
          return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), s, r);
        }
        _cameraForBoxAndBearing(e, r, s, l) {
          const h = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (l = c.e({ padding: h, offset: [0, 0], maxZoom: this.transform.maxZoom }, l)).padding == "number") {
            const dt = l.padding;
            l.padding = { top: dt, bottom: dt, right: dt, left: dt };
          }
          l.padding = c.e(h, l.padding);
          const y = this.transform, b = y.padding, I = new Y(e, r), k = y.project(I.getNorthWest()), z = y.project(I.getNorthEast()), M = y.project(I.getSouthEast()), O = y.project(I.getSouthWest()), U = c.ba(-s), B = k.rotate(U), G = z.rotate(U), Q = M.rotate(U), ee = O.rotate(U), ne = new c.P(Math.max(B.x, G.x, ee.x, Q.x), Math.max(B.y, G.y, ee.y, Q.y)), ie = new c.P(Math.min(B.x, G.x, ee.x, Q.x), Math.min(B.y, G.y, ee.y, Q.y)), he = ne.sub(ie), we = (y.width - (b.left + b.right + l.padding.left + l.padding.right)) / he.x, ve = (y.height - (b.top + b.bottom + l.padding.top + l.padding.bottom)) / he.y;
          if (ve < 0 || we < 0) return void c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const Ue = Math.min(y.scaleZoom(y.scale * Math.min(we, ve)), l.maxZoom), nt = c.P.convert(l.offset), ht = new c.P((l.padding.left - l.padding.right) / 2, (l.padding.top - l.padding.bottom) / 2).rotate(c.ba(s)), pt = nt.add(ht).mult(y.scale / y.zoomScale(Ue));
          return { center: y.unproject(k.add(M).div(2).sub(pt)), zoom: Ue, bearing: s };
        }
        fitBounds(e, r, s) {
          return this._fitInternal(this.cameraForBounds(e, r), r, s);
        }
        fitScreenCoordinates(e, r, s, l, h) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(c.P.convert(e)), this.transform.pointLocation(c.P.convert(r)), s, l), l, h);
        }
        _fitInternal(e, r, s) {
          return e ? (delete (r = c.e(e, r)).padding, r.linear ? this.easeTo(r, s) : this.flyTo(r, s)) : this;
        }
        jumpTo(e, r) {
          this.stop();
          const s = this._getTransformForUpdate();
          let l = !1, h = !1, y = !1;
          return "zoom" in e && s.zoom !== +e.zoom && (l = !0, s.zoom = +e.zoom), e.center !== void 0 && (s.center = c.N.convert(e.center)), "bearing" in e && s.bearing !== +e.bearing && (h = !0, s.bearing = +e.bearing), "pitch" in e && s.pitch !== +e.pitch && (y = !0, s.pitch = +e.pitch), e.padding == null || s.isPaddingEqual(e.padding) || (s.padding = e.padding), this._applyUpdatedTransform(s), this.fire(new c.k("movestart", r)).fire(new c.k("move", r)), l && this.fire(new c.k("zoomstart", r)).fire(new c.k("zoom", r)).fire(new c.k("zoomend", r)), h && this.fire(new c.k("rotatestart", r)).fire(new c.k("rotate", r)).fire(new c.k("rotateend", r)), y && this.fire(new c.k("pitchstart", r)).fire(new c.k("pitch", r)).fire(new c.k("pitchend", r)), this.fire(new c.k("moveend", r));
        }
        calculateCameraOptionsFromTo(e, r, s, l = 0) {
          const h = c.Z.fromLngLat(e, r), y = c.Z.fromLngLat(s, l), b = y.x - h.x, I = y.y - h.y, k = y.z - h.z, z = Math.hypot(b, I, k);
          if (z === 0) throw new Error("Can't calculate camera options with same From and To");
          const M = Math.hypot(b, I), O = this.transform.scaleZoom(this.transform.cameraToCenterDistance / z / this.transform.tileSize), U = 180 * Math.atan2(b, -I) / Math.PI;
          let B = 180 * Math.acos(M / z) / Math.PI;
          return B = k < 0 ? 90 - B : 90 + B, { center: y.toLngLat(), zoom: O, pitch: B, bearing: U };
        }
        easeTo(e, r) {
          var s;
          this._stop(!1, e.easeId), ((e = c.e({ offset: [0, 0], duration: 500, easing: c.b9 }, e)).animate === !1 || !e.essential && j.prefersReducedMotion) && (e.duration = 0);
          const l = this._getTransformForUpdate(), h = l.zoom, y = l.bearing, b = l.pitch, I = l.padding, k = "bearing" in e ? this._normalizeBearing(e.bearing, y) : y, z = "pitch" in e ? +e.pitch : b, M = "padding" in e ? e.padding : l.padding, O = c.P.convert(e.offset);
          let U = l.centerPoint.add(O);
          const B = l.pointLocation(U), { center: G, zoom: Q } = l.getConstrained(c.N.convert(e.center || B), (s = e.zoom) !== null && s !== void 0 ? s : h);
          this._normalizeCenter(G, l);
          const ee = l.project(B), ne = l.project(G).sub(ee), ie = l.zoomScale(Q - h);
          let he, we;
          e.around && (he = c.N.convert(e.around), we = l.locationPoint(he));
          const ve = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || Q !== h, this._rotating = this._rotating || y !== k, this._pitching = this._pitching || z !== b, this._padding = !l.isPaddingEqual(M), this._easeId = e.easeId, this._prepareEase(r, e.noMoveStart, ve), this.terrain && this._prepareElevation(G), this._ease((Ue) => {
            if (this._zooming && (l.zoom = c.y.number(h, Q, Ue)), this._rotating && (l.bearing = c.y.number(y, k, Ue)), this._pitching && (l.pitch = c.y.number(b, z, Ue)), this._padding && (l.interpolatePadding(I, M, Ue), U = l.centerPoint.add(O)), this.terrain && !e.freezeElevation && this._updateElevation(Ue), he) l.setLocationAtPoint(he, we);
            else {
              const nt = l.zoomScale(l.zoom - h), ht = Q > h ? Math.min(2, ie) : Math.max(0.5, ie), pt = Math.pow(ht, 1 - Ue), dt = l.unproject(ee.add(ne.mult(Ue * pt)).mult(nt));
              l.setLocationAtPoint(l.renderWorldCopies ? dt.wrap() : dt, U);
            }
            this._applyUpdatedTransform(l), this._fireMoveEvents(r);
          }, (Ue) => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r, Ue);
          }, e), this;
        }
        _prepareEase(e, r, s = {}) {
          this._moving = !0, r || s.moving || this.fire(new c.k("movestart", e)), this._zooming && !s.zooming && this.fire(new c.k("zoomstart", e)), this._rotating && !s.rotating && this.fire(new c.k("rotatestart", e)), this._pitching && !s.pitching && this.fire(new c.k("pitchstart", e));
        }
        _prepareElevation(e) {
          this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(e) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e < 1 && r !== this._elevationTarget) {
            const s = this._elevationTarget - this._elevationStart;
            this._elevationStart += e * (s - (r - (s * e + this._elevationStart)) / (1 - e)), this._elevationTarget = r;
          }
          this.transform.elevation = c.y.number(this._elevationStart, this._elevationTarget, e);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(e) {
          const r = e.getCameraPosition(), s = this.terrain.getElevationForLngLatZoom(r.lngLat, e.zoom);
          if (r.altitude < s) {
            const l = this.calculateCameraOptionsFromTo(r.lngLat, s, e.center, e.elevation);
            return { pitch: l.pitch, zoom: l.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(e) {
          const r = [];
          if (this.terrain && r.push((l) => this._elevateCameraIfInsideTerrain(l)), this.transformCameraUpdate && r.push((l) => this.transformCameraUpdate(l)), !r.length) return;
          const s = e.clone();
          for (const l of r) {
            const h = s.clone(), { center: y, zoom: b, pitch: I, bearing: k, elevation: z } = l(h);
            y && (h.center = y), b !== void 0 && (h.zoom = b), I !== void 0 && (h.pitch = I), k !== void 0 && (h.bearing = k), z !== void 0 && (h.elevation = z), s.apply(h);
          }
          this.transform.apply(s);
        }
        _fireMoveEvents(e) {
          this.fire(new c.k("move", e)), this._zooming && this.fire(new c.k("zoom", e)), this._rotating && this.fire(new c.k("rotate", e)), this._pitching && this.fire(new c.k("pitch", e));
        }
        _afterEase(e, r) {
          if (this._easeId && r && this._easeId === r) return;
          delete this._easeId;
          const s = this._zooming, l = this._rotating, h = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, s && this.fire(new c.k("zoomend", e)), l && this.fire(new c.k("rotateend", e)), h && this.fire(new c.k("pitchend", e)), this.fire(new c.k("moveend", e));
        }
        flyTo(e, r) {
          var s;
          if (!e.essential && j.prefersReducedMotion) {
            const vt = c.M(e, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(vt, r);
          }
          this.stop(), e = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.b9 }, e);
          const l = this._getTransformForUpdate(), h = l.zoom, y = l.bearing, b = l.pitch, I = l.padding, k = "bearing" in e ? this._normalizeBearing(e.bearing, y) : y, z = "pitch" in e ? +e.pitch : b, M = "padding" in e ? e.padding : l.padding, O = c.P.convert(e.offset);
          let U = l.centerPoint.add(O);
          const B = l.pointLocation(U), { center: G, zoom: Q } = l.getConstrained(c.N.convert(e.center || B), (s = e.zoom) !== null && s !== void 0 ? s : h);
          this._normalizeCenter(G, l);
          const ee = l.zoomScale(Q - h), ne = l.project(B), ie = l.project(G).sub(ne);
          let he = e.curve;
          const we = Math.max(l.width, l.height), ve = we / ee, Ue = ie.mag();
          if ("minZoom" in e) {
            const vt = c.ac(Math.min(e.minZoom, h, Q), l.minZoom, l.maxZoom), Vt = we / l.zoomScale(vt - h);
            he = Math.sqrt(Vt / Ue * 2);
          }
          const nt = he * he;
          function ht(vt) {
            const Vt = (ve * ve - we * we + (vt ? -1 : 1) * nt * nt * Ue * Ue) / (2 * (vt ? ve : we) * nt * Ue);
            return Math.log(Math.sqrt(Vt * Vt + 1) - Vt);
          }
          function pt(vt) {
            return (Math.exp(vt) - Math.exp(-vt)) / 2;
          }
          function dt(vt) {
            return (Math.exp(vt) + Math.exp(-vt)) / 2;
          }
          const ut = ht(!1);
          let ft = function(vt) {
            return dt(ut) / dt(ut + he * vt);
          }, Ot = function(vt) {
            return we * ((dt(ut) * (pt(Vt = ut + he * vt) / dt(Vt)) - pt(ut)) / nt) / Ue;
            var Vt;
          }, _t = (ht(!0) - ut) / he;
          if (Math.abs(Ue) < 1e-6 || !isFinite(_t)) {
            if (Math.abs(we - ve) < 1e-6) return this.easeTo(e, r);
            const vt = ve < we ? -1 : 1;
            _t = Math.abs(Math.log(ve / we)) / he, Ot = () => 0, ft = (Vt) => Math.exp(vt * he * Vt);
          }
          return e.duration = "duration" in e ? +e.duration : 1e3 * _t / ("screenSpeed" in e ? +e.screenSpeed / he : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = y !== k, this._pitching = z !== b, this._padding = !l.isPaddingEqual(M), this._prepareEase(r, !1), this.terrain && this._prepareElevation(G), this._ease((vt) => {
            const Vt = vt * _t, ni = 1 / ft(Vt);
            l.zoom = vt === 1 ? Q : h + l.scaleZoom(ni), this._rotating && (l.bearing = c.y.number(y, k, vt)), this._pitching && (l.pitch = c.y.number(b, z, vt)), this._padding && (l.interpolatePadding(I, M, vt), U = l.centerPoint.add(O)), this.terrain && !e.freezeElevation && this._updateElevation(vt);
            const ii = vt === 1 ? G : l.unproject(ne.add(ie.mult(Ot(Vt))).mult(ni));
            l.setLocationAtPoint(l.renderWorldCopies ? ii.wrap() : ii, U), this._applyUpdatedTransform(l), this._fireMoveEvents(r);
          }, () => {
            this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(r);
          }, e), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e, r) {
          var s;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const l = this._onEaseEnd;
            delete this._onEaseEnd, l.call(this, r);
          }
          return e || (s = this.handlers) === null || s === void 0 || s.stop(!1), this;
        }
        _ease(e, r, s) {
          s.animate === !1 || s.duration === 0 ? (e(1), r()) : (this._easeStart = j.now(), this._easeOptions = s, this._onEaseFrame = e, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e, r) {
          e = c.b3(e, -180, 180);
          const s = Math.abs(e - r);
          return Math.abs(e - 360 - r) < s && (e -= 360), Math.abs(e + 360 - r) < s && (e += 360), e;
        }
        _normalizeCenter(e, r) {
          if (!r.renderWorldCopies || r.lngRange) return;
          const s = e.lng - r.center.lng;
          e.lng += s > 180 ? -360 : s < -180 ? 360 : 0;
        }
        queryTerrainElevation(e) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(c.N.convert(e), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const ya = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class Fo {
        constructor(e = ya) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (r) => {
            !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e) {
          return this._map = e, this._compact = this.options.compact, this._container = V.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = V.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = V.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          V.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e, r) {
          const s = this._map._getUIString(`AttributionControl.${r}`);
          e.title = s, e.setAttribute("aria-label", s);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let e = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((l) => typeof l != "string" ? "" : l)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const l = this._map.style.stylesheet;
            this.styleOwner = l.owner, this.styleId = l.id;
          }
          const r = this._map.style.sourceCaches;
          for (const l in r) {
            const h = r[l];
            if (h.used || h.usedForTerrain) {
              const y = h.getSource();
              y.attribution && e.indexOf(y.attribution) < 0 && e.push(y.attribution);
            }
          }
          e = e.filter((l) => String(l).trim()), e.sort((l, h) => l.length - h.length), e = e.filter((l, h) => {
            for (let y = h + 1; y < e.length; y++) if (e[y].indexOf(l) >= 0) return !1;
            return !0;
          });
          const s = e.join(" | ");
          s !== this._attribHTML && (this._attribHTML = s, e.length ? (this._innerContainer.innerHTML = s, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class Ts {
        constructor(e = {}) {
          this._updateCompact = () => {
            const r = this._container.children;
            if (r.length) {
              const s = r[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact");
            }
          }, this.options = e;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(e) {
          this._map = e, this._compact = this.options && this.options.compact, this._container = V.create("div", "maplibregl-ctrl");
          const r = V.create("a", "maplibregl-ctrl-logo");
          return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          V.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class fi {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(e) {
          const r = ++this._id;
          return this._queue.push({ callback: e, id: r, cancelled: !1 }), r;
        }
        remove(e) {
          const r = this._currentlyRunning, s = r ? this._queue.concat(r) : this._queue;
          for (const l of s) if (l.id === e) return void (l.cancelled = !0);
        }
        run(e = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const r = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const s of r) if (!s.cancelled && (s.callback(e), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var Zl = c.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Uc extends c.E {
        constructor(e) {
          super(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e.usedForTerrain = !0, e.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(e, r) {
          this.sourceCache.update(e, r), this._renderableTilesKeys = [];
          const s = {};
          for (const l of e.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r })) s[l.key] = !0, this._renderableTilesKeys.push(l.key), this._tiles[l.key] || (l.posMatrix = new Float64Array(16), c.aP(l.posMatrix, 0, c.X, 0, c.X, 0, 1), this._tiles[l.key] = new cr(l, this.tileSize));
          for (const l in this._tiles) s[l] || delete this._tiles[l];
        }
        freeRtt(e) {
          for (const r in this._tiles) {
            const s = this._tiles[r];
            (!e || s.tileID.equals(e) || s.tileID.isChildOf(e) || e.isChildOf(s.tileID)) && (s.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((e) => this.getTileByID(e));
        }
        getTileByID(e) {
          return this._tiles[e];
        }
        getTerrainCoords(e) {
          const r = {};
          for (const s of this._renderableTilesKeys) {
            const l = this._tiles[s].tileID;
            if (l.canonical.equals(e.canonical)) {
              const h = e.clone();
              h.posMatrix = new Float64Array(16), c.aP(h.posMatrix, 0, c.X, 0, c.X, 0, 1), r[s] = h;
            } else if (l.canonical.isChildOf(e.canonical)) {
              const h = e.clone();
              h.posMatrix = new Float64Array(16);
              const y = l.canonical.z - e.canonical.z, b = l.canonical.x - (l.canonical.x >> y << y), I = l.canonical.y - (l.canonical.y >> y << y), k = c.X >> y;
              c.aP(h.posMatrix, 0, k, 0, k, 0, 1), c.J(h.posMatrix, h.posMatrix, [-b * k, -I * k, 0]), r[s] = h;
            } else if (e.canonical.isChildOf(l.canonical)) {
              const h = e.clone();
              h.posMatrix = new Float64Array(16);
              const y = e.canonical.z - l.canonical.z, b = e.canonical.x - (e.canonical.x >> y << y), I = e.canonical.y - (e.canonical.y >> y << y), k = c.X >> y;
              c.aP(h.posMatrix, 0, c.X, 0, c.X, 0, 1), c.J(h.posMatrix, h.posMatrix, [b * k, I * k, 0]), c.K(h.posMatrix, h.posMatrix, [1 / 2 ** y, 1 / 2 ** y, 0]), r[s] = h;
            }
          }
          return r;
        }
        getSourceTile(e, r) {
          const s = this.sourceCache._source;
          let l = e.overscaledZ - this.deltaZoom;
          if (l > s.maxzoom && (l = s.maxzoom), l < s.minzoom) return null;
          this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(l).key);
          let h = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
          if ((!h || !h.dem) && r) for (; l >= s.minzoom && (!h || !h.dem); ) h = this.sourceCache.getTileByID(e.scaledTo(l--).key);
          return h;
        }
        tilesAfterTime(e = Date.now()) {
          return Object.values(this._tiles).filter((r) => r.timeAdded >= e);
        }
      }
      class yl {
        constructor(e, r, s) {
          this.painter = e, this.sourceCache = new Uc(r), this.options = s, this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e, r, s, l = c.X) {
          var h;
          if (!(r >= 0 && r < l && s >= 0 && s < l)) return 0;
          const y = this.getTerrainData(e), b = (h = y.tile) === null || h === void 0 ? void 0 : h.dem;
          if (!b) return 0;
          const I = function(B, G, Q) {
            var ee = G[0], ne = G[1];
            return B[0] = Q[0] * ee + Q[4] * ne + Q[12], B[1] = Q[1] * ee + Q[5] * ne + Q[13], B;
          }([], [r / l * c.X, s / l * c.X], y.u_terrain_matrix), k = [I[0] * b.dim, I[1] * b.dim], z = Math.floor(k[0]), M = Math.floor(k[1]), O = k[0] - z, U = k[1] - M;
          return b.get(z, M) * (1 - O) * (1 - U) + b.get(z + 1, M) * O * (1 - U) + b.get(z, M + 1) * (1 - O) * U + b.get(z + 1, M + 1) * O * U;
        }
        getElevationForLngLatZoom(e, r) {
          if (!c.bb(r, e.wrap())) return 0;
          const { tileID: s, mercatorX: l, mercatorY: h } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return this.getElevation(s, l % c.X, h % c.X, c.X);
        }
        getElevation(e, r, s, l = c.X) {
          return this.getDEMElevation(e, r, s, l) * this.exaggeration;
        }
        getTerrainData(e) {
          if (!this._emptyDemTexture) {
            const l = this.painter.context, h = new c.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new oe(l, h, l.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new oe(l, new c.R({ width: 1, height: 1 }), l.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(l.gl.NEAREST, l.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.an([]);
          }
          const r = this.sourceCache.getSourceTile(e, !0);
          if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
            const l = this.painter.context;
            r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new oe(l, r.dem.getPixels(), l.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(l.gl.NEAREST, l.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
          }
          const s = r && r + r.tileID.key + e.key;
          if (s && !this._demMatrixCache[s]) {
            const l = this.sourceCache.sourceCache._source.maxzoom;
            let h = e.canonical.z - r.tileID.canonical.z;
            e.overscaledZ > e.canonical.z && (e.canonical.z >= l ? h = e.canonical.z - l : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const y = e.canonical.x - (e.canonical.x >> h << h), b = e.canonical.y - (e.canonical.y >> h << h), I = c.bc(new Float64Array(16), [1 / (c.X << h), 1 / (c.X << h), 0]);
            c.J(I, I, [y * c.X, b * c.X, 0]), this._demMatrixCache[e.key] = { matrix: I, coord: e };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: s ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
        }
        getFramebuffer(e) {
          const r = this.painter, s = r.width / devicePixelRatio, l = r.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === s && this._fbo.height === l || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new oe(r.context, { width: s, height: l, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new oe(r.context, { width: s, height: l, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(s, l, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, s, l))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const e = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let h = 0, y = 0; h < this._coordsTextureSize; h++) for (let b = 0; b < this._coordsTextureSize; b++, y += 4) r[y + 0] = 255 & b, r[y + 1] = 255 & h, r[y + 2] = b >> 8 << 4 | h >> 8, r[y + 3] = 0;
          const s = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), l = new oe(e, s, e.gl.RGBA, { premultiply: !1 });
          return l.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = l, l;
        }
        pointCoordinate(e) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const r = new Uint8Array(4), s = this.painter.context, l = s.gl, h = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), y = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), b = Math.round(this.painter.height / devicePixelRatio);
          s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), l.readPixels(h, b - y - 1, 1, 1, l.RGBA, l.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null);
          const I = r[0] + (r[2] >> 4 << 8), k = r[1] + ((15 & r[2]) << 8), z = this.coordsIndex[255 - r[3]], M = z && this.sourceCache.getTileByID(z);
          if (!M) return null;
          const O = this._coordsTextureSize, U = (1 << M.tileID.canonical.z) * O;
          return new c.Z((M.tileID.canonical.x * O + I) / U + M.tileID.wrap, (M.tileID.canonical.y * O + k) / U, this.getElevation(M.tileID, I, k, O));
        }
        depthAtPoint(e) {
          const r = new Uint8Array(4), s = this.painter.context, l = s.gl;
          return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), l.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, l.RGBA, l.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const e = this.painter.context, r = new c.bd(), s = new c.aY(), l = this.meshSize, h = c.X / l, y = l * l;
          for (let M = 0; M <= l; M++) for (let O = 0; O <= l; O++) r.emplaceBack(O * h, M * h, 0);
          for (let M = 0; M < y; M += l + 1) for (let O = 0; O < l; O++) s.emplaceBack(O + M, l + O + M + 1, l + O + M + 2), s.emplaceBack(O + M, l + O + M + 2, O + M + 1);
          const b = r.length, I = b + 2 * (l + 1);
          for (const M of [0, 1]) for (let O = 0; O <= l; O++) for (const U of [0, 1]) r.emplaceBack(O * h, M * c.X, U);
          for (let M = 0; M < 2 * l; M += 2) s.emplaceBack(I + M, I + M + 1, I + M + 3), s.emplaceBack(I + M, I + M + 3, I + M + 2), s.emplaceBack(b + M, b + M + 3, b + M + 1), s.emplaceBack(b + M, b + M + 2, b + M + 3);
          const k = r.length, z = k + 2 * (l + 1);
          for (const M of [0, 1]) for (let O = 0; O <= l; O++) for (const U of [0, 1]) r.emplaceBack(M * c.X, O * h, U);
          for (let M = 0; M < 2 * l; M += 2) s.emplaceBack(k + M, k + M + 1, k + M + 3), s.emplaceBack(k + M, k + M + 3, k + M + 2), s.emplaceBack(z + M, z + M + 3, z + M + 1), s.emplaceBack(z + M, z + M + 2, z + M + 3);
          return this._mesh = new ho(e.createVertexBuffer(r, Zl.members), e.createIndexBuffer(s), c.a0.simpleSegment(0, 0, r.length, s.length)), this._mesh;
        }
        getMeshFrameDelta(e) {
          return 2 * Math.PI * c.be / Math.pow(2, e) / 5;
        }
        getMinTileElevationForLngLatZoom(e, r) {
          var s;
          const { tileID: l } = this._getOverscaledTileIDFromLngLatZoom(e, r);
          return (s = this.getMinMaxElevation(l).minElevation) !== null && s !== void 0 ? s : 0;
        }
        getMinMaxElevation(e) {
          const r = this.getTerrainData(e).tile, s = { minElevation: null, maxElevation: null };
          return r && r.dem && (s.minElevation = r.dem.min * this.exaggeration, s.maxElevation = r.dem.max * this.exaggeration), s;
        }
        _getOverscaledTileIDFromLngLatZoom(e, r) {
          const s = c.Z.fromLngLat(e.wrap()), l = (1 << r) * c.X, h = s.x * l, y = s.y * l, b = Math.floor(h / c.X), I = Math.floor(y / c.X);
          return { tileID: new c.S(r, 0, r, b, I), mercatorX: h, mercatorY: y };
        }
      }
      class cc {
        constructor(e, r, s) {
          this._context = e, this._size = r, this._tileSize = s, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
        }
        _createObject(e) {
          const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), s = new oe(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(s.texture), { id: e, fbo: r, texture: s, stamp: -1, inUse: !1 };
        }
        getObjectForId(e) {
          return this._objects[e];
        }
        useObject(e) {
          e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((r) => e.id !== r), this._recentlyUsed.push(e.id);
        }
        stampObject(e) {
          e.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const e = this._createObject(this._objects.length);
          return this._objects.push(e), e;
        }
        freeObject(e) {
          e.inUse = !1;
        }
        freeAllObjects() {
          for (const e of this._objects) this.freeObject(e);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((e) => !e.inUse) === !1;
        }
      }
      const Ro = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class Gl {
        constructor(e, r) {
          this.painter = e, this.terrain = r, this.pool = new cc(e.context, 30, r.sourceCache.tileSize * r.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(e) {
          return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(e, r) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((s) => !e._layers[s].isHidden(r)), this._coordsDescendingInv = {};
          for (const s in e.sourceCaches) {
            this._coordsDescendingInv[s] = {};
            const l = e.sourceCaches[s].getVisibleCoordinates();
            for (const h of l) {
              const y = this.terrain.sourceCache.getTerrainCoords(h);
              for (const b in y) this._coordsDescendingInv[s][b] || (this._coordsDescendingInv[s][b] = []), this._coordsDescendingInv[s][b].push(y[b]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const s of e._order) {
            const l = e._layers[s], h = l.source;
            if (Ro[l.type] && !this._coordsDescendingInvStr[h]) {
              this._coordsDescendingInvStr[h] = {};
              for (const y in this._coordsDescendingInv[h]) this._coordsDescendingInvStr[h][y] = this._coordsDescendingInv[h][y].map((b) => b.key).sort().join();
            }
          }
          for (const s of this._renderableTiles) for (const l in this._coordsDescendingInvStr) {
            const h = this._coordsDescendingInvStr[l][s.tileID.key];
            h && h !== s.rttCoords[l] && (s.rtt = []);
          }
        }
        renderLayer(e) {
          if (e.isHidden(this.painter.transform.zoom)) return !1;
          const r = e.type, s = this.painter, l = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
          if (Ro[r] && (this._prevType && Ro[this._prevType] || this._stacks.push([]), this._prevType = r, this._stacks[this._stacks.length - 1].push(e.id), !l)) return !0;
          if (Ro[this._prevType] || Ro[r] && l) {
            this._prevType = r;
            const h = this._stacks.length - 1, y = this._stacks[h] || [];
            for (const b of this._renderableTiles) {
              if (this.pool.isFull() && (Eo(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(b), b.rtt[h]) {
                const k = this.pool.getObjectForId(b.rtt[h].id);
                if (k.stamp === b.rtt[h].stamp) {
                  this.pool.useObject(k);
                  continue;
                }
              }
              const I = this.pool.getOrCreateFreeObject();
              this.pool.useObject(I), this.pool.stampObject(I), b.rtt[h] = { id: I.id, stamp: I.stamp }, s.context.bindFramebuffer.set(I.fbo.framebuffer), s.context.clear({ color: c.aM.transparent, stencil: 0 }), s.currentStencilSource = void 0;
              for (let k = 0; k < y.length; k++) {
                const z = s.style._layers[y[k]], M = z.source ? this._coordsDescendingInv[z.source][b.tileID.key] : [b.tileID];
                s.context.viewport.set([0, 0, I.fbo.width, I.fbo.height]), s._renderTileClippingMasks(z, M), s.renderLayer(s, s.style.sourceCaches[z.source], z, M), z.source && (b.rttCoords[z.source] = this._coordsDescendingInvStr[z.source][b.tileID.key]);
              }
            }
            return Eo(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Ro[r];
          }
          return !1;
        }
      }
      const Wl = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Ja = C, _l = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: ya, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Bo = (a) => {
        a.touchstart = a.dragStart, a.touchmoveWindow = a.dragMove, a.touchend = a.dragEnd;
      }, Hl = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class hc {
        constructor(e, r, s = !1) {
          this.mousedown = (y) => {
            this.startMouse(c.e({}, y, { ctrlKey: !0, preventDefault: () => y.preventDefault() }), V.mousePos(this.element, y)), V.addEventListener(window, "mousemove", this.mousemove), V.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (y) => {
            this.moveMouse(y, V.mousePos(this.element, y));
          }, this.mouseup = (y) => {
            this.mouseRotate.dragEnd(y), this.mousePitch && this.mousePitch.dragEnd(y), this.offTemp();
          }, this.touchstart = (y) => {
            y.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = V.touchPos(this.element, y.targetTouches)[0], this.startTouch(y, this._startPos), V.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), V.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (y) => {
            y.targetTouches.length !== 1 ? this.reset() : (this._lastPos = V.touchPos(this.element, y.targetTouches)[0], this.moveTouch(y, this._lastPos));
          }, this.touchend = (y) => {
            y.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const l = e.dragRotate._mouseRotate.getClickTolerance(), h = e.dragRotate._mousePitch.getClickTolerance();
          this.element = r, this.mouseRotate = da({ clickTolerance: l, enable: !0 }), this.touchRotate = (({ enable: y, clickTolerance: b, bearingDegreesPerPixelMoved: I = 0.8 }) => {
            const k = new gl();
            return new Lr({ clickTolerance: b, move: (z, M) => ({ bearingDelta: (M.x - z.x) * I }), moveStateManager: k, enable: y, assignEvents: Bo });
          })({ clickTolerance: l, enable: !0 }), this.map = e, s && (this.mousePitch = Wa({ clickTolerance: h, enable: !0 }), this.touchPitch = (({ enable: y, clickTolerance: b, pitchDegreesPerPixelMoved: I = -0.5 }) => {
            const k = new gl();
            return new Lr({ clickTolerance: b, move: (z, M) => ({ pitchDelta: (M.y - z.y) * I }), moveStateManager: k, enable: y, assignEvents: Bo });
          })({ clickTolerance: h, enable: !0 })), V.addEventListener(r, "mousedown", this.mousedown), V.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), V.addEventListener(r, "touchcancel", this.reset);
        }
        startMouse(e, r) {
          this.mouseRotate.dragStart(e, r), this.mousePitch && this.mousePitch.dragStart(e, r), V.disableDrag();
        }
        startTouch(e, r) {
          this.touchRotate.dragStart(e, r), this.touchPitch && this.touchPitch.dragStart(e, r), V.disableDrag();
        }
        moveMouse(e, r) {
          const s = this.map, { bearingDelta: l } = this.mouseRotate.dragMove(e, r) || {};
          if (l && s.setBearing(s.getBearing() + l), this.mousePitch) {
            const { pitchDelta: h } = this.mousePitch.dragMove(e, r) || {};
            h && s.setPitch(s.getPitch() + h);
          }
        }
        moveTouch(e, r) {
          const s = this.map, { bearingDelta: l } = this.touchRotate.dragMove(e, r) || {};
          if (l && s.setBearing(s.getBearing() + l), this.touchPitch) {
            const { pitchDelta: h } = this.touchPitch.dragMove(e, r) || {};
            h && s.setPitch(s.getPitch() + h);
          }
        }
        off() {
          const e = this.element;
          V.removeEventListener(e, "mousedown", this.mousedown), V.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), V.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), V.removeEventListener(window, "touchend", this.touchend), V.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          V.enableDrag(), V.removeEventListener(window, "mousemove", this.mousemove), V.removeEventListener(window, "mouseup", this.mouseup), V.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), V.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Tn;
      function Gi(a, e, r) {
        const s = new c.N(a.lng, a.lat);
        if (a = new c.N(a.lng, a.lat), e) {
          const l = new c.N(a.lng - 360, a.lat), h = new c.N(a.lng + 360, a.lat), y = r.locationPoint(a).distSqr(e);
          r.locationPoint(l).distSqr(e) < y ? a = l : r.locationPoint(h).distSqr(e) < y && (a = h);
        }
        for (; Math.abs(a.lng - r.center.lng) > 180; ) {
          const l = r.locationPoint(a);
          if (l.x >= 0 && l.y >= 0 && l.x <= r.width && l.y <= r.height) break;
          a.lng > r.center.lng ? a.lng -= 360 : a.lng += 360;
        }
        return a.lng !== s.lng && r.locationPoint(a).y > r.height / 2 - r.getHorizon() ? a : s;
      }
      const _a = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function vl(a, e, r) {
        const s = a.classList;
        for (const l in _a) s.remove(`maplibregl-${r}-anchor-${l}`);
        s.add(`maplibregl-${r}-anchor-${e}`);
      }
      class xl extends c.E {
        constructor(e) {
          if (super(), this._onKeyPress = (r) => {
            const s = r.code, l = r.charCode || r.keyCode;
            s !== "Space" && s !== "Enter" && l !== 32 && l !== 13 || this.togglePopup();
          }, this._onMapClick = (r) => {
            const s = r.originalEvent.target, l = this._element;
            this._popup && (s === l || l.contains(s)) && this.togglePopup();
          }, this._update = (r) => {
            var s;
            if (!this._map) return;
            const l = this._map.loaded() && !this._map.isMoving();
            ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Gi(this._lngLat, this._flatPos, this._map.transform) : (s = this._lngLat) === null || s === void 0 ? void 0 : s.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let h = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let y = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? y = "rotateX(0deg)" : this._pitchAlignment === "map" && (y = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), V.setTransform(this._element, `${_a[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${y} ${h}`), j.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(r && r.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (r) => {
            if (!this._isDragging) {
              const s = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = r.point.dist(this._pointerdownPos) >= s;
            }
            this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.k("dragstart"))), this.fire(new c.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (r) => {
            this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = c.P.convert(e && e.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = V.create("div");
            const r = V.createNS("http://www.w3.org/2000/svg", "svg"), s = 41, l = 27;
            r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${s}px`), r.setAttributeNS(null, "width", `${l}px`), r.setAttributeNS(null, "viewBox", `0 0 ${l} ${s}`);
            const h = V.createNS("http://www.w3.org/2000/svg", "g");
            h.setAttributeNS(null, "stroke", "none"), h.setAttributeNS(null, "stroke-width", "1"), h.setAttributeNS(null, "fill", "none"), h.setAttributeNS(null, "fill-rule", "evenodd");
            const y = V.createNS("http://www.w3.org/2000/svg", "g");
            y.setAttributeNS(null, "fill-rule", "nonzero");
            const b = V.createNS("http://www.w3.org/2000/svg", "g");
            b.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), b.setAttributeNS(null, "fill", "#000000");
            const I = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const ee of I) {
              const ne = V.createNS("http://www.w3.org/2000/svg", "ellipse");
              ne.setAttributeNS(null, "opacity", "0.04"), ne.setAttributeNS(null, "cx", "10.5"), ne.setAttributeNS(null, "cy", "5.80029008"), ne.setAttributeNS(null, "rx", ee.rx), ne.setAttributeNS(null, "ry", ee.ry), b.appendChild(ne);
            }
            const k = V.createNS("http://www.w3.org/2000/svg", "g");
            k.setAttributeNS(null, "fill", this._color);
            const z = V.createNS("http://www.w3.org/2000/svg", "path");
            z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), k.appendChild(z);
            const M = V.createNS("http://www.w3.org/2000/svg", "g");
            M.setAttributeNS(null, "opacity", "0.25"), M.setAttributeNS(null, "fill", "#000000");
            const O = V.createNS("http://www.w3.org/2000/svg", "path");
            O.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), M.appendChild(O);
            const U = V.createNS("http://www.w3.org/2000/svg", "g");
            U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
            const B = V.createNS("http://www.w3.org/2000/svg", "g");
            B.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const G = V.createNS("http://www.w3.org/2000/svg", "circle");
            G.setAttributeNS(null, "fill", "#000000"), G.setAttributeNS(null, "opacity", "0.25"), G.setAttributeNS(null, "cx", "5.5"), G.setAttributeNS(null, "cy", "5.5"), G.setAttributeNS(null, "r", "5.4999962");
            const Q = V.createNS("http://www.w3.org/2000/svg", "circle");
            Q.setAttributeNS(null, "fill", "#FFFFFF"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962"), B.appendChild(G), B.appendChild(Q), y.appendChild(b), y.appendChild(k), y.appendChild(M), y.appendChild(U), y.appendChild(B), r.appendChild(y), r.setAttributeNS(null, "height", s * this._scale + "px"), r.setAttributeNS(null, "width", l * this._scale + "px"), this._element.appendChild(r), this._offset = c.P.convert(e && e.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (r) => {
            r.preventDefault();
          }), this._element.addEventListener("mousedown", (r) => {
            r.preventDefault();
          }), vl(this._element, this._anchor, "marker"), e && e.className) for (const r of e.className.split(" ")) this._element.classList.add(r);
          this._popup = null;
        }
        addTo(e) {
          return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), V.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e) {
          return this._lngLat = c.N.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
            if (!("offset" in e.options)) {
              const l = Math.abs(13.5) / Math.SQRT2;
              e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [l, -1 * (38.1 - 13.5 + l)], "bottom-right": [-l, -1 * (38.1 - 13.5 + l)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(e) {
          return this._subpixelPositioning = e, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
        }
        _updateOpacity(e = !1) {
          var r, s;
          if (!(!((r = this._map) === null || r === void 0) && r.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (e) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const l = this._map, h = l.terrain.depthAtPoint(this._pos), y = l.terrain.getElevationForLngLatZoom(this._lngLat, l.transform.tileZoom);
          if (l.transform.lngLatToCameraDepth(this._lngLat, y) - h < 6e-3) return void (this._element.style.opacity = this._opacity);
          const b = -this._offset.y / l.transform._pixelPerMeter, I = Math.sin(l.getPitch() * Math.PI / 180) * b, k = l.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), z = l.transform.lngLatToCameraDepth(this._lngLat, y + I) - k > 6e-3;
          !((s = this._popup) === null || s === void 0) && s.isOpen() && z && this._popup.remove(), this._element.style.opacity = z ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e) {
          return this._offset = c.P.convert(e), this._update(), this;
        }
        addClassName(e) {
          this._element.classList.add(e);
        }
        removeClassName(e) {
          this._element.classList.remove(e);
        }
        toggleClassName(e) {
          return this._element.classList.toggle(e);
        }
        setDraggable(e) {
          return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e) {
          return this._rotation = e || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e) {
          return this._rotationAlignment = e || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e) {
          return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(e, r) {
          return e === void 0 && r === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
        }
      }
      const uc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Ka = 0, Qa = !1;
      const ds = { maxWidth: 100, unit: "metric" };
      function mo(a, e, r) {
        const s = r && r.maxWidth || 100, l = a._container.clientHeight / 2, h = a.unproject([0, l]), y = a.unproject([s, l]), b = h.distanceTo(y);
        if (r && r.unit === "imperial") {
          const I = 3.2808 * b;
          I > 5280 ? jt(e, s, I / 5280, a._getUIString("ScaleControl.Miles")) : jt(e, s, I, a._getUIString("ScaleControl.Feet"));
        } else r && r.unit === "nautical" ? jt(e, s, b / 1852, a._getUIString("ScaleControl.NauticalMiles")) : b >= 1e3 ? jt(e, s, b / 1e3, a._getUIString("ScaleControl.Kilometers")) : jt(e, s, b, a._getUIString("ScaleControl.Meters"));
      }
      function jt(a, e, r, s) {
        const l = function(h) {
          const y = Math.pow(10, `${Math.floor(h)}`.length - 1);
          let b = h / y;
          return b = b >= 10 ? 10 : b >= 5 ? 5 : b >= 3 ? 3 : b >= 2 ? 2 : b >= 1 ? 1 : function(I) {
            const k = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
            return Math.round(I * k) / k;
          }(b), y * b;
        }(r);
        a.style.width = e * (l / r) + "px", a.innerHTML = `${l}&nbsp;${s}`;
      }
      const Kt = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, el = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function m(a) {
        if (a) {
          if (typeof a == "number") {
            const e = Math.round(Math.abs(a) / Math.SQRT2);
            return { center: new c.P(0, 0), top: new c.P(0, a), "top-left": new c.P(e, e), "top-right": new c.P(-e, e), bottom: new c.P(0, -a), "bottom-left": new c.P(e, -e), "bottom-right": new c.P(-e, -e), left: new c.P(a, 0), right: new c.P(-a, 0) };
          }
          if (a instanceof c.P || Array.isArray(a)) {
            const e = c.P.convert(a);
            return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
          }
          return { center: c.P.convert(a.center || [0, 0]), top: c.P.convert(a.top || [0, 0]), "top-left": c.P.convert(a["top-left"] || [0, 0]), "top-right": c.P.convert(a["top-right"] || [0, 0]), bottom: c.P.convert(a.bottom || [0, 0]), "bottom-left": c.P.convert(a["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(a["bottom-right"] || [0, 0]), left: c.P.convert(a.left || [0, 0]), right: c.P.convert(a.right || [0, 0]) };
        }
        return m(new c.P(0, 0));
      }
      const A = C;
      _.AJAXError = c.bh, _.Evented = c.E, _.LngLat = c.N, _.MercatorCoordinate = c.Z, _.Point = c.P, _.addProtocol = c.bi, _.config = c.a, _.removeProtocol = c.bj, _.AttributionControl = Fo, _.BoxZoomHandler = yn, _.CanvasSource = oi, _.CooperativeGesturesHandler = ga, _.DoubleClickZoomHandler = Zs, _.DragPanHandler = lc, _.DragRotateHandler = Ul, _.EdgeInsets = Bn, _.FullscreenControl = class extends c.E {
        constructor(a = {}) {
          super(), this._onFullscreenChange = () => {
            var e;
            let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((e = r == null ? void 0 : r.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
            r === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, a && a.container && (a.container instanceof HTMLElement ? this._container = a.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(a) {
          return this._map = a, this._container || (this._container = this._map.getContainer()), this._controlContainer = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          V.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const a = this._fullscreenButton = V.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          V.create("span", "maplibregl-ctrl-icon", a).setAttribute("aria-hidden", "true"), a.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const a = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", a), this._fullscreenButton.title = a;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, _.GeoJSONSource = zt, _.GeolocateControl = class extends c.E {
        constructor(a) {
          super(), this._onSuccess = (e) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new c.k("outofmaxbounds", e)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.k("geolocate", e)), this._finish();
            }
          }, this._updateCamera = (e) => {
            const r = new c.N(e.coords.longitude, e.coords.latitude), s = e.coords.accuracy, l = this._map.getBearing(), h = c.e({ bearing: l }, this.options.fitBoundsOptions), y = Y.fromLngLat(r, s);
            this._map.fitBounds(y, h, { geolocateSource: !0 });
          }, this._updateMarker = (e) => {
            if (e) {
              const r = new c.N(e.coords.longitude, e.coords.latitude);
              this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (e) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (e.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (e.code === 3 && Qa) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.k("error", e)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this._geolocateButton = V.create("button", "maplibregl-ctrl-geolocate", this._container), V.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (e) => {
            if (this._map) {
              if (e === !1) {
                c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              } else {
                const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = V.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new xl({ element: this._dotElement }), this._circleElement = V.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new xl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r) => {
                r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.k("trackuserlocationend")), this.fire(new c.k("userlocationlostfocus")));
              });
            }
          }, this.options = c.e({}, uc, a);
        }
        onAdd(a) {
          return this._map = a, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return c._(this, arguments, void 0, function* (e = !1) {
              if (Tn !== void 0 && !e) return Tn;
              if (window.navigator.permissions === void 0) return Tn = !!window.navigator.geolocation, Tn;
              try {
                Tn = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                Tn = !!window.navigator.geolocation;
              }
              return Tn;
            });
          }().then((e) => this._finishSetupUI(e)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), V.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ka = 0, Qa = !1;
        }
        _isOutOfMapMaxBounds(a) {
          const e = this._map.getMaxBounds(), r = a.coords;
          return e && (r.longitude < e.getWest() || r.longitude > e.getEast() || r.latitude < e.getSouth() || r.latitude > e.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const a = this._map.getBounds(), e = a.getSouthEast(), r = a.getNorthEast(), s = e.distanceTo(r), l = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${l}px`, this._circleElement.style.height = `${l}px`;
        }
        trigger() {
          if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new c.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Ka--, Qa = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.k("trackuserlocationstart")), this.fire(new c.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let a;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ka++, Ka > 1 ? (a = { maximumAge: 6e5, timeout: 0 }, Qa = !0) : (a = this.options.positionOptions, Qa = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, a);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, _.Hash = po, _.ImageSource = Gt, _.KeyboardHandler = Un, _.LngLatBounds = Y, _.LogoControl = Ts, _.Map = class extends Ls {
        constructor(a) {
          c.bf.mark(c.bg.create);
          const e = Object.assign(Object.assign({}, _l), a);
          if (e.minZoom != null && e.maxZoom != null && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (e.minPitch != null && e.maxPitch != null && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (e.minPitch != null && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (e.maxPitch != null && e.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new On(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), { bearingSnap: e.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new fi(), this._controls = [], this._mapId = c.a4(), this._contextLost = (r) => {
            r.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.k("webglcontextlost", { originalEvent: r }));
          }, this._contextRestored = (r) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new c.k("webglcontextrestored", { originalEvent: r }));
          }, this._onMapScroll = (r) => {
            if (r.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._maxTileCacheZoomLevels = e.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = e.preserveDrawingBuffer === !0, this._antialias = e.antialias === !0, this._trackResize = e.trackResize === !0, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles === !0, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions === !0, this._collectResourceTiming = e.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Wl), e.locale), this._clickTolerance = e.clickTolerance, this._overridePixelRatio = e.pixelRatio, this._maxCanvasSize = e.maxCanvasSize, this.transformCameraUpdate = e.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = e.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = Me.addThrottleControl(() => this.isMoving()), this._requestManager = new Ye(e.transformRequest), typeof e.container == "string") {
            if (this._container = document.getElementById(e.container), !this._container) throw new Error(`Container '${e.container}' not found.`);
          } else {
            if (!(e.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = e.container;
          }
          if (e.maxBounds && this.setMaxBounds(e.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let r = !1;
            const s = jn((l) => {
              this._trackResize && !this._removed && (this.resize(l), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((l) => {
              r ? s(l) : r = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Ln(this, e), this._hash = e.hash && new po(typeof e.hash == "string" && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch }), e.bounds && (this.resize(), this.fitBounds(e.bounds, c.e({}, e.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, this._validateStyle = e.validateStyle, e.style && this.setStyle(e.style, { localIdeographFontFamily: e.localIdeographFontFamily }), e.attributionControl && this.addControl(new Fo(typeof e.attributionControl == "boolean" ? void 0 : e.attributionControl)), e.maplibreLogo && this.addControl(new Ts(), e.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (r) => {
            this._update(r.dataType === "style"), this.fire(new c.k(`${r.dataType}data`, r));
          }), this.on("dataloading", (r) => {
            this.fire(new c.k(`${r.dataType}dataloading`, r));
          }), this.on("dataabort", (r) => {
            this.fire(new c.k("sourcedataabort", r));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(a, e) {
          if (e === void 0 && (e = a.getDefaultPosition ? a.getDefaultPosition() : "top-right"), !a || !a.onAdd) return this.fire(new c.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = a.onAdd(this);
          this._controls.push(a);
          const s = this._controlPositions[e];
          return e.indexOf("bottom") !== -1 ? s.insertBefore(r, s.firstChild) : s.appendChild(r), this;
        }
        removeControl(a) {
          if (!a || !a.onRemove) return this.fire(new c.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const e = this._controls.indexOf(a);
          return e > -1 && this._controls.splice(e, 1), a.onRemove(this), this;
        }
        hasControl(a) {
          return this._controls.indexOf(a) > -1;
        }
        calculateCameraOptionsFromTo(a, e, r, s) {
          return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(a, e, r, s);
        }
        resize(a) {
          var e;
          const r = this._containerDimensions(), s = r[0], l = r[1], h = this._getClampedPixelRatio(s, l);
          if (this._resizeCanvas(s, l, h), this.painter.resize(s, l, h), this.painter.overLimit()) {
            const b = this.painter.context.gl;
            this._maxCanvasSize = [b.drawingBufferWidth, b.drawingBufferHeight];
            const I = this._getClampedPixelRatio(s, l);
            this._resizeCanvas(s, l, I), this.painter.resize(s, l, I);
          }
          this.transform.resize(s, l), (e = this._requestedCameraState) === null || e === void 0 || e.resize(s, l);
          const y = !this._moving;
          return y && (this.stop(), this.fire(new c.k("movestart", a)).fire(new c.k("move", a))), this.fire(new c.k("resize", a)), y && this.fire(new c.k("moveend", a)), this;
        }
        _getClampedPixelRatio(a, e) {
          const { 0: r, 1: s } = this._maxCanvasSize, l = this.getPixelRatio(), h = a * l, y = e * l;
          return Math.min(h > r ? r / h : 1, y > s ? s / y : 1) * l;
        }
        getPixelRatio() {
          var a;
          return (a = this._overridePixelRatio) !== null && a !== void 0 ? a : devicePixelRatio;
        }
        setPixelRatio(a) {
          this._overridePixelRatio = a, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(a) {
          return this.transform.setMaxBounds(Y.convert(a)), this._update();
        }
        setMinZoom(a) {
          if ((a = a ?? -2) >= -2 && a <= this.transform.maxZoom) return this.transform.minZoom = a, this._update(), this.getZoom() < a && this.setZoom(a), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(a) {
          if ((a = a ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = a, this._update(), this.getZoom() > a && this.setZoom(a), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(a) {
          if ((a = a ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (a >= 0 && a <= this.transform.maxPitch) return this.transform.minPitch = a, this._update(), this.getPitch() < a && this.setPitch(a), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(a) {
          if ((a = a ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (a >= this.transform.minPitch) return this.transform.maxPitch = a, this._update(), this.getPitch() > a && this.setPitch(a), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(a) {
          return this.transform.renderWorldCopies = a, this._update();
        }
        project(a) {
          return this.transform.locationPoint(c.N.convert(a), this.style && this.terrain);
        }
        unproject(a) {
          return this.transform.pointLocation(c.P.convert(a), this.terrain);
        }
        isMoving() {
          var a;
          return this._moving || ((a = this.handlers) === null || a === void 0 ? void 0 : a.isMoving());
        }
        isZooming() {
          var a;
          return this._zooming || ((a = this.handlers) === null || a === void 0 ? void 0 : a.isZooming());
        }
        isRotating() {
          var a;
          return this._rotating || ((a = this.handlers) === null || a === void 0 ? void 0 : a.isRotating());
        }
        _createDelegatedListener(a, e, r) {
          if (a === "mouseenter" || a === "mouseover") {
            let s = !1;
            return { layers: e, listener: r, delegates: { mousemove: (h) => {
              const y = e.filter((I) => this.getLayer(I)), b = y.length !== 0 ? this.queryRenderedFeatures(h.point, { layers: y }) : [];
              b.length ? s || (s = !0, r.call(this, new br(a, this, h.originalEvent, { features: b }))) : s = !1;
            }, mouseout: () => {
              s = !1;
            } } };
          }
          if (a === "mouseleave" || a === "mouseout") {
            let s = !1;
            return { layers: e, listener: r, delegates: { mousemove: (y) => {
              const b = e.filter((I) => this.getLayer(I));
              (b.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: b }) : []).length ? s = !0 : s && (s = !1, r.call(this, new br(a, this, y.originalEvent)));
            }, mouseout: (y) => {
              s && (s = !1, r.call(this, new br(a, this, y.originalEvent)));
            } } };
          }
          {
            const s = (l) => {
              const h = e.filter((b) => this.getLayer(b)), y = h.length !== 0 ? this.queryRenderedFeatures(l.point, { layers: h }) : [];
              y.length && (l.features = y, r.call(this, l), delete l.features);
            };
            return { layers: e, listener: r, delegates: { [a]: s } };
          }
        }
        _saveDelegatedListener(a, e) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[a] = this._delegatedListeners[a] || [], this._delegatedListeners[a].push(e);
        }
        _removeDelegatedListener(a, e, r) {
          if (!this._delegatedListeners || !this._delegatedListeners[a]) return;
          const s = this._delegatedListeners[a];
          for (let l = 0; l < s.length; l++) {
            const h = s[l];
            if (h.listener === r && h.layers.length === e.length && h.layers.every((y) => e.includes(y))) {
              for (const y in h.delegates) this.off(y, h.delegates[y]);
              return void s.splice(l, 1);
            }
          }
        }
        on(a, e, r) {
          if (r === void 0) return super.on(a, e);
          const s = this._createDelegatedListener(a, typeof e == "string" ? [e] : e, r);
          this._saveDelegatedListener(a, s);
          for (const l in s.delegates) this.on(l, s.delegates[l]);
          return this;
        }
        once(a, e, r) {
          if (r === void 0) return super.once(a, e);
          const s = typeof e == "string" ? [e] : e, l = this._createDelegatedListener(a, s, r);
          for (const h in l.delegates) {
            const y = l.delegates[h];
            l.delegates[h] = (...b) => {
              this._removeDelegatedListener(a, s, r), y(...b);
            };
          }
          this._saveDelegatedListener(a, l);
          for (const h in l.delegates) this.once(h, l.delegates[h]);
          return this;
        }
        off(a, e, r) {
          return r === void 0 ? super.off(a, e) : (this._removeDelegatedListener(a, typeof e == "string" ? [e] : e, r), this);
        }
        queryRenderedFeatures(a, e) {
          if (!this.style) return [];
          let r;
          const s = a instanceof c.P || Array.isArray(a), l = s ? a : [[0, 0], [this.transform.width, this.transform.height]];
          if (e = e || (s ? {} : a) || {}, l instanceof c.P || typeof l[0] == "number") r = [c.P.convert(l)];
          else {
            const h = c.P.convert(l[0]), y = c.P.convert(l[1]);
            r = [h, new c.P(y.x, h.y), y, new c.P(h.x, y.y), h];
          }
          return this.style.queryRenderedFeatures(r, e, this.transform);
        }
        querySourceFeatures(a, e) {
          return this.style.querySourceFeatures(a, e);
        }
        setStyle(a, e) {
          return (e = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && a ? (this._diffStyle(a, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(a, e));
        }
        setTransformRequest(a) {
          return this._requestManager.setTransformRequest(a), this;
        }
        _getUIString(a) {
          const e = this._locale[a];
          if (e == null) throw new Error(`Missing UI string '${a}'`);
          return e;
        }
        _updateStyle(a, e) {
          if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(a, e));
          const r = this.style && e.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!a)), a ? (this.style = new Fr(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof a == "string" ? this.style.loadURL(a, e, r) : this.style.loadJSON(a, e, r), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Fr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(a, e) {
          if (typeof a == "string") {
            const r = this._requestManager.transformRequest(a, "Style");
            c.h(r, new AbortController()).then((s) => {
              this._updateDiff(s.data, e);
            }).catch((s) => {
              s && this.fire(new c.j(s));
            });
          } else typeof a == "object" && this._updateDiff(a, e);
        }
        _updateDiff(a, e) {
          try {
            this.style.setState(a, e) && this._update(!0);
          } catch (r) {
            c.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(a, e);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : c.w("There is no style added to the map.");
        }
        addSource(a, e) {
          return this._lazyInitEmptyStyle(), this.style.addSource(a, e), this._update(!0);
        }
        isSourceLoaded(a) {
          const e = this.style && this.style.sourceCaches[a];
          if (e !== void 0) return e.loaded();
          this.fire(new c.j(new Error(`There is no source with ID '${a}'`)));
        }
        setTerrain(a) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), a) {
            const e = this.style.sourceCaches[a.source];
            if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${a.source}`);
            this.terrain === null && e.reload();
            for (const r in this.style._layers) {
              const s = this.style._layers[r];
              s.type === "hillshade" && s.source === a.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new yl(this.painter, e, a), this.painter.renderToTexture = new Gl(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (r) => {
              r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== a.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(r.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new c.k("terrain", { terrain: a })), this;
        }
        getTerrain() {
          var a, e;
          return (e = (a = this.terrain) === null || a === void 0 ? void 0 : a.options) !== null && e !== void 0 ? e : null;
        }
        areTilesLoaded() {
          const a = this.style && this.style.sourceCaches;
          for (const e in a) {
            const r = a[e]._tiles;
            for (const s in r) {
              const l = r[s];
              if (l.state !== "loaded" && l.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(a) {
          return this.style.removeSource(a), this._update(!0);
        }
        getSource(a) {
          return this.style.getSource(a);
        }
        addImage(a, e, r = {}) {
          const { pixelRatio: s = 1, sdf: l = !1, stretchX: h, stretchY: y, content: b, textFitWidth: I, textFitHeight: k } = r;
          if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || c.b(e))) {
            if (e.width === void 0 || e.height === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: z, height: M, data: O } = e, U = e;
              return this.style.addImage(a, { data: new c.R({ width: z, height: M }, new Uint8Array(O)), pixelRatio: s, stretchX: h, stretchY: y, content: b, textFitWidth: I, textFitHeight: k, sdf: l, version: 0, userImage: U }), U.onAdd && U.onAdd(this, a), this;
            }
          }
          {
            const { width: z, height: M, data: O } = j.getImageData(e);
            this.style.addImage(a, { data: new c.R({ width: z, height: M }, O), pixelRatio: s, stretchX: h, stretchY: y, content: b, textFitWidth: I, textFitHeight: k, sdf: l, version: 0 });
          }
        }
        updateImage(a, e) {
          const r = this.style.getImage(a);
          if (!r) return this.fire(new c.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const s = e instanceof HTMLImageElement || c.b(e) ? j.getImageData(e) : e, { width: l, height: h, data: y } = s;
          if (l === void 0 || h === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (l !== r.data.width || h !== r.data.height) return this.fire(new c.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const b = !(e instanceof HTMLImageElement || c.b(e));
          return r.data.replace(y, b), this.style.updateImage(a, r), this;
        }
        getImage(a) {
          return this.style.getImage(a);
        }
        hasImage(a) {
          return a ? !!this.style.getImage(a) : (this.fire(new c.j(new Error("Missing required image id"))), !1);
        }
        removeImage(a) {
          this.style.removeImage(a);
        }
        loadImage(a) {
          return Me.getImage(this._requestManager.transformRequest(a, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(a, e) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(a, e), this._update(!0);
        }
        moveLayer(a, e) {
          return this.style.moveLayer(a, e), this._update(!0);
        }
        removeLayer(a) {
          return this.style.removeLayer(a), this._update(!0);
        }
        getLayer(a) {
          return this.style.getLayer(a);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(a, e, r) {
          return this.style.setLayerZoomRange(a, e, r), this._update(!0);
        }
        setFilter(a, e, r = {}) {
          return this.style.setFilter(a, e, r), this._update(!0);
        }
        getFilter(a) {
          return this.style.getFilter(a);
        }
        setPaintProperty(a, e, r, s = {}) {
          return this.style.setPaintProperty(a, e, r, s), this._update(!0);
        }
        getPaintProperty(a, e) {
          return this.style.getPaintProperty(a, e);
        }
        setLayoutProperty(a, e, r, s = {}) {
          return this.style.setLayoutProperty(a, e, r, s), this._update(!0);
        }
        getLayoutProperty(a, e) {
          return this.style.getLayoutProperty(a, e);
        }
        setGlyphs(a, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(a, e), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(a, e, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(a, e, r, (s) => {
            s || this._update(!0);
          }), this;
        }
        removeSprite(a) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(a), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(a, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(a, e, (r) => {
            r || this._update(!0);
          }), this;
        }
        setLight(a, e = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(a, e), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(a) {
          return this._lazyInitEmptyStyle(), this.style.setSky(a), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(a, e) {
          return this.style.setFeatureState(a, e), this._update();
        }
        removeFeatureState(a, e) {
          return this.style.removeFeatureState(a, e), this._update();
        }
        getFeatureState(a) {
          return this.style.getFeatureState(a);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let a = 0, e = 0;
          return this._container && (a = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [a, e];
        }
        _setupContainer() {
          const a = this._container;
          a.classList.add("maplibregl-map");
          const e = this._canvasContainer = V.create("div", "maplibregl-canvas-container", a);
          this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = V.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const r = this._containerDimensions(), s = this._getClampedPixelRatio(r[0], r[1]);
          this._resizeCanvas(r[0], r[1], s);
          const l = this._controlContainer = V.create("div", "maplibregl-control-container", a), h = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((y) => {
            h[y] = V.create("div", `maplibregl-ctrl-${y} `, l);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(a, e, r) {
          this._canvas.width = Math.floor(r * a), this._canvas.height = Math.floor(r * e), this._canvas.style.width = `${a}px`, this._canvas.style.height = `${e}px`;
        }
        _setupPainter() {
          const a = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let e = null;
          this._canvas.addEventListener("webglcontextcreationerror", (s) => {
            e = { requestedAttributes: a }, s && (e.statusMessage = s.statusMessage, e.type = s.type);
          }, { once: !0 });
          const r = this._canvas.getContext("webgl2", a) || this._canvas.getContext("webgl", a);
          if (!r) {
            const s = "Failed to initialize WebGL";
            throw e ? (e.message = s, new Error(JSON.stringify(e))) : new Error(s);
          }
          this.painter = new cs(r, this.transform), F.testSupport(r);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(a) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || a, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(a) {
          return this._update(), this._renderTaskQueue.add(a);
        }
        _cancelRenderFrame(a) {
          this._renderTaskQueue.remove(a);
        }
        _render(a) {
          const e = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(a), this._removed) return;
          let r = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const l = this.transform.zoom, h = j.now();
            this.style.zoomHistory.update(l, h);
            const y = new c.z(l, { now: h, fadeDuration: e, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), b = y.crossFadingFactor();
            b === 1 && b === this._crossFadingFactor || (r = !0, this._crossFadingFactor = b), this.style.update(y);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, e, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: e, showPadding: this.showPadding }), this.fire(new c.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.bf.mark(c.bg.load), this.fire(new c.k("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const s = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return s || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.k("idle")), !this._loaded || this._fullyLoaded || s || (this._fullyLoaded = !0, c.bf.mark(c.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var a;
          this._hash && this._hash.remove();
          for (const r of this._controls) r.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), Me.removeThrottleControl(this._imageQueueHandle), (a = this._resizeObserver) === null || a === void 0 || a.disconnect();
          const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
          e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), V.remove(this._canvasContainer), V.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), c.bf.clearMetrics(), this._removed = !0, this.fire(new c.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), j.frameAsync(this._frameRequest).then((a) => {
            c.bf.frame(a), this._frameRequest = null, this._render(a);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(a) {
          this._showTileBoundaries !== a && (this._showTileBoundaries = a, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(a) {
          this._showPadding !== a && (this._showPadding = a, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(a) {
          this._showCollisionBoxes !== a && (this._showCollisionBoxes = a, a ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(a) {
          this._showOverdrawInspector !== a && (this._showOverdrawInspector = a, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(a) {
          this._repaint !== a && (this._repaint = a, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(a) {
          this._vertices = a, this._update();
        }
        get version() {
          return Ja;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, _.MapMouseEvent = br, _.MapTouchEvent = Ps, _.MapWheelEvent = Bl, _.Marker = xl, _.NavigationControl = class {
        constructor(a) {
          this._updateZoomButtons = () => {
            const e = this._map.getZoom(), r = e === this._map.getMaxZoom(), s = e === this._map.getMinZoom();
            this._zoomInButton.disabled = r, this._zoomOutButton.disabled = s, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", s.toString());
          }, this._rotateCompassArrow = () => {
            const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = e;
          }, this._setButtonTitle = (e, r) => {
            const s = this._map._getUIString(`NavigationControl.${r}`);
            e.title = s, e.setAttribute("aria-label", s);
          }, this.options = c.e({}, Hl, a), this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e) => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e) => this._map.zoomIn({}, { originalEvent: e })), V.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e) => this._map.zoomOut({}, { originalEvent: e })), V.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
          }), this._compassIcon = V.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(a) {
          return this._map = a, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new hc(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          V.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(a, e) {
          const r = V.create("button", a, this._container);
          return r.type = "button", r.addEventListener("click", e), r;
        }
      }, _.Popup = class extends c.E {
        constructor(a) {
          super(), this.remove = () => (this._content && V.remove(this._content), this._container && (V.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.k("close"))), this), this._onMouseUp = (e) => {
            this._update(e.point);
          }, this._onMouseMove = (e) => {
            this._update(e.point);
          }, this._onDrag = (e) => {
            this._update(e.point);
          }, this._update = (e) => {
            var r;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = V.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = V.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const b of this.options.className.split(" ")) this._container.classList.add(b);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Gi(this._lngLat, this._flatPos, this._map.transform) : (r = this._lngLat) === null || r === void 0 ? void 0 : r.wrap(), this._trackPointer && !e) return;
            const s = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationPoint(this._lngLat));
            let l = this.options.anchor;
            const h = m(this.options.offset);
            if (!l) {
              const b = this._container.offsetWidth, I = this._container.offsetHeight;
              let k;
              k = s.y + h.bottom.y < I ? ["top"] : s.y > this._map.transform.height - I ? ["bottom"] : [], s.x < b / 2 ? k.push("left") : s.x > this._map.transform.width - b / 2 && k.push("right"), l = k.length === 0 ? "bottom" : k.join("-");
            }
            let y = s.add(h[l]);
            this.options.subpixelPositioning || (y = y.round()), V.setTransform(this._container, `${_a[l]} translate(${y.x}px,${y.y}px)`), vl(this._container, l, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = c.e(Object.create(Kt), a);
        }
        addTo(a) {
          return this._map && this.remove(), this._map = a, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(a) {
          return this._lngLat = c.N.convert(a), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(a) {
          return this.setDOMContent(document.createTextNode(a));
        }
        setHTML(a) {
          const e = document.createDocumentFragment(), r = document.createElement("body");
          let s;
          for (r.innerHTML = a; s = r.firstChild, s; ) e.appendChild(s);
          return this.setDOMContent(e);
        }
        getMaxWidth() {
          var a;
          return (a = this._container) === null || a === void 0 ? void 0 : a.style.maxWidth;
        }
        setMaxWidth(a) {
          return this.options.maxWidth = a, this._update(), this;
        }
        setDOMContent(a) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = V.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(a), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(a) {
          return this._container && this._container.classList.add(a), this;
        }
        removeClassName(a) {
          return this._container && this._container.classList.remove(a), this;
        }
        setOffset(a) {
          return this.options.offset = a, this._update(), this;
        }
        toggleClassName(a) {
          if (this._container) return this._container.classList.toggle(a);
        }
        setSubpixelPositioning(a) {
          this.options.subpixelPositioning = a;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = V.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const a = this._container.querySelector(el);
          a && a.focus();
        }
      }, _.RasterDEMTileSource = yt, _.RasterTileSource = at, _.ScaleControl = class {
        constructor(a) {
          this._onMove = () => {
            mo(this._map, this._container, this.options);
          }, this.setUnit = (e) => {
            this.options.unit = e, mo(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, ds), a);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(a) {
          return this._map = a, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", a.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          V.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, _.ScrollZoomHandler = In, _.Style = Fr, _.TerrainControl = class {
        constructor(a) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = a;
        }
        onAdd(a) {
          return this._map = a, this._container = V.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = V.create("button", "maplibregl-ctrl-terrain", this._container), V.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          V.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, _.TwoFingersTouchPitchHandler = ma, _.TwoFingersTouchRotateHandler = ql, _.TwoFingersTouchZoomHandler = Ha, _.TwoFingersTouchZoomRotateHandler = $l, _.VectorTileSource = $t, _.VideoSource = di, _.addSourceType = (a, e) => c._(void 0, void 0, void 0, function* () {
        if (Ci(a)) throw new Error(`A source type called "${a}" already exists.`);
        ((r, s) => {
          bi[r] = s;
        })(a, e);
      }), _.clearPrewarmedResources = function() {
        const a = Oe;
        a && (a.isPreloaded() && a.numActive() === 1 ? (a.release(_e), Oe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, _.getMaxParallelImageRequests = function() {
        return c.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, _.getRTLTextPluginStatus = function() {
        return It().getRTLTextPluginStatus();
      }, _.getVersion = function() {
        return A;
      }, _.getWorkerCount = function() {
        return Ce.workerCount;
      }, _.getWorkerUrl = function() {
        return c.a.WORKER_URL;
      }, _.importScriptInWorkers = function(a) {
        return bt().broadcast("IS", a);
      }, _.prewarm = function() {
        Ze().acquire(_e);
      }, _.setMaxParallelImageRequests = function(a) {
        c.a.MAX_PARALLEL_IMAGE_REQUESTS = a;
      }, _.setRTLTextPlugin = function(a, e) {
        return It().setRTLTextPlugin(a, e);
      }, _.setWorkerCount = function(a) {
        Ce.workerCount = a;
      }, _.setWorkerUrl = function(a) {
        c.a.WORKER_URL = a;
      };
    });
    var w = p;
    return w;
  });
})(xf);
var jc = xf.exports;
const Hh = /* @__PURE__ */ qg(jc);
var Vg = Object.defineProperty, Ug = (x, d, p) => d in x ? Vg(x, d, { enumerable: !0, configurable: !0, writable: !0, value: p }) : x[d] = p, $i = (x, d, p) => Ug(x, typeof d != "symbol" ? d + "" : d, p);
class $g {
  constructor(d) {
    $i(this, "map"), $i(this, "width"), $i(this, "height"), $i(this, "svgCanvas"), $i(this, "xLine"), $i(this, "yLine"), $i(this, "color", "#535353"), this.map = d, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var d, p;
    this.width = (d = this.map) == null ? void 0 : d.getCanvas().clientWidth, this.height = (p = this.map) == null ? void 0 : p.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const d = this.width / 2, p = this.height / 2;
      this.yLine.setAttribute("x1", `${d}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${d}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${p}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${p}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(d) {
    if (this.width !== void 0 && this.height !== void 0) {
      const p = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      p.style.position = "relative", p.setAttribute("width", `${this.width}px`), p.setAttribute("height", `${this.height}px`);
      const v = this.width / 2, S = this.height / 2;
      this.yLine = p.appendChild(
        this.createLine(v, 0, v, this.height, this.color, "2px")
      ), this.xLine = p.appendChild(
        this.createLine(0, S, this.width, S, this.color, "2px")
      ), d == null || d.appendChild(p), this.svgCanvas = p;
    }
  }
  createLine(d, p, v, S, w, _) {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return c.setAttribute("x1", d), c.setAttribute("y1", p), c.setAttribute("x2", v), c.setAttribute("y2", S), c.setAttribute("stroke-dasharray", "5,5"), c.setAttribute("stroke", w), c.setAttribute("stroke-width", _), c;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Xh = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, Ea = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, zc = {
  Landscape: "landscape",
  Portrait: "portrait"
}, El = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, qc = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class Zg {
  constructor(d) {
    $i(this, "map"), $i(this, "width"), $i(this, "height"), $i(this, "unit"), $i(this, "svgCanvas"), $i(this, "svgPath");
    var p, v, S;
    if (this.map = d, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const w = (p = this.map) == null ? void 0 : p.getCanvas().clientWidth, _ = (v = this.map) == null ? void 0 : v.getCanvas().clientHeight, c = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    c.style.position = "absolute", c.style.top = "0px", c.style.left = "0px", c.setAttribute("width", `${w}px`), c.setAttribute("height", `${_}px`);
    const C = document.createElementNS("http://www.w3.org/2000/svg", "path");
    C.setAttribute("style", "fill:#888888;stroke-width:0"), C.setAttribute("fill-opacity", "0.5"), c.append(C), (S = this.map) == null || S.getCanvasContainer().appendChild(c), this.svgCanvas = c, this.svgPath = C;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(d, p) {
    this.width = d, this.height = p, this.unit = qc.mm, this.generateCutOut();
  }
  generateCutOut() {
    var d, p;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const v = this.toPixels(this.width), S = this.toPixels(this.height), w = (d = this.map) == null ? void 0 : d.getCanvas().clientWidth, _ = (p = this.map) == null ? void 0 : p.getCanvas().clientHeight, c = w / 2 - v / 2, C = c + v, N = _ / 2 - S / 2, q = N + S;
    this.svgCanvas.setAttribute("width", `${w}px`), this.svgCanvas.setAttribute("height", `${_}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${w} 0 L ${w} ${_} L 0 ${_} M ${c} ${N} L ${c} ${q} L ${C} ${q} L ${C} ${N}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(d, p = 96) {
    return this.unit === qc.mm && (p /= 25.4), p * d;
  }
}
const wf = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, Gg = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Générer",
  LanguageName: "Français",
  LanguageCode: "fr"
}, Wg = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, Hg = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflösung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, Xg = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, Yg = {
  PageSize: "Tamaño de página",
  PageOrientation: "Orientación de página",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Española",
  LanguageCode: "es"
}, Jg = {
  PageSize: "Mida",
  PageOrientation: "Orientació",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, Kg = {
  PageSize: "Kích thước trang",
  PageOrientation: "Loại trang",
  Format: "Định dạng",
  DPI: "Mật độ điểm ảnh (DPI)",
  Generate: "Tạo",
  LanguageName: "Tiếng Việt",
  LanguageCode: "vi"
}, Qg = {
  PageSize: "Розмір сторінки",
  PageOrientation: "Орієнтація сторінки",
  Format: "Формат",
  DPI: "DPI",
  Generate: "Згенерувати",
  LanguageName: "українська",
  LanguageCode: "uk"
}, e0 = {
  PageSize: "页面大小",
  PageOrientation: "页面方向",
  Format: "格式",
  DPI: "像素",
  Generate: "导出",
  LanguageName: "简体字",
  LanguageCode: "zhHans"
}, t0 = {
  PageSize: "頁面大小",
  PageOrientation: "頁面方向",
  Format: "格式",
  DPI: "像素",
  Generate: "導出",
  LanguageName: "繁体字",
  LanguageCode: "zhHant"
}, i0 = {
  PageSize: "ページサイズ",
  PageOrientation: "ページ方向",
  Format: "フォーマット",
  DPI: "DPI（解像度）",
  Generate: "出力",
  LanguageName: "日本語",
  LanguageCode: "ja"
}, r0 = {
  PageSize: "Tamanho da página",
  PageOrientation: "Orientação da página",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Português",
  LanguageCode: "pt"
}, n0 = [
  wf,
  Gg,
  Wg,
  Hg,
  Xg,
  Yg,
  Jg,
  Kg,
  Qg,
  e0,
  t0,
  i0,
  r0
], s0 = (x) => n0.find((d) => d.LanguageCode === x) ?? wf;
(function(x) {
  var d = {};
  function p(v) {
    if (d[v]) return d[v].exports;
    var S = d[v] = { i: v, l: !1, exports: {} };
    return x[v].call(S.exports, S, S.exports, p), S.l = !0, S.exports;
  }
  p.m = x, p.c = d, p.d = function(v, S, w) {
    p.o(v, S) || Object.defineProperty(v, S, { enumerable: !0, get: w });
  }, p.r = function(v) {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(v, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(v, "__esModule", { value: !0 });
  }, p.t = function(v, S) {
    if (1 & S && (v = p(v)), 8 & S || 4 & S && typeof v == "object" && v && v.__esModule) return v;
    var w = /* @__PURE__ */ Object.create(null);
    if (p.r(w), Object.defineProperty(w, "default", { enumerable: !0, value: v }), 2 & S && typeof v != "string") for (var _ in v) p.d(w, _, (function(c) {
      return v[c];
    }).bind(null, _));
    return w;
  }, p.n = function(v) {
    var S = v && v.__esModule ? function() {
      return v.default;
    } : function() {
      return v;
    };
    return p.d(S, "a", S), S;
  }, p.o = function(v, S) {
    return Object.prototype.hasOwnProperty.call(v, S);
  }, p.p = "", p(p.s = 0);
})([function(x, d, p) {
  x.exports = p(1);
}, function(x, d) {
  function p(S, w) {
    for (var _ = 0; _ < w.length; _++) {
      var c = w[_];
      c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(S, c.key, c);
    }
  }
  var v = function() {
    function S() {
      (function(c, C) {
        if (!(c instanceof C)) throw new TypeError("Cannot call a class as a function");
      })(this, S), this.options = { overlayBackgroundColor: "#666666", overlayOpacity: 0.6, spinnerIcon: "ball-circus", spinnerColor: "#000", spinnerSize: "3x", overlayIDName: "overlay", spinnerIDName: "spinner", offsetY: 0, offsetX: 0, lockScroll: !1, containerID: null, spinnerZIndex: 99999, overlayZIndex: 99998 }, this.stylesheetBaseURL = "https://cdn.jsdelivr.net/npm/load-awesome@1.1.0/css/", this.spinner = null, this.spinnerStylesheetURL = null, this.numberOfEmptyDivForSpinner = { "ball-8bits": 16, "ball-atom": 4, "ball-beat": 3, "ball-circus": 5, "ball-climbing-dot": 1, "ball-clip-rotate": 1, "ball-clip-rotate-multiple": 2, "ball-clip-rotate-pulse": 2, "ball-elastic-dots": 5, "ball-fall": 3, "ball-fussion": 4, "ball-grid-beat": 9, "ball-grid-pulse": 9, "ball-newton-cradle": 4, "ball-pulse": 3, "ball-pulse-rise": 5, "ball-pulse-sync": 3, "ball-rotate": 1, "ball-running-dots": 5, "ball-scale": 1, "ball-scale-multiple": 3, "ball-scale-pulse": 2, "ball-scale-ripple": 1, "ball-scale-ripple-multiple": 3, "ball-spin": 8, "ball-spin-clockwise": 8, "ball-spin-clockwise-fade": 8, "ball-spin-clockwise-fade-rotating": 8, "ball-spin-fade": 8, "ball-spin-fade-rotating": 8, "ball-spin-rotate": 2, "ball-square-clockwise-spin": 8, "ball-square-spin": 8, "ball-triangle-path": 3, "ball-zig-zag": 2, "ball-zig-zag-deflect": 2, cog: 1, "cube-transition": 2, fire: 3, "line-scale": 5, "line-scale-party": 5, "line-scale-pulse-out": 5, "line-scale-pulse-out-rapid": 5, "line-spin-clockwise-fade": 8, "line-spin-clockwise-fade-rotating": 8, "line-spin-fade": 8, "line-spin-fade-rotating": 8, pacman: 6, "square-jelly-box": 2, "square-loader": 1, "square-spin": 1, timer: 1, "triangle-skew-spin": 1 };
    }
    var w, _;
    return w = S, (_ = [{ key: "show", value: function(c) {
      this.setOptions(c), this.addSpinnerStylesheet(), this.generateSpinnerElement(), this.options.lockScroll && (document.body.style.overflow = "hidden", document.documentElement.style.overflow = "hidden"), this.generateAndAddOverlayElement();
    } }, { key: "hide", value: function() {
      this.options.lockScroll && (document.body.style.overflow = "", document.documentElement.style.overflow = "");
      var c = document.getElementById("loading-overlay-stylesheet");
      c && (c.disabled = !0, c.parentNode.removeChild(c), document.getElementById(this.options.overlayIDName).remove(), document.getElementById(this.options.spinnerIDName).remove());
    } }, { key: "setOptions", value: function(c) {
      if (c !== void 0) for (var C in c) this.options[C] = c[C];
    } }, { key: "generateAndAddOverlayElement", value: function() {
      var c = "50%";
      this.options.offsetX !== 0 && (c = "calc(50% + " + this.options.offsetX + ")");
      var C = "50%";
      if (this.options.offsetY !== 0 && (C = "calc(50% + " + this.options.offsetY + ")"), this.options.containerID && document.body.contains(document.getElementById(this.options.containerID))) {
        var N = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: absolute; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, '; z-index: 50; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: absolute; top: ').concat(C, "; left: ").concat(c, '; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: 9999;">').concat(this.spinner, "</div>"), q = document.getElementById(this.options.containerID);
        return q.style.position = "relative", void q.insertAdjacentHTML("beforeend", N);
      }
      var j = '<div id="'.concat(this.options.overlayIDName, '" style="display: block !important; position: fixed; top: 0; left: 0; overflow: auto; opacity: ').concat(this.options.overlayOpacity, "; background: ").concat(this.options.overlayBackgroundColor, "; z-index: ").concat(this.options.overlayZIndex, '; width: 100%; height: 100%;"></div><div id="').concat(this.options.spinnerIDName, '" style="display: block !important; position: fixed; top: ').concat(C, "; left: ").concat(c, "; -webkit-transform: translate(-50%); -ms-transform: translate(-50%); transform: translate(-50%); z-index: ").concat(this.options.spinnerZIndex, ';">').concat(this.spinner, "</div>");
      document.body.insertAdjacentHTML("beforeend", j);
    } }, { key: "generateSpinnerElement", value: function() {
      var c = this, C = Object.keys(this.numberOfEmptyDivForSpinner).find(function(q) {
        return q === c.options.spinnerIcon;
      }), N = this.generateEmptyDivElement(this.numberOfEmptyDivForSpinner[C]);
      this.spinner = '<div style="color: '.concat(this.options.spinnerColor, '" class="la-').concat(this.options.spinnerIcon, " la-").concat(this.options.spinnerSize, '">').concat(N, "</div>");
    } }, { key: "addSpinnerStylesheet", value: function() {
      this.setSpinnerStylesheetURL();
      var c = document.createElement("link");
      c.setAttribute("id", "loading-overlay-stylesheet"), c.setAttribute("rel", "stylesheet"), c.setAttribute("type", "text/css"), c.setAttribute("href", this.spinnerStylesheetURL), document.getElementsByTagName("head")[0].appendChild(c);
    } }, { key: "setSpinnerStylesheetURL", value: function() {
      this.spinnerStylesheetURL = this.stylesheetBaseURL + this.options.spinnerIcon + ".min.css";
    } }, { key: "generateEmptyDivElement", value: function(c) {
      for (var C = "", N = 1; N <= c; N++) C += "<div></div>";
      return C;
    } }]) && p(w.prototype, _), S;
  }();
  window.JsLoadingOverlay = new v(), x.exports = JsLoadingOverlay;
}]);
function rr(x) {
  "@babel/helpers - typeof";
  return rr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
    return typeof d;
  } : function(d) {
    return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
  }, rr(x);
}
var Ms = Uint8Array, gs = Uint16Array, _h = Uint32Array, iu = new Ms([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), ru = new Ms([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), id = new Ms([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Sf = function(x, d) {
  for (var p = new gs(31), v = 0; v < 31; ++v)
    p[v] = d += 1 << x[v - 1];
  for (var S = new _h(p[30]), v = 1; v < 30; ++v)
    for (var w = p[v]; w < p[v + 1]; ++w)
      S[w] = w - p[v] << 5 | v;
  return [p, S];
}, Af = Sf(iu, 2), Pf = Af[0], rd = Af[1];
Pf[28] = 258, rd[258] = 28;
var If = Sf(ru, 0), o0 = If[0], Wp = If[1], nd = new gs(32768);
for (var Ar = 0; Ar < 32768; ++Ar) {
  var kl = (Ar & 43690) >>> 1 | (Ar & 21845) << 1;
  kl = (kl & 52428) >>> 2 | (kl & 13107) << 2, kl = (kl & 61680) >>> 4 | (kl & 3855) << 4, nd[Ar] = ((kl & 65280) >>> 8 | (kl & 255) << 8) >>> 1;
}
var za = function(x, d, p) {
  for (var v = x.length, S = 0, w = new gs(d); S < v; ++S)
    ++w[x[S] - 1];
  var _ = new gs(d);
  for (S = 0; S < d; ++S)
    _[S] = _[S - 1] + w[S - 1] << 1;
  var c;
  if (p) {
    c = new gs(1 << d);
    var C = 15 - d;
    for (S = 0; S < v; ++S)
      if (x[S])
        for (var N = S << 4 | x[S], q = d - x[S], j = _[x[S] - 1]++ << q, V = j | (1 << q) - 1; j <= V; ++j)
          c[nd[j] >>> C] = N;
  } else
    for (c = new gs(v), S = 0; S < v; ++S)
      c[S] = nd[_[x[S] - 1]++] >>> 15 - x[S];
  return c;
}, zl = new Ms(288);
for (var Ar = 0; Ar < 144; ++Ar)
  zl[Ar] = 8;
for (var Ar = 144; Ar < 256; ++Ar)
  zl[Ar] = 9;
for (var Ar = 256; Ar < 280; ++Ar)
  zl[Ar] = 7;
for (var Ar = 280; Ar < 288; ++Ar)
  zl[Ar] = 8;
var vh = new Ms(32);
for (var Ar = 0; Ar < 32; ++Ar)
  vh[Ar] = 5;
var a0 = /* @__PURE__ */ za(zl, 9, 0), l0 = /* @__PURE__ */ za(zl, 9, 1), c0 = /* @__PURE__ */ za(vh, 5, 0), h0 = /* @__PURE__ */ za(vh, 5, 1), Zu = function(x) {
  for (var d = x[0], p = 1; p < x.length; ++p)
    x[p] > d && (d = x[p]);
  return d;
}, Vo = function(x, d, p) {
  var v = d / 8 >> 0;
  return (x[v] | x[v + 1] << 8) >>> (d & 7) & p;
}, Gu = function(x, d) {
  var p = d / 8 >> 0;
  return (x[p] | x[p + 1] << 8 | x[p + 2] << 16) >>> (d & 7);
}, md = function(x) {
  return (x / 8 >> 0) + (x & 7 && 1);
}, Lf = function(x, d, p) {
  (p == null || p > x.length) && (p = x.length);
  var v = new (x instanceof gs ? gs : x instanceof _h ? _h : Ms)(p - d);
  return v.set(x.subarray(d, p)), v;
}, u0 = function(x, d, p) {
  var v = x.length, S = !d || p, w = !p || p.i;
  p || (p = {}), d || (d = new Ms(v * 3));
  var _ = function(De) {
    var Oe = d.length;
    if (De > Oe) {
      var qe = new Ms(Math.max(Oe * 2, De));
      qe.set(d), d = qe;
    }
  }, c = p.f || 0, C = p.p || 0, N = p.b || 0, q = p.l, j = p.d, V = p.m, F = p.n, de = v * 8;
  do {
    if (!q) {
      p.f = c = Vo(x, C, 1);
      var ae = Vo(x, C + 1, 3);
      if (C += 3, ae)
        if (ae == 1)
          q = l0, j = h0, V = 9, F = 5;
        else if (ae == 2) {
          var ye = Vo(x, C, 31) + 257, se = Vo(x, C + 10, 15) + 4, ge = ye + Vo(x, C + 5, 31) + 1;
          C += 14;
          for (var Me = new Ms(ge), Ye = new Ms(19), $e = 0; $e < se; ++$e)
            Ye[id[$e]] = Vo(x, C + $e * 3, 7);
          C += se * 3;
          var tt = Zu(Ye), Be = (1 << tt) - 1;
          if (!w && C + ge * (tt + 7) > de)
            break;
          for (var Ie = za(Ye, tt, 1), $e = 0; $e < ge; ) {
            var ot = Ie[Vo(x, C, Be)];
            C += ot & 15;
            var it = ot >>> 4;
            if (it < 16)
              Me[$e++] = it;
            else {
              var oe = 0, le = 0;
              for (it == 16 ? (le = 3 + Vo(x, C, 3), C += 2, oe = Me[$e - 1]) : it == 17 ? (le = 3 + Vo(x, C, 7), C += 3) : it == 18 && (le = 11 + Vo(x, C, 127), C += 7); le--; )
                Me[$e++] = oe;
            }
          }
          var Le = Me.subarray(0, ye), Se = Me.subarray(ye);
          V = Zu(Le), F = Zu(Se), q = za(Le, V, 1), j = za(Se, F, 1);
        } else
          throw "invalid block type";
      else {
        var it = md(C) + 4, He = x[it - 4] | x[it - 3] << 8, We = it + He;
        if (We > v) {
          if (w)
            throw "unexpected EOF";
          break;
        }
        S && _(N + He), d.set(x.subarray(it, We), N), p.b = N += He, p.p = C = We * 8;
        continue;
      }
      if (C > de)
        throw "unexpected EOF";
    }
    S && _(N + 131072);
    for (var Je = (1 << V) - 1, je = (1 << F) - 1, rt = V + F + 18; w || C + rt < de; ) {
      var oe = q[Gu(x, C) & Je], Ke = oe >>> 4;
      if (C += oe & 15, C > de)
        throw "unexpected EOF";
      if (!oe)
        throw "invalid length/literal";
      if (Ke < 256)
        d[N++] = Ke;
      else if (Ke == 256) {
        q = null;
        break;
      } else {
        var St = Ke - 254;
        if (Ke > 264) {
          var $e = Ke - 257, J = iu[$e];
          St = Vo(x, C, (1 << J) - 1) + Pf[$e], C += J;
        }
        var fe = j[Gu(x, C) & je], _e = fe >>> 4;
        if (!fe)
          throw "invalid distance";
        C += fe & 15;
        var Se = o0[_e];
        if (_e > 3) {
          var J = ru[_e];
          Se += Gu(x, C) & (1 << J) - 1, C += J;
        }
        if (C > de)
          throw "unexpected EOF";
        S && _(N + 131072);
        for (var Ce = N + St; N < Ce; N += 4)
          d[N] = d[N - Se], d[N + 1] = d[N + 1 - Se], d[N + 2] = d[N + 2 - Se], d[N + 3] = d[N + 3 - Se];
        N = Ce;
      }
    }
    p.l = q, p.p = C, p.b = N, q && (c = 1, p.m = V, p.d = j, p.n = F);
  } while (!c);
  return N == d.length ? d : Lf(d, 0, N);
}, cl = function(x, d, p) {
  p <<= d & 7;
  var v = d / 8 >> 0;
  x[v] |= p, x[v + 1] |= p >>> 8;
}, fh = function(x, d, p) {
  p <<= d & 7;
  var v = d / 8 >> 0;
  x[v] |= p, x[v + 1] |= p >>> 8, x[v + 2] |= p >>> 16;
}, Wu = function(x, d) {
  for (var p = [], v = 0; v < x.length; ++v)
    x[v] && p.push({ s: v, f: x[v] });
  var S = p.length, w = p.slice();
  if (!S)
    return [new Ms(0), 0];
  if (S == 1) {
    var _ = new Ms(p[0].s + 1);
    return _[p[0].s] = 1, [_, 1];
  }
  p.sort(function($e, tt) {
    return $e.f - tt.f;
  }), p.push({ s: -1, f: 25001 });
  var c = p[0], C = p[1], N = 0, q = 1, j = 2;
  for (p[0] = { s: -1, f: c.f + C.f, l: c, r: C }; q != S - 1; )
    c = p[p[N].f < p[j].f ? N++ : j++], C = p[N != q && p[N].f < p[j].f ? N++ : j++], p[q++] = { s: -1, f: c.f + C.f, l: c, r: C };
  for (var V = w[0].s, v = 1; v < S; ++v)
    w[v].s > V && (V = w[v].s);
  var F = new gs(V + 1), de = sd(p[q - 1], F, 0);
  if (de > d) {
    var v = 0, ae = 0, ye = de - d, se = 1 << ye;
    for (w.sort(function(tt, Be) {
      return F[Be.s] - F[tt.s] || tt.f - Be.f;
    }); v < S; ++v) {
      var ge = w[v].s;
      if (F[ge] > d)
        ae += se - (1 << de - F[ge]), F[ge] = d;
      else
        break;
    }
    for (ae >>>= ye; ae > 0; ) {
      var Me = w[v].s;
      F[Me] < d ? ae -= 1 << d - F[Me]++ - 1 : ++v;
    }
    for (; v >= 0 && ae; --v) {
      var Ye = w[v].s;
      F[Ye] == d && (--F[Ye], ++ae);
    }
    de = d;
  }
  return [new Ms(F), de];
}, sd = function(x, d, p) {
  return x.s == -1 ? Math.max(sd(x.l, d, p + 1), sd(x.r, d, p + 1)) : d[x.s] = p;
}, Hp = function(x) {
  for (var d = x.length; d && !x[--d]; )
    ;
  for (var p = new gs(++d), v = 0, S = x[0], w = 1, _ = function(C) {
    p[v++] = C;
  }, c = 1; c <= d; ++c)
    if (x[c] == S && c != d)
      ++w;
    else {
      if (!S && w > 2) {
        for (; w > 138; w -= 138)
          _(32754);
        w > 2 && (_(w > 10 ? w - 11 << 5 | 28690 : w - 3 << 5 | 12305), w = 0);
      } else if (w > 3) {
        for (_(S), --w; w > 6; w -= 6)
          _(8304);
        w > 2 && (_(w - 3 << 5 | 8208), w = 0);
      }
      for (; w--; )
        _(S);
      w = 1, S = x[c];
    }
  return [p.subarray(0, v), d];
}, mh = function(x, d) {
  for (var p = 0, v = 0; v < d.length; ++v)
    p += x[v] * d[v];
  return p;
}, od = function(x, d, p) {
  var v = p.length, S = md(d + 2);
  x[S] = v & 255, x[S + 1] = v >>> 8, x[S + 2] = x[S] ^ 255, x[S + 3] = x[S + 1] ^ 255;
  for (var w = 0; w < v; ++w)
    x[S + w + 4] = p[w];
  return (S + 4 + v) * 8;
}, Xp = function(x, d, p, v, S, w, _, c, C, N, q) {
  cl(d, q++, p), ++S[256];
  for (var j = Wu(S, 15), V = j[0], F = j[1], de = Wu(w, 15), ae = de[0], ye = de[1], se = Hp(V), ge = se[0], Me = se[1], Ye = Hp(ae), $e = Ye[0], tt = Ye[1], Be = new gs(19), Ie = 0; Ie < ge.length; ++Ie)
    Be[ge[Ie] & 31]++;
  for (var Ie = 0; Ie < $e.length; ++Ie)
    Be[$e[Ie] & 31]++;
  for (var ot = Wu(Be, 7), it = ot[0], oe = ot[1], le = 19; le > 4 && !it[id[le - 1]]; --le)
    ;
  var Le = N + 5 << 3, Se = mh(S, zl) + mh(w, vh) + _, He = mh(S, V) + mh(w, ae) + _ + 14 + 3 * le + mh(Be, it) + (2 * Be[16] + 3 * Be[17] + 7 * Be[18]);
  if (Le <= Se && Le <= He)
    return od(d, q, x.subarray(C, C + N));
  var We, Je, je, rt;
  if (cl(d, q, 1 + (He < Se)), q += 2, He < Se) {
    We = za(V, F, 0), Je = V, je = za(ae, ye, 0), rt = ae;
    var Ke = za(it, oe, 0);
    cl(d, q, Me - 257), cl(d, q + 5, tt - 1), cl(d, q + 10, le - 4), q += 14;
    for (var Ie = 0; Ie < le; ++Ie)
      cl(d, q + 3 * Ie, it[id[Ie]]);
    q += 3 * le;
    for (var St = [ge, $e], J = 0; J < 2; ++J)
      for (var fe = St[J], Ie = 0; Ie < fe.length; ++Ie) {
        var _e = fe[Ie] & 31;
        cl(d, q, Ke[_e]), q += it[_e], _e > 15 && (cl(d, q, fe[Ie] >>> 5 & 127), q += fe[Ie] >>> 12);
      }
  } else
    We = a0, Je = zl, je = c0, rt = vh;
  for (var Ie = 0; Ie < c; ++Ie)
    if (v[Ie] > 255) {
      var _e = v[Ie] >>> 18 & 31;
      fh(d, q, We[_e + 257]), q += Je[_e + 257], _e > 7 && (cl(d, q, v[Ie] >>> 23 & 31), q += iu[_e]);
      var Ce = v[Ie] & 31;
      fh(d, q, je[Ce]), q += rt[Ce], Ce > 3 && (fh(d, q, v[Ie] >>> 5 & 8191), q += ru[Ce]);
    } else
      fh(d, q, We[v[Ie]]), q += Je[v[Ie]];
  return fh(d, q, We[256]), q + Je[256];
}, d0 = /* @__PURE__ */ new _h([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), p0 = function(x, d, p, v, S, w) {
  var _ = x.length, c = new Ms(v + _ + 5 * (1 + Math.floor(_ / 7e3)) + S), C = c.subarray(v, c.length - S), N = 0;
  if (!d || _ < 8)
    for (var q = 0; q <= _; q += 65535) {
      var j = q + 65535;
      j < _ ? N = od(C, N, x.subarray(q, j)) : (C[q] = w, N = od(C, N, x.subarray(q, _)));
    }
  else {
    for (var V = d0[d - 1], F = V >>> 13, de = V & 8191, ae = (1 << p) - 1, ye = new gs(32768), se = new gs(ae + 1), ge = Math.ceil(p / 3), Me = 2 * ge, Ye = function(Qt) {
      return (x[Qt] ^ x[Qt + 1] << ge ^ x[Qt + 2] << Me) & ae;
    }, $e = new _h(25e3), tt = new gs(288), Be = new gs(32), Ie = 0, ot = 0, q = 0, it = 0, oe = 0, le = 0; q < _; ++q) {
      var Le = Ye(q), Se = q & 32767, He = se[Le];
      if (ye[Se] = He, se[Le] = Se, oe <= q) {
        var We = _ - q;
        if ((Ie > 7e3 || it > 24576) && We > 423) {
          N = Xp(x, C, 0, $e, tt, Be, ot, it, le, q - le, N), it = Ie = ot = 0, le = q;
          for (var Je = 0; Je < 286; ++Je)
            tt[Je] = 0;
          for (var Je = 0; Je < 30; ++Je)
            Be[Je] = 0;
        }
        var je = 2, rt = 0, Ke = de, St = Se - He & 32767;
        if (We > 2 && Le == Ye(q - St))
          for (var J = Math.min(F, We) - 1, fe = Math.min(32767, q), _e = Math.min(258, We); St <= fe && --Ke && Se != He; ) {
            if (x[q + je] == x[q + je - St]) {
              for (var Ce = 0; Ce < _e && x[q + Ce] == x[q + Ce - St]; ++Ce)
                ;
              if (Ce > je) {
                if (je = Ce, rt = St, Ce > J)
                  break;
                for (var De = Math.min(St, Ce - 2), Oe = 0, Je = 0; Je < De; ++Je) {
                  var qe = q - St + Je + 32768 & 32767, Ze = ye[qe], wt = qe - Ze + 32768 & 32767;
                  wt > Oe && (Oe = wt, He = qe);
                }
              }
            }
            Se = He, He = ye[Se], St += Se - He + 32768 & 32767;
          }
        if (rt) {
          $e[it++] = 268435456 | rd[je] << 18 | Wp[rt];
          var bt = rd[je] & 31, Tt = Wp[rt] & 31;
          ot += iu[bt] + ru[Tt], ++tt[257 + bt], ++Be[Tt], oe = q + je, ++Ie;
        } else
          $e[it++] = x[q], ++tt[x[q]];
      }
    }
    N = Xp(x, C, w, $e, tt, Be, ot, it, le, q - le, N);
  }
  return Lf(c, 0, v + md(N) + S);
}, f0 = function() {
  var x = 1, d = 0;
  return {
    p: function(p) {
      for (var v = x, S = d, w = p.length, _ = 0; _ != w; ) {
        for (var c = Math.min(_ + 5552, w); _ < c; ++_)
          v += p[_], S += v;
        v %= 65521, S %= 65521;
      }
      x = v, d = S;
    },
    d: function() {
      return (x >>> 8 << 16 | (d & 255) << 8 | d >>> 8) + ((x & 255) << 23) * 2;
    }
  };
}, m0 = function(x, d, p, v, S) {
  return p0(x, d.level == null ? 6 : d.level, d.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(x.length))) * 1.5) : 12 + d.mem, p, v, !S);
}, g0 = function(x, d, p) {
  for (; p; ++d)
    x[d] = p, p >>>= 8;
}, y0 = function(x, d) {
  var p = d.level, v = p == 0 ? 0 : p < 6 ? 1 : p == 9 ? 3 : 2;
  x[0] = 120, x[1] = v << 6 | (v ? 32 - 2 * v : 1);
}, _0 = function(x) {
  if ((x[0] & 15) != 8 || x[0] >>> 4 > 7 || (x[0] << 8 | x[1]) % 31)
    throw "invalid zlib data";
  if (x[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function ad(x, d) {
  d === void 0 && (d = {});
  var p = f0();
  p.p(x);
  var v = m0(x, d, 2, 4);
  return y0(v, d), g0(v, v.length - 4, p.d()), v;
}
function v0(x, d) {
  return u0((_0(x), x.subarray(2, -4)), d);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var _i = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Hu() {
  _i.console && typeof _i.console.log == "function" && _i.console.log.apply(_i.console, arguments);
}
var pr = { log: Hu, warn: function(x) {
  _i.console && (typeof _i.console.warn == "function" ? _i.console.warn.apply(_i.console, arguments) : Hu.call(null, arguments));
}, error: function(x) {
  _i.console && (typeof _i.console.error == "function" ? _i.console.error.apply(_i.console, arguments) : Hu(x));
} };
function Xu(x, d, p) {
  var v = new XMLHttpRequest();
  v.open("GET", x), v.responseType = "blob", v.onload = function() {
    rc(v.response, d, p);
  }, v.onerror = function() {
    pr.error("could not download file");
  }, v.send();
}
function Yp(x) {
  var d = new XMLHttpRequest();
  d.open("HEAD", x, !1);
  try {
    d.send();
  } catch {
  }
  return d.status >= 200 && d.status <= 299;
}
function Oh(x) {
  try {
    x.dispatchEvent(new MouseEvent("click"));
  } catch {
    var d = document.createEvent("MouseEvents");
    d.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), x.dispatchEvent(d);
  }
}
var yh, ld, rc = _i.saveAs || ((typeof window > "u" ? "undefined" : rr(window)) !== "object" || window !== _i ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(x, d, p) {
  var v = _i.URL || _i.webkitURL, S = document.createElement("a");
  d = d || x.name || "download", S.download = d, S.rel = "noopener", typeof x == "string" ? (S.href = x, S.origin !== location.origin ? Yp(S.href) ? Xu(x, d, p) : Oh(S, S.target = "_blank") : Oh(S)) : (S.href = v.createObjectURL(x), setTimeout(function() {
    v.revokeObjectURL(S.href);
  }, 4e4), setTimeout(function() {
    Oh(S);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(x, d, p) {
  if (d = d || x.name || "download", typeof x == "string") if (Yp(x)) Xu(x, d, p);
  else {
    var v = document.createElement("a");
    v.href = x, v.target = "_blank", setTimeout(function() {
      Oh(v);
    });
  }
  else navigator.msSaveOrOpenBlob(function(S, w) {
    return w === void 0 ? w = { autoBom: !1 } : rr(w) !== "object" && (pr.warn("Deprecated: Expected third argument to be a object"), w = { autoBom: !w }), w.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(S.type) ? new Blob(["\uFEFF", S], { type: S.type }) : S;
  }(x, p), d);
} : function(x, d, p, v) {
  if ((v = v || open("", "_blank")) && (v.document.title = v.document.body.innerText = "downloading..."), typeof x == "string") return Xu(x, d, p);
  var S = x.type === "application/octet-stream", w = /constructor/i.test(_i.HTMLElement) || _i.safari, _ = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((_ || S && w) && (typeof FileReader > "u" ? "undefined" : rr(FileReader)) === "object") {
    var c = new FileReader();
    c.onloadend = function() {
      var q = c.result;
      q = _ ? q : q.replace(/^data:[^;]*;/, "data:attachment/file;"), v ? v.location.href = q : location = q, v = null;
    }, c.readAsDataURL(x);
  } else {
    var C = _i.URL || _i.webkitURL, N = C.createObjectURL(x);
    v ? v.location = N : location.href = N, v = null, setTimeout(function() {
      C.revokeObjectURL(N);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function Tf(x) {
  var d;
  x = x || "", this.ok = !1, x.charAt(0) == "#" && (x = x.substr(1, 6)), x = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[x = (x = x.replace(/ /g, "")).toLowerCase()] || x;
  for (var p = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(c) {
    return [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(c) {
    return [parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(c) {
    return [parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16)];
  } }], v = 0; v < p.length; v++) {
    var S = p[v].re, w = p[v].process, _ = S.exec(x);
    _ && (d = w(_), this.r = d[0], this.g = d[1], this.b = d[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var c = this.r.toString(16), C = this.g.toString(16), N = this.b.toString(16);
    return c.length == 1 && (c = "0" + c), C.length == 1 && (C = "0" + C), N.length == 1 && (N = "0" + N), "#" + c + C + N;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Yu(x, d) {
  var p = x[0], v = x[1], S = x[2], w = x[3];
  p = Yn(p, v, S, w, d[0], 7, -680876936), w = Yn(w, p, v, S, d[1], 12, -389564586), S = Yn(S, w, p, v, d[2], 17, 606105819), v = Yn(v, S, w, p, d[3], 22, -1044525330), p = Yn(p, v, S, w, d[4], 7, -176418897), w = Yn(w, p, v, S, d[5], 12, 1200080426), S = Yn(S, w, p, v, d[6], 17, -1473231341), v = Yn(v, S, w, p, d[7], 22, -45705983), p = Yn(p, v, S, w, d[8], 7, 1770035416), w = Yn(w, p, v, S, d[9], 12, -1958414417), S = Yn(S, w, p, v, d[10], 17, -42063), v = Yn(v, S, w, p, d[11], 22, -1990404162), p = Yn(p, v, S, w, d[12], 7, 1804603682), w = Yn(w, p, v, S, d[13], 12, -40341101), S = Yn(S, w, p, v, d[14], 17, -1502002290), p = Jn(p, v = Yn(v, S, w, p, d[15], 22, 1236535329), S, w, d[1], 5, -165796510), w = Jn(w, p, v, S, d[6], 9, -1069501632), S = Jn(S, w, p, v, d[11], 14, 643717713), v = Jn(v, S, w, p, d[0], 20, -373897302), p = Jn(p, v, S, w, d[5], 5, -701558691), w = Jn(w, p, v, S, d[10], 9, 38016083), S = Jn(S, w, p, v, d[15], 14, -660478335), v = Jn(v, S, w, p, d[4], 20, -405537848), p = Jn(p, v, S, w, d[9], 5, 568446438), w = Jn(w, p, v, S, d[14], 9, -1019803690), S = Jn(S, w, p, v, d[3], 14, -187363961), v = Jn(v, S, w, p, d[8], 20, 1163531501), p = Jn(p, v, S, w, d[13], 5, -1444681467), w = Jn(w, p, v, S, d[2], 9, -51403784), S = Jn(S, w, p, v, d[7], 14, 1735328473), p = Kn(p, v = Jn(v, S, w, p, d[12], 20, -1926607734), S, w, d[5], 4, -378558), w = Kn(w, p, v, S, d[8], 11, -2022574463), S = Kn(S, w, p, v, d[11], 16, 1839030562), v = Kn(v, S, w, p, d[14], 23, -35309556), p = Kn(p, v, S, w, d[1], 4, -1530992060), w = Kn(w, p, v, S, d[4], 11, 1272893353), S = Kn(S, w, p, v, d[7], 16, -155497632), v = Kn(v, S, w, p, d[10], 23, -1094730640), p = Kn(p, v, S, w, d[13], 4, 681279174), w = Kn(w, p, v, S, d[0], 11, -358537222), S = Kn(S, w, p, v, d[3], 16, -722521979), v = Kn(v, S, w, p, d[6], 23, 76029189), p = Kn(p, v, S, w, d[9], 4, -640364487), w = Kn(w, p, v, S, d[12], 11, -421815835), S = Kn(S, w, p, v, d[15], 16, 530742520), p = Qn(p, v = Kn(v, S, w, p, d[2], 23, -995338651), S, w, d[0], 6, -198630844), w = Qn(w, p, v, S, d[7], 10, 1126891415), S = Qn(S, w, p, v, d[14], 15, -1416354905), v = Qn(v, S, w, p, d[5], 21, -57434055), p = Qn(p, v, S, w, d[12], 6, 1700485571), w = Qn(w, p, v, S, d[3], 10, -1894986606), S = Qn(S, w, p, v, d[10], 15, -1051523), v = Qn(v, S, w, p, d[1], 21, -2054922799), p = Qn(p, v, S, w, d[8], 6, 1873313359), w = Qn(w, p, v, S, d[15], 10, -30611744), S = Qn(S, w, p, v, d[6], 15, -1560198380), v = Qn(v, S, w, p, d[13], 21, 1309151649), p = Qn(p, v, S, w, d[4], 6, -145523070), w = Qn(w, p, v, S, d[11], 10, -1120210379), S = Qn(S, w, p, v, d[2], 15, 718787259), v = Qn(v, S, w, p, d[9], 21, -343485551), x[0] = Ml(p, x[0]), x[1] = Ml(v, x[1]), x[2] = Ml(S, x[2]), x[3] = Ml(w, x[3]);
}
function nu(x, d, p, v, S, w) {
  return d = Ml(Ml(d, x), Ml(v, w)), Ml(d << S | d >>> 32 - S, p);
}
function Yn(x, d, p, v, S, w, _) {
  return nu(d & p | ~d & v, x, d, S, w, _);
}
function Jn(x, d, p, v, S, w, _) {
  return nu(d & v | p & ~v, x, d, S, w, _);
}
function Kn(x, d, p, v, S, w, _) {
  return nu(d ^ p ^ v, x, d, S, w, _);
}
function Qn(x, d, p, v, S, w, _) {
  return nu(p ^ (d | ~v), x, d, S, w, _);
}
function kf(x) {
  var d, p = x.length, v = [1732584193, -271733879, -1732584194, 271733878];
  for (d = 64; d <= x.length; d += 64) Yu(v, x0(x.substring(d - 64, d)));
  x = x.substring(d - 64);
  var S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (d = 0; d < x.length; d++) S[d >> 2] |= x.charCodeAt(d) << (d % 4 << 3);
  if (S[d >> 2] |= 128 << (d % 4 << 3), d > 55) for (Yu(v, S), d = 0; d < 16; d++) S[d] = 0;
  return S[14] = 8 * p, Yu(v, S), v;
}
function x0(x) {
  var d, p = [];
  for (d = 0; d < 64; d += 4) p[d >> 2] = x.charCodeAt(d) + (x.charCodeAt(d + 1) << 8) + (x.charCodeAt(d + 2) << 16) + (x.charCodeAt(d + 3) << 24);
  return p;
}
yh = _i.atob.bind(_i), ld = _i.btoa.bind(_i);
var Jp = "0123456789abcdef".split("");
function b0(x) {
  for (var d = "", p = 0; p < 4; p++) d += Jp[x >> 8 * p + 4 & 15] + Jp[x >> 8 * p & 15];
  return d;
}
function w0(x) {
  return String.fromCharCode((255 & x) >> 0, (65280 & x) >> 8, (16711680 & x) >> 16, (4278190080 & x) >> 24);
}
function cd(x) {
  return kf(x).map(w0).join("");
}
var S0 = function(x) {
  for (var d = 0; d < x.length; d++) x[d] = b0(x[d]);
  return x.join("");
}(kf("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Ml(x, d) {
  if (S0) {
    var p = (65535 & x) + (65535 & d);
    return (x >> 16) + (d >> 16) + (p >> 16) << 16 | 65535 & p;
  }
  return x + d & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function hd(x, d) {
  var p, v, S, w;
  if (x !== p) {
    for (var _ = (S = x, w = 1 + (256 / x.length >> 0), new Array(w + 1).join(S)), c = [], C = 0; C < 256; C++) c[C] = C;
    var N = 0;
    for (C = 0; C < 256; C++) {
      var q = c[C];
      N = (N + q + _.charCodeAt(C)) % 256, c[C] = c[N], c[N] = q;
    }
    p = x, v = c;
  } else c = v;
  var j = d.length, V = 0, F = 0, de = "";
  for (C = 0; C < j; C++) F = (F + (q = c[V = (V + 1) % 256])) % 256, c[V] = c[F], c[F] = q, _ = c[(c[V] + c[F]) % 256], de += String.fromCharCode(d.charCodeAt(C) ^ _);
  return de;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Kp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Ec(x, d, p, v) {
  this.v = 1, this.r = 2;
  var S = 192;
  x.forEach(function(c) {
    if (Kp.perm !== void 0) throw new Error("Invalid permission: " + c);
    S += Kp[c];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var w = (d + this.padding).substr(0, 32), _ = (p + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(w, _), this.P = -(1 + (255 ^ S)), this.encryptionKey = cd(w + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(v)).substr(0, 5), this.U = hd(this.encryptionKey, this.padding);
}
function Mc(x) {
  if (/[^\u0000-\u00ff]/.test(x)) throw new Error("Invalid PDF Name Object: " + x + ", Only accept ASCII characters.");
  for (var d = "", p = x.length, v = 0; v < p; v++) {
    var S = x.charCodeAt(v);
    S < 33 || S === 35 || S === 37 || S === 40 || S === 41 || S === 47 || S === 60 || S === 62 || S === 91 || S === 93 || S === 123 || S === 125 || S > 126 ? d += "#" + ("0" + S.toString(16)).slice(-2) : d += x[v];
  }
  return d;
}
function Qp(x) {
  if (rr(x) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var d = {};
  this.subscribe = function(p, v, S) {
    if (S = S || !1, typeof p != "string" || typeof v != "function" || typeof S != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    d.hasOwnProperty(p) || (d[p] = {});
    var w = Math.random().toString(35);
    return d[p][w] = [v, !!S], w;
  }, this.unsubscribe = function(p) {
    for (var v in d) if (d[v][p]) return delete d[v][p], Object.keys(d[v]).length === 0 && delete d[v], !0;
    return !1;
  }, this.publish = function(p) {
    if (d.hasOwnProperty(p)) {
      var v = Array.prototype.slice.call(arguments, 1), S = [];
      for (var w in d[p]) {
        var _ = d[p][w];
        try {
          _[0].apply(x, v);
        } catch (c) {
          _i.console && pr.error("jsPDF PubSub Error", c.message, c);
        }
        _[1] && S.push(w);
      }
      S.length && S.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return d;
  };
}
function Yh(x) {
  if (!(this instanceof Yh)) return new Yh(x);
  var d = "opacity,stroke-opacity".split(",");
  for (var p in x) x.hasOwnProperty(p) && d.indexOf(p) >= 0 && (this[p] = x[p]);
  this.id = "", this.objectNumber = -1;
}
function Cf(x, d) {
  this.gState = x, this.matrix = d, this.id = "", this.objectNumber = -1;
}
function nc(x, d, p, v, S) {
  if (!(this instanceof nc)) return new nc(x, d, p, v, S);
  this.type = x === "axial" ? 2 : 3, this.coords = d, this.colors = p, Cf.call(this, v, S);
}
function Dc(x, d, p, v, S) {
  if (!(this instanceof Dc)) return new Dc(x, d, p, v, S);
  this.boundingBox = x, this.xStep = d, this.yStep = p, this.stream = "", this.cloneIndex = 0, Cf.call(this, v, S);
}
function yi(x) {
  var d, p = typeof arguments[0] == "string" ? arguments[0] : "p", v = arguments[1], S = arguments[2], w = arguments[3], _ = [], c = 1, C = 16, N = "S", q = null;
  rr(x = x || {}) === "object" && (p = x.orientation, v = x.unit || v, S = x.format || S, w = x.compress || x.compressPdf || w, (q = x.encryption || null) !== null && (q.userPassword = q.userPassword || "", q.ownerPassword = q.ownerPassword || "", q.userPermissions = q.userPermissions || []), c = typeof x.userUnit == "number" ? Math.abs(x.userUnit) : 1, x.precision !== void 0 && (d = x.precision), x.floatPrecision !== void 0 && (C = x.floatPrecision), N = x.defaultPathOperation || "S"), _ = x.filters || (w === !0 ? ["FlateEncode"] : _), v = v || "mm", p = ("" + (p || "P")).toLowerCase();
  var j = x.putOnlyUsedFonts || !1, V = {}, F = { internal: {}, __private__: {} };
  F.__private__.PubSub = Qp;
  var de = "1.3", ae = F.__private__.getPdfVersion = function() {
    return de;
  };
  F.__private__.setPdfVersion = function(T) {
    de = T;
  };
  var ye = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  F.__private__.getPageFormats = function() {
    return ye;
  };
  var se = F.__private__.getPageFormat = function(T) {
    return ye[T];
  };
  S = S || "a4";
  var ge = { COMPAT: "compat", ADVANCED: "advanced" }, Me = ge.COMPAT;
  function Ye() {
    this.saveGraphicsState(), Y(new Ae(It, 0, 0, -It, 0, so() * It).toString() + " cm"), this.setFontSize(this.getFontSize() / It), N = "n", Me = ge.ADVANCED;
  }
  function $e() {
    this.restoreGraphicsState(), N = "S", Me = ge.COMPAT;
  }
  var tt = F.__private__.combineFontStyleAndFontWeight = function(T, X) {
    if (T == "bold" && X == "normal" || T == "bold" && X == 400 || T == "normal" && X == "italic" || T == "bold" && X == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return X && (T = X == 400 || X === "normal" ? T === "italic" ? "italic" : "normal" : X != 700 && X !== "bold" || T !== "normal" ? (X == 700 ? "bold" : X) + "" + T : "bold"), T;
  };
  F.advancedAPI = function(T) {
    var X = Me === ge.COMPAT;
    return X && Ye.call(this), typeof T != "function" || (T(this), X && $e.call(this)), this;
  }, F.compatAPI = function(T) {
    var X = Me === ge.ADVANCED;
    return X && $e.call(this), typeof T != "function" || (T(this), X && Ye.call(this)), this;
  }, F.isAdvancedAPI = function() {
    return Me === ge.ADVANCED;
  };
  var Be, Ie = function(T) {
    if (Me !== ge.ADVANCED) throw new Error(T + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, ot = F.roundToPrecision = F.__private__.roundToPrecision = function(T, X) {
    var me = d || X;
    if (isNaN(T) || isNaN(me)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return T.toFixed(me).replace(/0+$/, "");
  };
  Be = F.hpf = F.__private__.hpf = typeof C == "number" ? function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return ot(T, C);
  } : C === "smart" ? function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return ot(T, T > -1 && T < 1 ? 16 : 5);
  } : function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return ot(T, 16);
  };
  var it = F.f2 = F.__private__.f2 = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.f2");
    return ot(T, 2);
  }, oe = F.__private__.f3 = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.f3");
    return ot(T, 3);
  }, le = F.scale = F.__private__.scale = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.scale");
    return Me === ge.COMPAT ? T * It : Me === ge.ADVANCED ? T : void 0;
  }, Le = function(T) {
    return Me === ge.COMPAT ? so() - T : Me === ge.ADVANCED ? T : void 0;
  }, Se = function(T) {
    return le(Le(T));
  };
  F.__private__.setPrecision = F.setPrecision = function(T) {
    typeof parseInt(T, 10) == "number" && (d = parseInt(T, 10));
  };
  var He, We = "00000000000000000000000000000000", Je = F.__private__.getFileId = function() {
    return We;
  }, je = F.__private__.setFileId = function(T) {
    return We = T !== void 0 && /^[a-fA-F0-9]{32}$/.test(T) ? T.toUpperCase() : We.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), q !== null && (gr = new Ec(q.userPermissions, q.userPassword, q.ownerPassword, We)), We;
  };
  F.setFileId = function(T) {
    return je(T), this;
  }, F.getFileId = function() {
    return Je();
  };
  var rt = F.__private__.convertDateToPDFDate = function(T) {
    var X = T.getTimezoneOffset(), me = X < 0 ? "+" : "-", ke = Math.floor(Math.abs(X / 60)), Fe = Math.abs(X % 60), Xe = [me, _e(ke), "'", _e(Fe), "'"].join("");
    return ["D:", T.getFullYear(), _e(T.getMonth() + 1), _e(T.getDate()), _e(T.getHours()), _e(T.getMinutes()), _e(T.getSeconds()), Xe].join("");
  }, Ke = F.__private__.convertPDFDateToDate = function(T) {
    var X = parseInt(T.substr(2, 4), 10), me = parseInt(T.substr(6, 2), 10) - 1, ke = parseInt(T.substr(8, 2), 10), Fe = parseInt(T.substr(10, 2), 10), Xe = parseInt(T.substr(12, 2), 10), xt = parseInt(T.substr(14, 2), 10);
    return new Date(X, me, ke, Fe, Xe, xt, 0);
  }, St = F.__private__.setCreationDate = function(T) {
    var X;
    if (T === void 0 && (T = /* @__PURE__ */ new Date()), T instanceof Date) X = rt(T);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(T)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      X = T;
    }
    return He = X;
  }, J = F.__private__.getCreationDate = function(T) {
    var X = He;
    return T === "jsDate" && (X = Ke(He)), X;
  };
  F.setCreationDate = function(T) {
    return St(T), this;
  }, F.getCreationDate = function(T) {
    return J(T);
  };
  var fe, _e = F.__private__.padd2 = function(T) {
    return ("0" + parseInt(T)).slice(-2);
  }, Ce = F.__private__.padd2Hex = function(T) {
    return ("00" + (T = T.toString())).substr(T.length);
  }, De = 0, Oe = [], qe = [], Ze = 0, wt = [], bt = [], Tt = !1, Mt = qe, Qt = function() {
    De = 0, Ze = 0, qe = [], Oe = [], wt = [], vi = mt(), Jt = mt();
  };
  F.__private__.setCustomOutputDestination = function(T) {
    Tt = !0, Mt = T;
  };
  var Qe = function(T) {
    Tt || (Mt = T);
  };
  F.__private__.resetCustomOutputDestination = function() {
    Tt = !1, Mt = qe;
  };
  var Y = F.__private__.out = function(T) {
    return T = T.toString(), Ze += T.length + 1, Mt.push(T), Mt;
  }, ui = F.__private__.write = function(T) {
    return Y(arguments.length === 1 ? T.toString() : Array.prototype.join.call(arguments, " "));
  }, $t = F.__private__.getArrayBuffer = function(T) {
    for (var X = T.length, me = new ArrayBuffer(X), ke = new Uint8Array(me); X--; ) ke[X] = T.charCodeAt(X);
    return me;
  }, at = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  F.__private__.getStandardFonts = function() {
    return at;
  };
  var yt = x.fontSize || 16;
  F.__private__.setFontSize = F.setFontSize = function(T) {
    return yt = Me === ge.ADVANCED ? T / It : T, this;
  };
  var zt, Pt = F.__private__.getFontSize = F.getFontSize = function() {
    return Me === ge.COMPAT ? yt : yt * It;
  }, Gt = x.R2L || !1;
  F.__private__.setR2L = F.setR2L = function(T) {
    return Gt = T, this;
  }, F.__private__.getR2L = F.getR2L = function() {
    return Gt;
  };
  var di, oi = F.__private__.setZoomMode = function(T) {
    var X = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(T)) zt = T;
    else if (isNaN(T)) {
      if (X.indexOf(T) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + T + '" is not recognized.');
      zt = T;
    } else zt = parseInt(T, 10);
  };
  F.__private__.getZoomMode = function() {
    return zt;
  };
  var bi, Ci = F.__private__.setPageMode = function(T) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(T) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + T + '" is not recognized.');
    di = T;
  };
  F.__private__.getPageMode = function() {
    return di;
  };
  var lt = F.__private__.setLayoutMode = function(T) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(T) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + T + '" is not recognized.');
    bi = T;
  };
  F.__private__.getLayoutMode = function() {
    return bi;
  }, F.__private__.setDisplayMode = F.setDisplayMode = function(T, X, me) {
    return oi(T), lt(X), Ci(me), this;
  };
  var ei = { title: "", subject: "", author: "", keywords: "", creator: "" };
  F.__private__.getDocumentProperty = function(T) {
    if (Object.keys(ei).indexOf(T) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ei[T];
  }, F.__private__.getDocumentProperties = function() {
    return ei;
  }, F.__private__.setDocumentProperties = F.setProperties = F.setDocumentProperties = function(T) {
    for (var X in ei) ei.hasOwnProperty(X) && T[X] && (ei[X] = T[X]);
    return this;
  }, F.__private__.setDocumentProperty = function(T, X) {
    if (Object.keys(ei).indexOf(T) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ei[T] = X;
  };
  var ai, It, cr, ct, si, kt = {}, Ei = {}, Pr = [], Et = {}, $r = {}, qi = {}, Cr = {}, Er = null, ue = 0, $ = [], W = new Qp(F), te = x.hotfixes || [], ce = {}, Pe = {}, Ee = [], Ae = function T(X, me, ke, Fe, Xe, xt) {
    if (!(this instanceof T)) return new T(X, me, ke, Fe, Xe, xt);
    isNaN(X) && (X = 1), isNaN(me) && (me = 0), isNaN(ke) && (ke = 0), isNaN(Fe) && (Fe = 1), isNaN(Xe) && (Xe = 0), isNaN(xt) && (xt = 0), this._matrix = [X, me, ke, Fe, Xe, xt];
  };
  Object.defineProperty(Ae.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(T) {
    this._matrix[0] = T;
  } }), Object.defineProperty(Ae.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(T) {
    this._matrix[1] = T;
  } }), Object.defineProperty(Ae.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(T) {
    this._matrix[2] = T;
  } }), Object.defineProperty(Ae.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(T) {
    this._matrix[3] = T;
  } }), Object.defineProperty(Ae.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(T) {
    this._matrix[4] = T;
  } }), Object.defineProperty(Ae.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(T) {
    this._matrix[5] = T;
  } }), Object.defineProperty(Ae.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(T) {
    this._matrix[0] = T;
  } }), Object.defineProperty(Ae.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(T) {
    this._matrix[1] = T;
  } }), Object.defineProperty(Ae.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(T) {
    this._matrix[2] = T;
  } }), Object.defineProperty(Ae.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(T) {
    this._matrix[3] = T;
  } }), Object.defineProperty(Ae.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(T) {
    this._matrix[4] = T;
  } }), Object.defineProperty(Ae.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(T) {
    this._matrix[5] = T;
  } }), Object.defineProperty(Ae.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Ae.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Ae.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Ae.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Ae.prototype.join = function(T) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Be).join(T);
  }, Ae.prototype.multiply = function(T) {
    var X = T.sx * this.sx + T.shy * this.shx, me = T.sx * this.shy + T.shy * this.sy, ke = T.shx * this.sx + T.sy * this.shx, Fe = T.shx * this.shy + T.sy * this.sy, Xe = T.tx * this.sx + T.ty * this.shx + this.tx, xt = T.tx * this.shy + T.ty * this.sy + this.ty;
    return new Ae(X, me, ke, Fe, Xe, xt);
  }, Ae.prototype.decompose = function() {
    var T = this.sx, X = this.shy, me = this.shx, ke = this.sy, Fe = this.tx, Xe = this.ty, xt = Math.sqrt(T * T + X * X), Rt = (T /= xt) * me + (X /= xt) * ke;
    me -= T * Rt, ke -= X * Rt;
    var ti = Math.sqrt(me * me + ke * ke);
    return Rt /= ti, T * (ke /= ti) < X * (me /= ti) && (T = -T, X = -X, Rt = -Rt, xt = -xt), { scale: new Ae(xt, 0, 0, ti, 0, 0), translate: new Ae(1, 0, 0, 1, Fe, Xe), rotate: new Ae(T, X, -X, T, 0, 0), skew: new Ae(1, 0, Rt, 1, 0, 0) };
  }, Ae.prototype.toString = function(T) {
    return this.join(" ");
  }, Ae.prototype.inversed = function() {
    var T = this.sx, X = this.shy, me = this.shx, ke = this.sy, Fe = this.tx, Xe = this.ty, xt = 1 / (T * ke - X * me), Rt = ke * xt, ti = -X * xt, mi = -me * xt, wi = T * xt;
    return new Ae(Rt, ti, mi, wi, -Rt * Fe - mi * Xe, -ti * Fe - wi * Xe);
  }, Ae.prototype.applyToPoint = function(T) {
    var X = T.x * this.sx + T.y * this.shx + this.tx, me = T.x * this.shy + T.y * this.sy + this.ty;
    return new Nn(X, me);
  }, Ae.prototype.applyToRectangle = function(T) {
    var X = this.applyToPoint(T), me = this.applyToPoint(new Nn(T.x + T.w, T.y + T.h));
    return new aa(X.x, X.y, me.x - X.x, me.y - X.y);
  }, Ae.prototype.clone = function() {
    var T = this.sx, X = this.shy, me = this.shx, ke = this.sy, Fe = this.tx, Xe = this.ty;
    return new Ae(T, X, me, ke, Fe, Xe);
  }, F.Matrix = Ae;
  var be = F.matrixMult = function(T, X) {
    return X.multiply(T);
  }, Ve = new Ae(1, 0, 0, 1, 0, 0);
  F.unitMatrix = F.identityMatrix = Ve;
  var et = function(T, X) {
    if (!$r[T]) {
      var me = (X instanceof nc ? "Sh" : "P") + (Object.keys(Et).length + 1).toString(10);
      X.id = me, $r[T] = me, Et[me] = X, W.publish("addPattern", X);
    }
  };
  F.ShadingPattern = nc, F.TilingPattern = Dc, F.addShadingPattern = function(T, X) {
    return Ie("addShadingPattern()"), et(T, X), this;
  }, F.beginTilingPattern = function(T) {
    Ie("beginTilingPattern()"), Ua(T.boundingBox[0], T.boundingBox[1], T.boundingBox[2] - T.boundingBox[0], T.boundingBox[3] - T.boundingBox[1], T.matrix);
  }, F.endTilingPattern = function(T, X) {
    Ie("endTilingPattern()"), X.stream = bt[fe].join(`
`), et(T, X), W.publish("endTilingPattern", X), Ee.pop().restore();
  };
  var Re = F.__private__.newObject = function() {
    var T = mt();
    return Dt(T, !0), T;
  }, mt = F.__private__.newObjectDeferred = function() {
    return De++, Oe[De] = function() {
      return Ze;
    }, De;
  }, Dt = function(T, X) {
    return X = typeof X == "boolean" && X, Oe[T] = Ze, X && Y(T + " 0 obj"), T;
  }, Zt = F.__private__.newAdditionalObject = function() {
    var T = { objId: mt(), content: "" };
    return wt.push(T), T;
  }, vi = mt(), Jt = mt(), gi = F.__private__.decodeColorString = function(T) {
    var X = T.split(" ");
    if (X.length !== 2 || X[1] !== "g" && X[1] !== "G")
      X.length === 5 && (X[4] === "k" || X[4] === "K") && (X = [(1 - X[0]) * (1 - X[3]), (1 - X[1]) * (1 - X[3]), (1 - X[2]) * (1 - X[3]), "r"]);
    else {
      var me = parseFloat(X[0]);
      X = [me, me, me, "r"];
    }
    for (var ke = "#", Fe = 0; Fe < 3; Fe++) ke += ("0" + Math.floor(255 * parseFloat(X[Fe])).toString(16)).slice(-2);
    return ke;
  }, pi = F.__private__.encodeColorString = function(T) {
    var X;
    typeof T == "string" && (T = { ch1: T });
    var me = T.ch1, ke = T.ch2, Fe = T.ch3, Xe = T.ch4, xt = T.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof me == "string" && me.charAt(0) !== "#") {
      var Rt = new Tf(me);
      if (Rt.ok) me = Rt.toHex();
      else if (!/^\d*\.?\d*$/.test(me)) throw new Error('Invalid color "' + me + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof me == "string" && /^#[0-9A-Fa-f]{3}$/.test(me) && (me = "#" + me[1] + me[1] + me[2] + me[2] + me[3] + me[3]), typeof me == "string" && /^#[0-9A-Fa-f]{6}$/.test(me)) {
      var ti = parseInt(me.substr(1), 16);
      me = ti >> 16 & 255, ke = ti >> 8 & 255, Fe = 255 & ti;
    }
    if (ke === void 0 || Xe === void 0 && me === ke && ke === Fe) if (typeof me == "string") X = me + " " + xt[0];
    else switch (T.precision) {
      case 2:
        X = it(me / 255) + " " + xt[0];
        break;
      case 3:
      default:
        X = oe(me / 255) + " " + xt[0];
    }
    else if (Xe === void 0 || rr(Xe) === "object") {
      if (Xe && !isNaN(Xe.a) && Xe.a === 0) return X = ["1.", "1.", "1.", xt[1]].join(" ");
      if (typeof me == "string") X = [me, ke, Fe, xt[1]].join(" ");
      else switch (T.precision) {
        case 2:
          X = [it(me / 255), it(ke / 255), it(Fe / 255), xt[1]].join(" ");
          break;
        default:
        case 3:
          X = [oe(me / 255), oe(ke / 255), oe(Fe / 255), xt[1]].join(" ");
      }
    } else if (typeof me == "string") X = [me, ke, Fe, Xe, xt[2]].join(" ");
    else switch (T.precision) {
      case 2:
        X = [it(me), it(ke), it(Fe), it(Xe), xt[2]].join(" ");
        break;
      case 3:
      default:
        X = [oe(me), oe(ke), oe(Fe), oe(Xe), xt[2]].join(" ");
    }
    return X;
  }, Ui = F.__private__.getFilters = function() {
    return _;
  }, Fi = F.__private__.putStream = function(T) {
    var X = (T = T || {}).data || "", me = T.filters || Ui(), ke = T.alreadyAppliedFilters || [], Fe = T.addLength1 || !1, Xe = X.length, xt = T.objectId, Rt = function(Wr) {
      return Wr;
    };
    if (q !== null && xt === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    q !== null && (Rt = gr.encryptor(xt, 0));
    var ti = {};
    me === !0 && (me = ["FlateEncode"]);
    var mi = T.additionalKeyValues || [], wi = (ti = yi.API.processDataByFilters !== void 0 ? yi.API.processDataByFilters(X, me) : { data: X, reverseChain: [] }).reverseChain + (Array.isArray(ke) ? ke.join(" ") : ke.toString());
    if (ti.data.length !== 0 && (mi.push({ key: "Length", value: ti.data.length }), Fe === !0 && mi.push({ key: "Length1", value: Xe })), wi.length != 0) if (wi.split("/").length - 1 == 1) mi.push({ key: "Filter", value: wi });
    else {
      mi.push({ key: "Filter", value: "[" + wi + "]" });
      for (var Ii = 0; Ii < mi.length; Ii += 1) if (mi[Ii].key === "DecodeParms") {
        for (var Ki = [], vr = 0; vr < ti.reverseChain.split("/").length - 1; vr += 1) Ki.push("null");
        Ki.push(mi[Ii].value), mi[Ii].value = "[" + Ki.join(" ") + "]";
      }
    }
    Y("<<");
    for (var Si = 0; Si < mi.length; Si++) Y("/" + mi[Si].key + " " + mi[Si].value);
    Y(">>"), ti.data.length !== 0 && (Y("stream"), Y(Rt(ti.data)), Y("endstream"));
  }, li = F.__private__.putPage = function(T) {
    var X = T.number, me = T.data, ke = T.objId, Fe = T.contentsObjId;
    Dt(ke, !0), Y("<</Type /Page"), Y("/Parent " + T.rootDictionaryObjId + " 0 R"), Y("/Resources " + T.resourceDictionaryObjId + " 0 R"), Y("/MediaBox [" + parseFloat(Be(T.mediaBox.bottomLeftX)) + " " + parseFloat(Be(T.mediaBox.bottomLeftY)) + " " + Be(T.mediaBox.topRightX) + " " + Be(T.mediaBox.topRightY) + "]"), T.cropBox !== null && Y("/CropBox [" + Be(T.cropBox.bottomLeftX) + " " + Be(T.cropBox.bottomLeftY) + " " + Be(T.cropBox.topRightX) + " " + Be(T.cropBox.topRightY) + "]"), T.bleedBox !== null && Y("/BleedBox [" + Be(T.bleedBox.bottomLeftX) + " " + Be(T.bleedBox.bottomLeftY) + " " + Be(T.bleedBox.topRightX) + " " + Be(T.bleedBox.topRightY) + "]"), T.trimBox !== null && Y("/TrimBox [" + Be(T.trimBox.bottomLeftX) + " " + Be(T.trimBox.bottomLeftY) + " " + Be(T.trimBox.topRightX) + " " + Be(T.trimBox.topRightY) + "]"), T.artBox !== null && Y("/ArtBox [" + Be(T.artBox.bottomLeftX) + " " + Be(T.artBox.bottomLeftY) + " " + Be(T.artBox.topRightX) + " " + Be(T.artBox.topRightY) + "]"), typeof T.userUnit == "number" && T.userUnit !== 1 && Y("/UserUnit " + T.userUnit), W.publish("putPage", { objId: ke, pageContext: $[X], pageNumber: X, page: me }), Y("/Contents " + Fe + " 0 R"), Y(">>"), Y("endobj");
    var Xe = me.join(`
`);
    return Me === ge.ADVANCED && (Xe += `
Q`), Dt(Fe, !0), Fi({ data: Xe, filters: Ui(), objectId: Fe }), Y("endobj"), ke;
  }, Di = F.__private__.putPages = function() {
    var T, X, me = [];
    for (T = 1; T <= ue; T++) $[T].objId = mt(), $[T].contentsObjId = mt();
    for (T = 1; T <= ue; T++) me.push(li({ number: T, data: bt[T], objId: $[T].objId, contentsObjId: $[T].contentsObjId, mediaBox: $[T].mediaBox, cropBox: $[T].cropBox, bleedBox: $[T].bleedBox, trimBox: $[T].trimBox, artBox: $[T].artBox, userUnit: $[T].userUnit, rootDictionaryObjId: vi, resourceDictionaryObjId: Jt }));
    Dt(vi, !0), Y("<</Type /Pages");
    var ke = "/Kids [";
    for (X = 0; X < ue; X++) ke += me[X] + " 0 R ";
    Y(ke + "]"), Y("/Count " + ue), Y(">>"), Y("endobj"), W.publish("postPutPages");
  }, Vi = function(T) {
    W.publish("putFont", { font: T, out: Y, newObject: Re, putStream: Fi }), T.isAlreadyPutted !== !0 && (T.objectNumber = Re(), Y("<<"), Y("/Type /Font"), Y("/BaseFont /" + Mc(T.postScriptName)), Y("/Subtype /Type1"), typeof T.encoding == "string" && Y("/Encoding /" + T.encoding), Y("/FirstChar 32"), Y("/LastChar 255"), Y(">>"), Y("endobj"));
  }, hr = function() {
    for (var T in kt) kt.hasOwnProperty(T) && (j === !1 || j === !0 && V.hasOwnProperty(T)) && Vi(kt[T]);
  }, fr = function(T) {
    T.objectNumber = Re();
    var X = [];
    X.push({ key: "Type", value: "/XObject" }), X.push({ key: "Subtype", value: "/Form" }), X.push({ key: "BBox", value: "[" + [Be(T.x), Be(T.y), Be(T.x + T.width), Be(T.y + T.height)].join(" ") + "]" }), X.push({ key: "Matrix", value: "[" + T.matrix.toString() + "]" });
    var me = T.pages[1].join(`
`);
    Fi({ data: me, additionalKeyValues: X, objectId: T.objectNumber }), Y("endobj");
  }, Ir = function() {
    for (var T in ce) ce.hasOwnProperty(T) && fr(ce[T]);
  }, Ns = function(T, X) {
    var me, ke = [], Fe = 1 / (X - 1);
    for (me = 0; me < 1; me += Fe) ke.push(me);
    if (ke.push(1), T[0].offset != 0) {
      var Xe = { offset: 0, color: T[0].color };
      T.unshift(Xe);
    }
    if (T[T.length - 1].offset != 1) {
      var xt = { offset: 1, color: T[T.length - 1].color };
      T.push(xt);
    }
    for (var Rt = "", ti = 0, mi = 0; mi < ke.length; mi++) {
      for (me = ke[mi]; me > T[ti + 1].offset; ) ti++;
      var wi = T[ti].offset, Ii = (me - wi) / (T[ti + 1].offset - wi), Ki = T[ti].color, vr = T[ti + 1].color;
      Rt += Ce(Math.round((1 - Ii) * Ki[0] + Ii * vr[0]).toString(16)) + Ce(Math.round((1 - Ii) * Ki[1] + Ii * vr[1]).toString(16)) + Ce(Math.round((1 - Ii) * Ki[2] + Ii * vr[2]).toString(16));
    }
    return Rt.trim();
  }, Ri = function(T, X) {
    X || (X = 21);
    var me = Re(), ke = Ns(T.colors, X), Fe = [];
    Fe.push({ key: "FunctionType", value: "0" }), Fe.push({ key: "Domain", value: "[0.0 1.0]" }), Fe.push({ key: "Size", value: "[" + X + "]" }), Fe.push({ key: "BitsPerSample", value: "8" }), Fe.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Fe.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Fi({ data: ke, additionalKeyValues: Fe, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: me }), Y("endobj"), T.objectNumber = Re(), Y("<< /ShadingType " + T.type), Y("/ColorSpace /DeviceRGB");
    var Xe = "/Coords [" + Be(parseFloat(T.coords[0])) + " " + Be(parseFloat(T.coords[1])) + " ";
    T.type === 2 ? Xe += Be(parseFloat(T.coords[2])) + " " + Be(parseFloat(T.coords[3])) : Xe += Be(parseFloat(T.coords[2])) + " " + Be(parseFloat(T.coords[3])) + " " + Be(parseFloat(T.coords[4])) + " " + Be(parseFloat(T.coords[5])), Y(Xe += "]"), T.matrix && Y("/Matrix [" + T.matrix.toString() + "]"), Y("/Function " + me + " 0 R"), Y("/Extend [true true]"), Y(">>"), Y("endobj");
  }, Na = function(T, X) {
    var me = mt(), ke = Re();
    X.push({ resourcesOid: me, objectOid: ke }), T.objectNumber = ke;
    var Fe = [];
    Fe.push({ key: "Type", value: "/Pattern" }), Fe.push({ key: "PatternType", value: "1" }), Fe.push({ key: "PaintType", value: "1" }), Fe.push({ key: "TilingType", value: "1" }), Fe.push({ key: "BBox", value: "[" + T.boundingBox.map(Be).join(" ") + "]" }), Fe.push({ key: "XStep", value: Be(T.xStep) }), Fe.push({ key: "YStep", value: Be(T.yStep) }), Fe.push({ key: "Resources", value: me + " 0 R" }), T.matrix && Fe.push({ key: "Matrix", value: "[" + T.matrix.toString() + "]" }), Fi({ data: T.stream, additionalKeyValues: Fe, objectId: T.objectNumber }), Y("endobj");
  }, eo = function(T) {
    var X;
    for (X in Et) Et.hasOwnProperty(X) && (Et[X] instanceof nc ? Ri(Et[X]) : Et[X] instanceof Dc && Na(Et[X], T));
  }, Zr = function(T) {
    for (var X in T.objectNumber = Re(), Y("<<"), T) switch (X) {
      case "opacity":
        Y("/ca " + it(T[X]));
        break;
      case "stroke-opacity":
        Y("/CA " + it(T[X]));
    }
    Y(">>"), Y("endobj");
  }, nn = function() {
    var T;
    for (T in qi) qi.hasOwnProperty(T) && Zr(qi[T]);
  }, Fa = function() {
    for (var T in Y("/XObject <<"), ce) ce.hasOwnProperty(T) && ce[T].objectNumber >= 0 && Y("/" + T + " " + ce[T].objectNumber + " 0 R");
    W.publish("putXobjectDict"), Y(">>");
  }, pn = function() {
    gr.oid = Re(), Y("<<"), Y("/Filter /Standard"), Y("/V " + gr.v), Y("/R " + gr.r), Y("/U <" + gr.toHexString(gr.U) + ">"), Y("/O <" + gr.toHexString(gr.O) + ">"), Y("/P " + gr.P), Y(">>"), Y("endobj");
  }, Gr = function() {
    for (var T in Y("/Font <<"), kt) kt.hasOwnProperty(T) && (j === !1 || j === !0 && V.hasOwnProperty(T)) && Y("/" + T + " " + kt[T].objectNumber + " 0 R");
    Y(">>");
  }, to = function() {
    if (Object.keys(Et).length > 0) {
      for (var T in Y("/Shading <<"), Et) Et.hasOwnProperty(T) && Et[T] instanceof nc && Et[T].objectNumber >= 0 && Y("/" + T + " " + Et[T].objectNumber + " 0 R");
      W.publish("putShadingPatternDict"), Y(">>");
    }
  }, Dn = function(T) {
    if (Object.keys(Et).length > 0) {
      for (var X in Y("/Pattern <<"), Et) Et.hasOwnProperty(X) && Et[X] instanceof F.TilingPattern && Et[X].objectNumber >= 0 && Et[X].objectNumber < T && Y("/" + X + " " + Et[X].objectNumber + " 0 R");
      W.publish("putTilingPatternDict"), Y(">>");
    }
  }, mr = function() {
    if (Object.keys(qi).length > 0) {
      var T;
      for (T in Y("/ExtGState <<"), qi) qi.hasOwnProperty(T) && qi[T].objectNumber >= 0 && Y("/" + T + " " + qi[T].objectNumber + " 0 R");
      W.publish("putGStateDict"), Y(">>");
    }
  }, Ji = function(T) {
    Dt(T.resourcesOid, !0), Y("<<"), Y("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Gr(), to(), Dn(T.objectOid), mr(), Fa(), Y(">>"), Y("endobj");
  }, fn = function() {
    var T = [];
    hr(), nn(), Ir(), eo(T), W.publish("putResources"), T.forEach(Ji), Ji({ resourcesOid: Jt, objectOid: Number.MAX_SAFE_INTEGER }), W.publish("postPutResources");
  }, nr = function() {
    W.publish("putAdditionalObjects");
    for (var T = 0; T < wt.length; T++) {
      var X = wt[T];
      Dt(X.objId, !0), Y(X.content), Y("endobj");
    }
    W.publish("postPutAdditionalObjects");
  }, So = function(T) {
    Ei[T.fontName] = Ei[T.fontName] || {}, Ei[T.fontName][T.fontStyle] = T.id;
  }, sn = function(T, X, me, ke, Fe) {
    var Xe = { id: "F" + (Object.keys(kt).length + 1).toString(10), postScriptName: T, fontName: X, fontStyle: me, encoding: ke, isStandardFont: Fe || !1, metadata: {} };
    return W.publish("addFont", { font: Xe, instance: this }), kt[Xe.id] = Xe, So(Xe), Xe.id;
  }, Ra = function(T) {
    for (var X = 0, me = at.length; X < me; X++) {
      var ke = sn.call(this, T[X][0], T[X][1], T[X][2], at[X][3], !0);
      j === !1 && (V[ke] = !0);
      var Fe = T[X][0].split("-");
      So({ id: ke, fontName: Fe[0], fontStyle: Fe[1] || "" });
    }
    W.publish("addFonts", { fonts: kt, dictionary: Ei });
  }, _r = function(T) {
    return T.foo = function() {
      try {
        return T.apply(this, arguments);
      } catch (ke) {
        var X = ke.stack || "";
        ~X.indexOf(" at ") && (X = X.split(" at ")[1]);
        var me = "Error in function " + X.split(`
`)[0].split("<")[0] + ": " + ke.message;
        if (!_i.console) throw new Error(me);
        _i.console.error(me, ke), _i.alert && alert(me);
      }
    }, T.foo.bar = T, T.foo;
  }, Wo = function(T, X) {
    var me, ke, Fe, Xe, xt, Rt, ti, mi, wi;
    if (Fe = (X = X || {}).sourceEncoding || "Unicode", xt = X.outputEncoding, (X.autoencode || xt) && kt[ai].metadata && kt[ai].metadata[Fe] && kt[ai].metadata[Fe].encoding && (Xe = kt[ai].metadata[Fe].encoding, !xt && kt[ai].encoding && (xt = kt[ai].encoding), !xt && Xe.codePages && (xt = Xe.codePages[0]), typeof xt == "string" && (xt = Xe[xt]), xt)) {
      for (ti = !1, Rt = [], me = 0, ke = T.length; me < ke; me++) (mi = xt[T.charCodeAt(me)]) ? Rt.push(String.fromCharCode(mi)) : Rt.push(T[me]), Rt[me].charCodeAt(0) >> 8 && (ti = !0);
      T = Rt.join("");
    }
    for (me = T.length; ti === void 0 && me !== 0; ) T.charCodeAt(me - 1) >> 8 && (ti = !0), me--;
    if (!ti) return T;
    for (Rt = X.noBOM ? [] : [254, 255], me = 0, ke = T.length; me < ke; me++) {
      if ((wi = (mi = T.charCodeAt(me)) >> 8) >> 8) throw new Error("Character at position " + me + " of string '" + T + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Rt.push(wi), Rt.push(mi - (wi << 8));
    }
    return String.fromCharCode.apply(void 0, Rt);
  }, Fr = F.__private__.pdfEscape = F.pdfEscape = function(T, X) {
    return Wo(T, X).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, ts = F.__private__.beginPage = function(T) {
    bt[++ue] = [], $[ue] = { objId: 0, contentsObjId: 0, userUnit: Number(c), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(T[0]), topRightY: Number(T[1]) } }, Ho(ue), Qe(bt[fe]);
  }, is = function(T, X) {
    var me, ke, Fe;
    switch (p = X || p, typeof T == "string" && (me = se(T.toLowerCase()), Array.isArray(me) && (ke = me[0], Fe = me[1])), Array.isArray(T) && (ke = T[0] * It, Fe = T[1] * It), isNaN(ke) && (ke = S[0], Fe = S[1]), (ke > 14400 || Fe > 14400) && (pr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), ke = Math.min(14400, ke), Fe = Math.min(14400, Fe)), S = [ke, Fe], p.substr(0, 1)) {
      case "l":
        Fe > ke && (S = [Fe, ke]);
        break;
      case "p":
        ke > Fe && (S = [Fe, ke]);
    }
    ts(S), dl(Lo), Y(os), sa !== 0 && Y(sa + " J"), oa !== 0 && Y(oa + " j"), W.publish("addPage", { pageNumber: ue });
  }, Ni = function(T) {
    T > 0 && T <= ue && (bt.splice(T, 1), $.splice(T, 1), ue--, fe > ue && (fe = ue), this.setPage(fe));
  }, Ho = function(T) {
    T > 0 && T <= ue && (fe = T);
  }, Ba = F.__private__.getNumberOfPages = F.getNumberOfPages = function() {
    return bt.length - 1;
  }, Fs = function(T, X, me) {
    var ke, Fe = void 0;
    return me = me || {}, T = T !== void 0 ? T : kt[ai].fontName, X = X !== void 0 ? X : kt[ai].fontStyle, ke = T.toLowerCase(), Ei[ke] !== void 0 && Ei[ke][X] !== void 0 ? Fe = Ei[ke][X] : Ei[T] !== void 0 && Ei[T][X] !== void 0 ? Fe = Ei[T][X] : me.disableWarning === !1 && pr.warn("Unable to look up font label for font '" + T + "', '" + X + "'. Refer to getFontList() for available fonts."), Fe || me.noFallback || (Fe = Ei.times[X]) == null && (Fe = Ei.times.normal), Fe;
  }, Oa = F.__private__.putInfo = function() {
    var T = Re(), X = function(ke) {
      return ke;
    };
    for (var me in q !== null && (X = gr.encryptor(T, 0)), Y("<<"), Y("/Producer (" + Fr(X("jsPDF " + yi.version)) + ")"), ei) ei.hasOwnProperty(me) && ei[me] && Y("/" + me.substr(0, 1).toUpperCase() + me.substr(1) + " (" + Fr(X(ei[me])) + ")");
    Y("/CreationDate (" + Fr(X(He)) + ")"), Y(">>"), Y("endobj");
  }, io = F.__private__.putCatalog = function(T) {
    var X = (T = T || {}).rootDictionaryObjId || vi;
    switch (Re(), Y("<<"), Y("/Type /Catalog"), Y("/Pages " + X + " 0 R"), zt || (zt = "fullwidth"), zt) {
      case "fullwidth":
        Y("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Y("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Y("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Y("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var me = "" + zt;
        me.substr(me.length - 1) === "%" && (zt = parseInt(zt) / 100), typeof zt == "number" && Y("/OpenAction [3 0 R /XYZ null null " + it(zt) + "]");
    }
    switch (bi || (bi = "continuous"), bi) {
      case "continuous":
        Y("/PageLayout /OneColumn");
        break;
      case "single":
        Y("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Y("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Y("/PageLayout /TwoColumnRight");
    }
    di && Y("/PageMode /" + di), W.publish("putCatalog"), Y(">>"), Y("endobj");
  }, Ao = F.__private__.putTrailer = function() {
    Y("trailer"), Y("<<"), Y("/Size " + (De + 1)), Y("/Root " + De + " 0 R"), Y("/Info " + (De - 1) + " 0 R"), q !== null && Y("/Encrypt " + gr.oid + " 0 R"), Y("/ID [ <" + We + "> <" + We + "> ]"), Y(">>");
  }, Xo = F.__private__.putHeader = function() {
    Y("%PDF-" + de), Y("%ºß¬à");
  }, ro = F.__private__.putXRef = function() {
    var T = "0000000000";
    Y("xref"), Y("0 " + (De + 1)), Y("0000000000 65535 f ");
    for (var X = 1; X <= De; X++)
      typeof Oe[X] == "function" ? Y((T + Oe[X]()).slice(-10) + " 00000 n ") : Oe[X] !== void 0 ? Y((T + Oe[X]).slice(-10) + " 00000 n ") : Y("0000000000 00000 n ");
  }, ys = F.__private__.buildDocument = function() {
    Qt(), Qe(qe), W.publish("buildDocument"), Xo(), Di(), nr(), fn(), q !== null && pn(), Oa(), io();
    var T = Ze;
    return ro(), Ao(), Y("startxref"), Y("" + T), Y("%%EOF"), Qe(bt[fe]), qe.join(`
`);
  }, Yo = F.__private__.getBlob = function(T) {
    return new Blob([$t(T)], { type: "application/pdf" });
  }, Po = F.output = F.__private__.output = _r(function(T, X) {
    switch (typeof (X = X || {}) == "string" ? X = { filename: X } : X.filename = X.filename || "generated.pdf", T) {
      case void 0:
        return ys();
      case "save":
        F.save(X.filename);
        break;
      case "arraybuffer":
        return $t(ys());
      case "blob":
        return Yo(ys());
      case "bloburi":
      case "bloburl":
        if (_i.URL !== void 0 && typeof _i.URL.createObjectURL == "function") return _i.URL && _i.URL.createObjectURL(Yo(ys())) || void 0;
        pr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var me = "", ke = ys();
        try {
          me = ld(ke);
        } catch {
          me = ld(unescape(encodeURIComponent(ke)));
        }
        return "data:application/pdf;filename=" + X.filename + ";base64," + me;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(_i) === "[object Window]") {
          var Fe = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Xe = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          X.pdfObjectUrl && (Fe = X.pdfObjectUrl, Xe = "");
          var xt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Fe + '"' + Xe + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(X) + ");<\/script></body></html>", Rt = _i.open();
          return Rt !== null && Rt.document.write(xt), Rt;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(_i) === "[object Window]") {
          var ti = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (X.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + X.filename + '" width="500px" height="400px" /></body></html>', mi = _i.open();
          if (mi !== null) {
            mi.document.write(ti);
            var wi = this;
            mi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              mi.document.title = X.filename, mi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(wi.output("bloburl"));
            };
          }
          return mi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(_i) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Ii = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", X) + '"></iframe></body></html>', Ki = _i.open();
        if (Ki !== null && (Ki.document.write(Ii), Ki.document.title = X.filename), Ki || typeof safari > "u") return Ki;
        break;
      case "datauri":
      case "dataurl":
        return _i.document.location.href = this.output("datauristring", X);
      default:
        return null;
    }
  }), hl = function(T) {
    return Array.isArray(te) === !0 && te.indexOf(T) > -1;
  };
  switch (v) {
    case "pt":
      It = 1;
      break;
    case "mm":
      It = 72 / 25.4;
      break;
    case "cm":
      It = 72 / 2.54;
      break;
    case "in":
      It = 72;
      break;
    case "px":
      It = hl("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      It = 12;
      break;
    case "ex":
      It = 6;
      break;
    default:
      if (typeof v != "number") throw new Error("Invalid unit: " + v);
      It = v;
  }
  var gr = null;
  St(), je();
  var Io = function(T) {
    return q !== null ? gr.encryptor(T, 0) : function(X) {
      return X;
    };
  }, Rr = F.__private__.getPageInfo = F.getPageInfo = function(T) {
    if (isNaN(T) || T % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: $[T].objId, pageNumber: T, pageContext: $[T] };
  }, Xt = F.__private__.getPageInfoByObjId = function(T) {
    if (isNaN(T) || T % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var X in $) if ($[X].objId === T) break;
    return Rr(X);
  }, Jo = F.__private__.getCurrentPageInfo = F.getCurrentPageInfo = function() {
    return { objId: $[fe].objId, pageNumber: fe, pageContext: $[fe] };
  };
  F.addPage = function() {
    return is.apply(this, arguments), this;
  }, F.setPage = function() {
    return Ho.apply(this, arguments), Qe.call(this, bt[fe]), this;
  }, F.insertPage = function(T) {
    return this.addPage(), this.movePage(fe, T), this;
  }, F.movePage = function(T, X) {
    var me, ke;
    if (T > X) {
      me = bt[T], ke = $[T];
      for (var Fe = T; Fe > X; Fe--) bt[Fe] = bt[Fe - 1], $[Fe] = $[Fe - 1];
      bt[X] = me, $[X] = ke, this.setPage(X);
    } else if (T < X) {
      me = bt[T], ke = $[T];
      for (var Xe = T; Xe < X; Xe++) bt[Xe] = bt[Xe + 1], $[Xe] = $[Xe + 1];
      bt[X] = me, $[X] = ke, this.setPage(X);
    }
    return this;
  }, F.deletePage = function() {
    return Ni.apply(this, arguments), this;
  }, F.__private__.text = F.text = function(T, X, me, ke, Fe) {
    var Xe, xt, Rt, ti, mi, wi, Ii, Ki, vr, Si = (ke = ke || {}).scope || this;
    if (typeof T == "number" && typeof X == "number" && (typeof me == "string" || Array.isArray(me))) {
      var Wr = me;
      me = X, X = T, T = Wr;
    }
    if (arguments[3] instanceof Ae ? (Ie("The transform parameter of text() with a Matrix value"), vr = Fe) : (Rt = arguments[4], ti = arguments[5], rr(Ii = arguments[3]) === "object" && Ii !== null || (typeof Rt == "string" && (ti = Rt, Rt = null), typeof Ii == "string" && (ti = Ii, Ii = null), typeof Ii == "number" && (Rt = Ii, Ii = null), ke = { flags: Ii, angle: Rt, align: ti })), isNaN(X) || isNaN(me) || T == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (T.length === 0) return Si;
    var Yt = "", mn = !1, ki = typeof ke.lineHeightFactor == "number" ? ke.lineHeightFactor : Bs, Mi = Si.internal.scaleFactor;
    function bs(Xi) {
      return Xi = Xi.split("	").join(Array(ke.TabLen || 9).join(" ")), Fr(Xi, Ii);
    }
    function Os(Xi) {
      for (var Zi, sr = Xi.concat(), xr = [], Pn = sr.length; Pn--; ) typeof (Zi = sr.shift()) == "string" ? xr.push(Zi) : Array.isArray(Xi) && (Zi.length === 1 || Zi[1] === void 0 && Zi[2] === void 0) ? xr.push(Zi[0]) : xr.push([Zi[0], Zi[1], Zi[2]]);
      return xr;
    }
    function js(Xi, Zi) {
      var sr;
      if (typeof Xi == "string") sr = Zi(Xi)[0];
      else if (Array.isArray(Xi)) {
        for (var xr, Pn, qn = Xi.concat(), br = [], Ps = qn.length; Ps--; ) typeof (xr = qn.shift()) == "string" ? br.push(Zi(xr)[0]) : Array.isArray(xr) && typeof xr[0] == "string" && (Pn = Zi(xr[0], xr[1], xr[2]), br.push([Pn[0], Pn[1], Pn[2]]));
        sr = br;
      }
      return sr;
    }
    var oo = !1, as = !0;
    if (typeof T == "string") oo = !0;
    else if (Array.isArray(T)) {
      var ws = T.concat();
      xt = [];
      for (var Br, Hr = ws.length; Hr--; ) (typeof (Br = ws.shift()) != "string" || Array.isArray(Br) && typeof Br[0] != "string") && (as = !1);
      oo = as;
    }
    if (oo === !1) throw new Error('Type of text must be string or Array. "' + T + '" is not recognized.');
    typeof T == "string" && (T = T.match(/[\r?\n]/) ? T.split(/\r\n|\r|\n/g) : [T]);
    var ao = yt / Si.internal.scaleFactor, lo = ao * (ki - 1);
    switch (ke.baseline) {
      case "bottom":
        me -= lo;
        break;
      case "top":
        me += ao - lo;
        break;
      case "hanging":
        me += ao - 2 * lo;
        break;
      case "middle":
        me += ao / 2 - lo;
    }
    if ((wi = ke.maxWidth || 0) > 0 && (typeof T == "string" ? T = Si.splitTextToSize(T, wi) : Object.prototype.toString.call(T) === "[object Array]" && (T = T.reduce(function(Xi, Zi) {
      return Xi.concat(Si.splitTextToSize(Zi, wi));
    }, []))), Xe = { text: T, x: X, y: me, options: ke, mutex: { pdfEscape: Fr, activeFontKey: ai, fonts: kt, activeFontSize: yt } }, W.publish("preProcessText", Xe), T = Xe.text, Rt = (ke = Xe.options).angle, !(vr instanceof Ae) && Rt && typeof Rt == "number") {
      Rt *= Math.PI / 180, ke.rotationDirection === 0 && (Rt = -Rt), Me === ge.ADVANCED && (Rt = -Rt);
      var Fn = Math.cos(Rt), qs = Math.sin(Rt);
      vr = new Ae(Fn, qs, -qs, Fn, 0, 0);
    } else Rt && Rt instanceof Ae && (vr = Rt);
    Me !== ge.ADVANCED || vr || (vr = Ve), (mi = ke.charSpace || no) !== void 0 && (Yt += Be(le(mi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Ki = ke.horizontalScale) !== void 0 && (Yt += Be(100 * Ki) + ` Tz
`), ke.lang;
    var Mr = -1, co = ke.renderingMode !== void 0 ? ke.renderingMode : ke.stroke, Vs = Si.internal.getCurrentPageInfo().pageContext;
    switch (co) {
      case 0:
      case !1:
      case "fill":
        Mr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Mr = 1;
        break;
      case 2:
      case "fillThenStroke":
        Mr = 2;
        break;
      case 3:
      case "invisible":
        Mr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Mr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Mr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Mr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Mr = 7;
    }
    var Co = Vs.usedRenderingMode !== void 0 ? Vs.usedRenderingMode : -1;
    Mr !== -1 ? Yt += Mr + ` Tr
` : Co !== -1 && (Yt += `0 Tr
`), Mr !== -1 && (Vs.usedRenderingMode = Mr), ti = ke.align || "left";
    var Xr, Ss = yt * ki, ml = Si.internal.pageSize.getWidth(), Za = kt[ai];
    mi = ke.charSpace || no, wi = ke.maxWidth || 0, Ii = Object.assign({ autoencode: !0, noBOM: !0 }, ke.flags);
    var Ai = [];
    if (Object.prototype.toString.call(T) === "[object Array]") {
      var an;
      xt = Os(T), ti !== "left" && (Xr = xt.map(function(Xi) {
        return Si.getStringUnitWidth(Xi, { font: Za, charSpace: mi, fontSize: yt, doKerning: !1 }) * yt / Mi;
      }));
      var ls, Us = 0;
      if (ti === "right") {
        X -= Xr[0], T = [], Hr = xt.length;
        for (var ln = 0; ln < Hr; ln++) ln === 0 ? (ls = Pi(X), an = ss(me)) : (ls = le(Us - Xr[ln]), an = -Ss), T.push([xt[ln], ls, an]), Us = Xr[ln];
      } else if (ti === "center") {
        X -= Xr[0] / 2, T = [], Hr = xt.length;
        for (var As = 0; As < Hr; As++) As === 0 ? (ls = Pi(X), an = ss(me)) : (ls = le((Us - Xr[As]) / 2), an = -Ss), T.push([xt[As], ls, an]), Us = Xr[As];
      } else if (ti === "left") {
        T = [], Hr = xt.length;
        for (var $s = 0; $s < Hr; $s++) T.push(xt[$s]);
      } else {
        if (ti !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        T = [], Hr = xt.length, wi = wi !== 0 ? wi : ml;
        for (var Rn = 0; Rn < Hr; Rn++) an = Rn === 0 ? ss(me) : -Ss, ls = Rn === 0 ? Pi(X) : 0, Rn < Hr - 1 ? Ai.push(Be(le((wi - Xr[Rn]) / (xt[Rn].split(" ").length - 1)))) : Ai.push(0), T.push([xt[Rn], ls, an]);
      }
    }
    var Eo = typeof ke.R2L == "boolean" ? ke.R2L : Gt;
    Eo === !0 && (T = js(T, function(Xi, Zi, sr) {
      return [Xi.split("").reverse().join(""), Zi, sr];
    })), Xe = { text: T, x: X, y: me, options: ke, mutex: { pdfEscape: Fr, activeFontKey: ai, fonts: kt, activeFontSize: yt } }, W.publish("postProcessText", Xe), T = Xe.text, mn = Xe.mutex.isHex || !1;
    var ho = kt[ai].encoding;
    ho !== "WinAnsiEncoding" && ho !== "StandardEncoding" || (T = js(T, function(Xi, Zi, sr) {
      return [bs(Xi), Zi, sr];
    })), xt = Os(T), T = [];
    for (var cs, Yr, gn, Bn = 0, uo = 1, On = Array.isArray(xt[0]) ? uo : Bn, jn = "", po = function(Xi, Zi, sr) {
      var xr = "";
      return sr instanceof Ae ? (sr = typeof ke.angle == "number" ? be(sr, new Ae(1, 0, 0, 1, Xi, Zi)) : be(new Ae(1, 0, 0, 1, Xi, Zi), sr), Me === ge.ADVANCED && (sr = be(new Ae(1, 0, 0, -1, 0, 0), sr)), xr = sr.join(" ") + ` Tm
`) : xr = Be(Xi) + " " + Be(Zi) + ` Td
`, xr;
    }, cn = 0; cn < xt.length; cn++) {
      switch (jn = "", On) {
        case uo:
          gn = (mn ? "<" : "(") + xt[cn][0] + (mn ? ">" : ")"), cs = parseFloat(xt[cn][1]), Yr = parseFloat(xt[cn][2]);
          break;
        case Bn:
          gn = (mn ? "<" : "(") + xt[cn] + (mn ? ">" : ")"), cs = Pi(X), Yr = ss(me);
      }
      Ai !== void 0 && Ai[cn] !== void 0 && (jn = Ai[cn] + ` Tw
`), cn === 0 ? T.push(jn + po(cs, Yr, vr) + gn) : On === Bn ? T.push(jn + gn) : On === uo && T.push(jn + po(cs, Yr, vr) + gn);
    }
    T = On === Bn ? T.join(` Tj
T* `) : T.join(` Tj
`), T += ` Tj
`;
    var hs = `BT
/`;
    return hs += ai + " " + yt + ` Tf
`, hs += Be(yt * ki) + ` TL
`, hs += To + `
`, hs += Yt, hs += T, Y(hs += "ET"), V[ai] = !0, Si;
  };
  var Ko = F.__private__.clip = F.clip = function(T) {
    return Y(T === "evenodd" ? "W*" : "W"), this;
  };
  F.clipEvenOdd = function() {
    return Ko("evenodd");
  }, F.__private__.discardPath = F.discardPath = function() {
    return Y("n"), this;
  };
  var Sn = F.__private__.isValidStyle = function(T) {
    var X = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(T) !== -1 && (X = !0), X;
  };
  F.__private__.setDefaultPathOperation = F.setDefaultPathOperation = function(T) {
    return Sn(T) && (N = T), this;
  };
  var ja = F.__private__.getStyle = F.getStyle = function(T) {
    var X = N;
    switch (T) {
      case "D":
      case "S":
        X = "S";
        break;
      case "F":
        X = "f";
        break;
      case "FD":
      case "DF":
        X = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        X = T;
    }
    return X;
  }, Rs = F.close = function() {
    return Y("h"), this;
  };
  F.stroke = function() {
    return Y("S"), this;
  }, F.fill = function(T) {
    return Qo("f", T), this;
  }, F.fillEvenOdd = function(T) {
    return Qo("f*", T), this;
  }, F.fillStroke = function(T) {
    return Qo("B", T), this;
  }, F.fillStrokeEvenOdd = function(T) {
    return Qo("B*", T), this;
  };
  var Qo = function(T, X) {
    rr(X) === "object" ? Nl(X, T) : Y(T);
  }, ea = function(T) {
    T === null || Me === ge.ADVANCED && T === void 0 || (T = ja(T), Y(T));
  };
  function ul(T, X, me, ke, Fe) {
    var Xe = new Dc(X || this.boundingBox, me || this.xStep, ke || this.yStep, this.gState, Fe || this.matrix);
    Xe.stream = this.stream;
    var xt = T + "$$" + this.cloneIndex++ + "$$";
    return et(xt, Xe), Xe;
  }
  var Nl = function(T, X) {
    var me = $r[T.key], ke = Et[me];
    if (ke instanceof nc) Y("q"), Y(Fl(X)), ke.gState && F.setGState(ke.gState), Y(T.matrix.toString() + " cm"), Y("/" + me + " sh"), Y("Q");
    else if (ke instanceof Dc) {
      var Fe = new Ae(1, 0, 0, -1, 0, so());
      T.matrix && (Fe = Fe.multiply(T.matrix || Ve), me = ul.call(ke, T.key, T.boundingBox, T.xStep, T.yStep, Fe).id), Y("q"), Y("/Pattern cs"), Y("/" + me + " scn"), ke.gState && F.setGState(ke.gState), Y(X), Y("Q");
    }
  }, Fl = function(T) {
    switch (T) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, ta = F.moveTo = function(T, X) {
    return Y(Be(le(T)) + " " + Be(Se(X)) + " m"), this;
  }, rs = F.lineTo = function(T, X) {
    return Y(Be(le(T)) + " " + Be(Se(X)) + " l"), this;
  }, _s = F.curveTo = function(T, X, me, ke, Fe, Xe) {
    return Y([Be(le(T)), Be(Se(X)), Be(le(me)), Be(Se(ke)), Be(le(Fe)), Be(Se(Xe)), "c"].join(" ")), this;
  };
  F.__private__.line = F.line = function(T, X, me, ke, Fe) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || isNaN(ke) || !Sn(Fe)) throw new Error("Invalid arguments passed to jsPDF.line");
    return Me === ge.COMPAT ? this.lines([[me - T, ke - X]], T, X, [1, 1], Fe || "S") : this.lines([[me - T, ke - X]], T, X, [1, 1]).stroke();
  }, F.__private__.lines = F.lines = function(T, X, me, ke, Fe, Xe) {
    var xt, Rt, ti, mi, wi, Ii, Ki, vr, Si, Wr, Yt, mn;
    if (typeof T == "number" && (mn = me, me = X, X = T, T = mn), ke = ke || [1, 1], Xe = Xe || !1, isNaN(X) || isNaN(me) || !Array.isArray(T) || !Array.isArray(ke) || !Sn(Fe) || typeof Xe != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (ta(X, me), xt = ke[0], Rt = ke[1], mi = T.length, Wr = X, Yt = me, ti = 0; ti < mi; ti++) (wi = T[ti]).length === 2 ? (Wr = wi[0] * xt + Wr, Yt = wi[1] * Rt + Yt, rs(Wr, Yt)) : (Ii = wi[0] * xt + Wr, Ki = wi[1] * Rt + Yt, vr = wi[2] * xt + Wr, Si = wi[3] * Rt + Yt, Wr = wi[4] * xt + Wr, Yt = wi[5] * Rt + Yt, _s(Ii, Ki, vr, Si, Wr, Yt));
    return Xe && Rs(), ea(Fe), this;
  }, F.path = function(T) {
    for (var X = 0; X < T.length; X++) {
      var me = T[X], ke = me.c;
      switch (me.op) {
        case "m":
          ta(ke[0], ke[1]);
          break;
        case "l":
          rs(ke[0], ke[1]);
          break;
        case "c":
          _s.apply(this, ke);
          break;
        case "h":
          Rs();
      }
    }
    return this;
  }, F.__private__.rect = F.rect = function(T, X, me, ke, Fe) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || isNaN(ke) || !Sn(Fe)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return Me === ge.COMPAT && (ke = -ke), Y([Be(le(T)), Be(Se(X)), Be(le(me)), Be(le(ke)), "re"].join(" ")), ea(Fe), this;
  }, F.__private__.triangle = F.triangle = function(T, X, me, ke, Fe, Xe, xt) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || isNaN(ke) || isNaN(Fe) || isNaN(Xe) || !Sn(xt)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[me - T, ke - X], [Fe - me, Xe - ke], [T - Fe, X - Xe]], T, X, [1, 1], xt, !0), this;
  }, F.__private__.roundedRect = F.roundedRect = function(T, X, me, ke, Fe, Xe, xt) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || isNaN(ke) || isNaN(Fe) || isNaN(Xe) || !Sn(xt)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Rt = 4 / 3 * (Math.SQRT2 - 1);
    return Fe = Math.min(Fe, 0.5 * me), Xe = Math.min(Xe, 0.5 * ke), this.lines([[me - 2 * Fe, 0], [Fe * Rt, 0, Fe, Xe - Xe * Rt, Fe, Xe], [0, ke - 2 * Xe], [0, Xe * Rt, -Fe * Rt, Xe, -Fe, Xe], [2 * Fe - me, 0], [-Fe * Rt, 0, -Fe, -Xe * Rt, -Fe, -Xe], [0, 2 * Xe - ke], [0, -Xe * Rt, Fe * Rt, -Xe, Fe, -Xe]], T + Fe, X, [1, 1], xt, !0), this;
  }, F.__private__.ellipse = F.ellipse = function(T, X, me, ke, Fe) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || isNaN(ke) || !Sn(Fe)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Xe = 4 / 3 * (Math.SQRT2 - 1) * me, xt = 4 / 3 * (Math.SQRT2 - 1) * ke;
    return ta(T + me, X), _s(T + me, X - xt, T + Xe, X - ke, T, X - ke), _s(T - Xe, X - ke, T - me, X - xt, T - me, X), _s(T - me, X + xt, T - Xe, X + ke, T, X + ke), _s(T + Xe, X + ke, T + me, X + xt, T + me, X), ea(Fe), this;
  }, F.__private__.circle = F.circle = function(T, X, me, ke) {
    if (isNaN(T) || isNaN(X) || isNaN(me) || !Sn(ke)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(T, X, me, me, ke);
  }, F.setFont = function(T, X, me) {
    return me && (X = tt(X, me)), ai = Fs(T, X, { disableWarning: !1 }), this;
  };
  var ia = F.__private__.getFont = F.getFont = function() {
    return kt[Fs.apply(F, arguments)];
  };
  F.__private__.getFontList = F.getFontList = function() {
    var T, X, me = {};
    for (T in Ei) if (Ei.hasOwnProperty(T)) for (X in me[T] = [], Ei[T]) Ei[T].hasOwnProperty(X) && me[T].push(X);
    return me;
  }, F.addFont = function(T, X, me, ke, Fe) {
    var Xe = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Xe.indexOf(arguments[3]) !== -1 ? Fe = arguments[3] : arguments[3] && Xe.indexOf(arguments[3]) == -1 && (me = tt(me, ke)), Fe = Fe || "Identity-H", sn.call(this, T, X, me, Fe);
  };
  var Bs, Lo = x.lineWidth || 0.200025, on = F.__private__.getLineWidth = F.getLineWidth = function() {
    return Lo;
  }, dl = F.__private__.setLineWidth = F.setLineWidth = function(T) {
    return Lo = T, Y(Be(le(T)) + " w"), this;
  };
  F.__private__.setLineDash = yi.API.setLineDash = yi.API.setLineDashPattern = function(T, X) {
    if (T = T || [], X = X || 0, isNaN(X) || !Array.isArray(T)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return T = T.map(function(me) {
      return Be(le(me));
    }).join(" "), X = Be(le(X)), Y("[" + T + "] " + X + " d"), this;
  };
  var ra = F.__private__.getLineHeight = F.getLineHeight = function() {
    return yt * Bs;
  };
  F.__private__.getLineHeight = F.getLineHeight = function() {
    return yt * Bs;
  };
  var vs = F.__private__.setLineHeightFactor = F.setLineHeightFactor = function(T) {
    return typeof (T = T || 1.15) == "number" && (Bs = T), this;
  }, ns = F.__private__.getLineHeightFactor = F.getLineHeightFactor = function() {
    return Bs;
  };
  vs(x.lineHeight);
  var Pi = F.__private__.getHorizontalCoordinate = function(T) {
    return le(T);
  }, ss = F.__private__.getVerticalCoordinate = function(T) {
    return Me === ge.ADVANCED ? T : $[fe].mediaBox.topRightY - $[fe].mediaBox.bottomLeftY - le(T);
  }, Rl = F.__private__.getHorizontalCoordinateString = F.getHorizontalCoordinateString = function(T) {
    return Be(Pi(T));
  }, An = F.__private__.getVerticalCoordinateString = F.getVerticalCoordinateString = function(T) {
    return Be(ss(T));
  }, os = x.strokeColor || "0 G";
  F.__private__.getStrokeColor = F.getDrawColor = function() {
    return gi(os);
  }, F.__private__.setStrokeColor = F.setDrawColor = function(T, X, me, ke) {
    return os = pi({ ch1: T, ch2: X, ch3: me, ch4: ke, pdfColorType: "draw", precision: 2 }), Y(os), this;
  };
  var na = x.fillColor || "0 g";
  F.__private__.getFillColor = F.getFillColor = function() {
    return gi(na);
  }, F.__private__.setFillColor = F.setFillColor = function(T, X, me, ke) {
    return na = pi({ ch1: T, ch2: X, ch3: me, ch4: ke, pdfColorType: "fill", precision: 2 }), Y(na), this;
  };
  var To = x.textColor || "0 g", pl = F.__private__.getTextColor = F.getTextColor = function() {
    return gi(To);
  };
  F.__private__.setTextColor = F.setTextColor = function(T, X, me, ke) {
    return To = pi({ ch1: T, ch2: X, ch3: me, ch4: ke, pdfColorType: "text", precision: 3 }), this;
  };
  var no = x.charSpace, fl = F.__private__.getCharSpace = F.getCharSpace = function() {
    return parseFloat(no || 0);
  };
  F.__private__.setCharSpace = F.setCharSpace = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return no = T, this;
  };
  var sa = 0;
  F.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, F.__private__.setLineCap = F.setLineCap = function(T) {
    var X = F.CapJoinStyles[T];
    if (X === void 0) throw new Error("Line cap style of '" + T + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return sa = X, Y(X + " J"), this;
  };
  var oa = 0;
  F.__private__.setLineJoin = F.setLineJoin = function(T) {
    var X = F.CapJoinStyles[T];
    if (X === void 0) throw new Error("Line join style of '" + T + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return oa = X, Y(X + " j"), this;
  }, F.__private__.setLineMiterLimit = F.__private__.setMiterLimit = F.setLineMiterLimit = F.setMiterLimit = function(T) {
    if (T = T || 0, isNaN(T)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Y(Be(le(T)) + " M"), this;
  }, F.GState = Yh, F.setGState = function(T) {
    (T = typeof T == "string" ? qi[Cr[T]] : qa(null, T)).equals(Er) || (Y("/" + T.id + " gs"), Er = T);
  };
  var qa = function(T, X) {
    if (!T || !Cr[T]) {
      var me = !1;
      for (var ke in qi) if (qi.hasOwnProperty(ke) && qi[ke].equals(X)) {
        me = !0;
        break;
      }
      if (me) X = qi[ke];
      else {
        var Fe = "GS" + (Object.keys(qi).length + 1).toString(10);
        qi[Fe] = X, X.id = Fe;
      }
      return T && (Cr[T] = X.id), W.publish("addGState", X), X;
    }
  };
  F.addGState = function(T, X) {
    return qa(T, X), this;
  }, F.saveGraphicsState = function() {
    return Y("q"), Pr.push({ key: ai, size: yt, color: To }), this;
  }, F.restoreGraphicsState = function() {
    Y("Q");
    var T = Pr.pop();
    return ai = T.key, yt = T.size, To = T.color, Er = null, this;
  }, F.setCurrentTransformationMatrix = function(T) {
    return Y(T.toString() + " cm"), this;
  }, F.comment = function(T) {
    return Y("#" + T), this;
  };
  var Nn = function(T, X) {
    var me = T || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return me;
    }, set: function(Xe) {
      isNaN(Xe) || (me = parseFloat(Xe));
    } });
    var ke = X || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return ke;
    }, set: function(Xe) {
      isNaN(Xe) || (ke = parseFloat(Xe));
    } });
    var Fe = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Fe;
    }, set: function(Xe) {
      Fe = Xe.toString();
    } }), this;
  }, aa = function(T, X, me, ke) {
    Nn.call(this, T, X), this.type = "rect";
    var Fe = me || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Fe;
    }, set: function(xt) {
      isNaN(xt) || (Fe = parseFloat(xt));
    } });
    var Xe = ke || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Xe;
    }, set: function(xt) {
      isNaN(xt) || (Xe = parseFloat(xt));
    } }), this;
  }, Va = function() {
    this.page = ue, this.currentPage = fe, this.pages = bt.slice(0), this.pagesContext = $.slice(0), this.x = cr, this.y = ct, this.matrix = si, this.width = xs(fe), this.height = so(fe), this.outputDestination = Mt, this.id = "", this.objectNumber = -1;
  };
  Va.prototype.restore = function() {
    ue = this.page, fe = this.currentPage, $ = this.pagesContext, bt = this.pages, cr = this.x, ct = this.y, si = this.matrix, $a(fe, this.width), ca(fe, this.height), Mt = this.outputDestination;
  };
  var Ua = function(T, X, me, ke, Fe) {
    Ee.push(new Va()), ue = fe = 0, bt = [], cr = T, ct = X, si = Fe, ts([me, ke]);
  }, ko = function(T) {
    if (Pe[T]) Ee.pop().restore();
    else {
      var X = new Va(), me = "Xo" + (Object.keys(ce).length + 1).toString(10);
      X.id = me, Pe[T] = me, ce[me] = X, W.publish("addFormObject", X), Ee.pop().restore();
    }
  };
  for (var la in F.beginFormObject = function(T, X, me, ke, Fe) {
    return Ua(T, X, me, ke, Fe), this;
  }, F.endFormObject = function(T) {
    return ko(T), this;
  }, F.doFormObject = function(T, X) {
    var me = ce[Pe[T]];
    return Y("q"), Y(X.toString() + " cm"), Y("/" + me.id + " Do"), Y("Q"), this;
  }, F.getFormObject = function(T) {
    var X = ce[Pe[T]];
    return { x: X.x, y: X.y, width: X.width, height: X.height, matrix: X.matrix };
  }, F.save = function(T, X) {
    return T = T || "generated.pdf", (X = X || {}).returnPromise = X.returnPromise || !1, X.returnPromise === !1 ? (rc(Yo(ys()), T), typeof rc.unload == "function" && _i.setTimeout && setTimeout(rc.unload, 911), this) : new Promise(function(me, ke) {
      try {
        var Fe = rc(Yo(ys()), T);
        typeof rc.unload == "function" && _i.setTimeout && setTimeout(rc.unload, 911), me(Fe);
      } catch (Xe) {
        ke(Xe.message);
      }
    });
  }, yi.API) yi.API.hasOwnProperty(la) && (la === "events" && yi.API.events.length ? function(T, X) {
    var me, ke, Fe;
    for (Fe = X.length - 1; Fe !== -1; Fe--) me = X[Fe][0], ke = X[Fe][1], T.subscribe.apply(T, [me].concat(typeof ke == "function" ? [ke] : ke));
  }(W, yi.API.events) : F[la] = yi.API[la]);
  var xs = F.getPageWidth = function(T) {
    return ($[T = T || fe].mediaBox.topRightX - $[T].mediaBox.bottomLeftX) / It;
  }, $a = F.setPageWidth = function(T, X) {
    $[T].mediaBox.topRightX = X * It + $[T].mediaBox.bottomLeftX;
  }, so = F.getPageHeight = function(T) {
    return ($[T = T || fe].mediaBox.topRightY - $[T].mediaBox.bottomLeftY) / It;
  }, ca = F.setPageHeight = function(T, X) {
    $[T].mediaBox.topRightY = X * It + $[T].mediaBox.bottomLeftY;
  };
  return F.internal = { pdfEscape: Fr, getStyle: ja, getFont: ia, getFontSize: Pt, getCharSpace: fl, getTextColor: pl, getLineHeight: ra, getLineHeightFactor: ns, getLineWidth: on, write: ui, getHorizontalCoordinate: Pi, getVerticalCoordinate: ss, getCoordinateString: Rl, getVerticalCoordinateString: An, collections: {}, newObject: Re, newAdditionalObject: Zt, newObjectDeferred: mt, newObjectDeferredBegin: Dt, getFilters: Ui, putStream: Fi, events: W, scaleFactor: It, pageSize: { getWidth: function() {
    return xs(fe);
  }, setWidth: function(T) {
    $a(fe, T);
  }, getHeight: function() {
    return so(fe);
  }, setHeight: function(T) {
    ca(fe, T);
  } }, encryptionOptions: q, encryption: gr, getEncryptor: Io, output: Po, getNumberOfPages: Ba, pages: bt, out: Y, f2: it, f3: oe, getPageInfo: Rr, getPageInfoByObjId: Xt, getCurrentPageInfo: Jo, getPDFVersion: ae, Point: Nn, Rectangle: aa, Matrix: Ae, hasHotfix: hl }, Object.defineProperty(F.internal.pageSize, "width", { get: function() {
    return xs(fe);
  }, set: function(T) {
    $a(fe, T);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(F.internal.pageSize, "height", { get: function() {
    return so(fe);
  }, set: function(T) {
    ca(fe, T);
  }, enumerable: !0, configurable: !0 }), Ra.call(F, at), ai = "F1", is(S, p), W.publish("initialized"), F;
}
Ec.prototype.lsbFirstWord = function(x) {
  return String.fromCharCode(x >> 0 & 255, x >> 8 & 255, x >> 16 & 255, x >> 24 & 255);
}, Ec.prototype.toHexString = function(x) {
  return x.split("").map(function(d) {
    return ("0" + (255 & d.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Ec.prototype.hexToBytes = function(x) {
  for (var d = [], p = 0; p < x.length; p += 2) d.push(String.fromCharCode(parseInt(x.substr(p, 2), 16)));
  return d.join("");
}, Ec.prototype.processOwnerPassword = function(x, d) {
  return hd(cd(d).substr(0, 5), x);
}, Ec.prototype.encryptor = function(x, d) {
  var p = cd(this.encryptionKey + String.fromCharCode(255 & x, x >> 8 & 255, x >> 16 & 255, 255 & d, d >> 8 & 255)).substr(0, 10);
  return function(v) {
    return hd(p, v);
  };
}, Yh.prototype.equals = function(x) {
  var d, p = "id,objectNumber,equals";
  if (!x || rr(x) !== rr(this)) return !1;
  var v = 0;
  for (d in this) if (!(p.indexOf(d) >= 0)) {
    if (this.hasOwnProperty(d) && !x.hasOwnProperty(d) || this[d] !== x[d]) return !1;
    v++;
  }
  for (d in x) x.hasOwnProperty(d) && p.indexOf(d) < 0 && v--;
  return v === 0;
}, yi.API = { events: [] }, yi.version = "2.5.1";
var Nr = yi.API, gd = 1, oc = function(x) {
  return x.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, kc = function(x) {
  return x.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Li = function(x) {
  return x.toFixed(2);
}, Cl = function(x) {
  return x.toFixed(5);
};
Nr.__acroform__ = {};
var zs = function(x, d) {
  x.prototype = Object.create(d.prototype), x.prototype.constructor = x;
}, ef = function(x) {
  return x * gd;
}, Ca = function(x) {
  var d = new Mf(), p = Ht.internal.getHeight(x) || 0, v = Ht.internal.getWidth(x) || 0;
  return d.BBox = [0, 0, Number(Li(v)), Number(Li(p))], d;
}, A0 = Nr.__acroform__.setBit = function(x, d) {
  if (x = x || 0, d = d || 0, isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return x |= 1 << d;
}, P0 = Nr.__acroform__.clearBit = function(x, d) {
  if (x = x || 0, d = d || 0, isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return x &= ~(1 << d);
}, I0 = Nr.__acroform__.getBit = function(x, d) {
  if (isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return x & 1 << d ? 1 : 0;
}, qr = Nr.__acroform__.getBitForPdf = function(x, d) {
  if (isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return I0(x, d - 1);
}, Vr = Nr.__acroform__.setBitForPdf = function(x, d) {
  if (isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return A0(x, d - 1);
}, Ur = Nr.__acroform__.clearBitForPdf = function(x, d) {
  if (isNaN(x) || isNaN(d)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return P0(x, d - 1);
}, L0 = Nr.__acroform__.calculateCoordinates = function(x, d) {
  var p = d.internal.getHorizontalCoordinate, v = d.internal.getVerticalCoordinate, S = x[0], w = x[1], _ = x[2], c = x[3], C = {};
  return C.lowerLeft_X = p(S) || 0, C.lowerLeft_Y = v(w + c) || 0, C.upperRight_X = p(S + _) || 0, C.upperRight_Y = v(w) || 0, [Number(Li(C.lowerLeft_X)), Number(Li(C.lowerLeft_Y)), Number(Li(C.upperRight_X)), Number(Li(C.upperRight_Y))];
}, T0 = function(x) {
  if (x.appearanceStreamContent) return x.appearanceStreamContent;
  if (x.V || x.DV) {
    var d = [], p = x._V || x.DV, v = ud(x, p), S = x.scope.internal.getFont(x.fontName, x.fontStyle).id;
    d.push("/Tx BMC"), d.push("q"), d.push("BT"), d.push(x.scope.__private__.encodeColorString(x.color)), d.push("/" + S + " " + Li(v.fontSize) + " Tf"), d.push("1 0 0 1 0 0 Tm"), d.push(v.text), d.push("ET"), d.push("Q"), d.push("EMC");
    var w = Ca(x);
    return w.scope = x.scope, w.stream = d.join(`
`), w;
  }
}, ud = function(x, d) {
  var p = x.fontSize === 0 ? x.maxFontSize : x.fontSize, v = { text: "", fontSize: "" }, S = (d = (d = d.substr(0, 1) == "(" ? d.substr(1) : d).substr(d.length - 1) == ")" ? d.substr(0, d.length - 1) : d).split(" ");
  S = x.multiline ? S.map(function(oe) {
    return oe.split(`
`);
  }) : S.map(function(oe) {
    return [oe];
  });
  var w = p, _ = Ht.internal.getHeight(x) || 0;
  _ = _ < 0 ? -_ : _;
  var c = Ht.internal.getWidth(x) || 0;
  c = c < 0 ? -c : c;
  var C = function(oe, le, Le) {
    if (oe + 1 < S.length) {
      var Se = le + " " + S[oe + 1][0];
      return jh(Se, x, Le).width <= c - 4;
    }
    return !1;
  };
  w++;
  e: for (; w > 0; ) {
    d = "", w--;
    var N, q, j = jh("3", x, w).height, V = x.multiline ? _ - w : (_ - j) / 2, F = V += 2, de = 0, ae = 0, ye = 0;
    if (w <= 0) {
      d = `(...) Tj
`, d += "% Width of Text: " + jh(d, x, w = 12).width + ", FieldWidth:" + c + `
`;
      break;
    }
    for (var se = "", ge = 0, Me = 0; Me < S.length; Me++) if (S.hasOwnProperty(Me)) {
      var Ye = !1;
      if (S[Me].length !== 1 && ye !== S[Me].length - 1) {
        if ((j + 2) * (ge + 2) + 2 > _) continue e;
        se += S[Me][ye], Ye = !0, ae = Me, Me--;
      } else {
        se = (se += S[Me][ye] + " ").substr(se.length - 1) == " " ? se.substr(0, se.length - 1) : se;
        var $e = parseInt(Me), tt = C($e, se, w), Be = Me >= S.length - 1;
        if (tt && !Be) {
          se += " ", ye = 0;
          continue;
        }
        if (tt || Be) {
          if (Be) ae = $e;
          else if (x.multiline && (j + 2) * (ge + 2) + 2 > _) continue e;
        } else {
          if (!x.multiline || (j + 2) * (ge + 2) + 2 > _) continue e;
          ae = $e;
        }
      }
      for (var Ie = "", ot = de; ot <= ae; ot++) {
        var it = S[ot];
        if (x.multiline) {
          if (ot === ae) {
            Ie += it[ye] + " ", ye = (ye + 1) % it.length;
            continue;
          }
          if (ot === de) {
            Ie += it[it.length - 1] + " ";
            continue;
          }
        }
        Ie += it[0] + " ";
      }
      switch (Ie = Ie.substr(Ie.length - 1) == " " ? Ie.substr(0, Ie.length - 1) : Ie, q = jh(Ie, x, w).width, x.textAlign) {
        case "right":
          N = c - q - 2;
          break;
        case "center":
          N = (c - q) / 2;
          break;
        case "left":
        default:
          N = 2;
      }
      d += Li(N) + " " + Li(F) + ` Td
`, d += "(" + oc(Ie) + `) Tj
`, d += -Li(N) + ` 0 Td
`, F = -(w + 2), q = 0, de = Ye ? ae : ae + 1, ge++, se = "";
    }
    break;
  }
  return v.text = d, v.fontSize = w, v;
}, jh = function(x, d, p) {
  var v = d.scope.internal.getFont(d.fontName, d.fontStyle), S = d.scope.getStringUnitWidth(x, { font: v, fontSize: parseFloat(p), charSpace: 0 }) * parseFloat(p);
  return { height: d.scope.getStringUnitWidth("3", { font: v, fontSize: parseFloat(p), charSpace: 0 }) * parseFloat(p) * 1.5, width: S };
}, k0 = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, C0 = function(x, d) {
  var p = { type: "reference", object: x };
  d.internal.getPageInfo(x.page).pageContext.annotations.find(function(v) {
    return v.type === p.type && v.object === p.object;
  }) === void 0 && d.internal.getPageInfo(x.page).pageContext.annotations.push(p);
}, E0 = function(x, d) {
  for (var p in x) if (x.hasOwnProperty(p)) {
    var v = p, S = x[p];
    d.internal.newObjectDeferredBegin(S.objId, !0), rr(S) === "object" && typeof S.putStream == "function" && S.putStream(), delete x[v];
  }
}, M0 = function(x, d) {
  if (d.scope = x, x.internal !== void 0 && (x.internal.acroformPlugin === void 0 || x.internal.acroformPlugin.isInitialized === !1)) {
    if (Zo.FieldNum = 0, x.internal.acroformPlugin = JSON.parse(JSON.stringify(k0)), x.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    gd = x.internal.scaleFactor, x.internal.acroformPlugin.acroFormDictionaryRoot = new zf(), x.internal.acroformPlugin.acroFormDictionaryRoot.scope = x, x.internal.acroformPlugin.acroFormDictionaryRoot._eventID = x.internal.events.subscribe("postPutResources", function() {
      (function(p) {
        p.internal.events.unsubscribe(p.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete p.internal.acroformPlugin.acroFormDictionaryRoot._eventID, p.internal.acroformPlugin.printedOut = !0;
      })(x);
    }), x.internal.events.subscribe("buildDocument", function() {
      (function(p) {
        p.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var v = p.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var S in v) if (v.hasOwnProperty(S)) {
          var w = v[S];
          w.objId = void 0, w.hasAnnotation && C0(w, p);
        }
      })(x);
    }), x.internal.events.subscribe("putCatalog", function() {
      (function(p) {
        if (p.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        p.internal.write("/AcroForm " + p.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(x);
    }), x.internal.events.subscribe("postPutPages", function(p) {
      (function(v, S) {
        var w = !v;
        for (var _ in v || (S.internal.newObjectDeferredBegin(S.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), S.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), v = v || S.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (v.hasOwnProperty(_)) {
          var c = v[_], C = [], N = c.Rect;
          if (c.Rect && (c.Rect = L0(c.Rect, S)), S.internal.newObjectDeferredBegin(c.objId, !0), c.DA = Ht.createDefaultAppearanceStream(c), rr(c) === "object" && typeof c.getKeyValueListForStream == "function" && (C = c.getKeyValueListForStream()), c.Rect = N, c.hasAppearanceStream && !c.appearanceStreamContent) {
            var q = T0(c);
            C.push({ key: "AP", value: "<</N " + q + ">>" }), S.internal.acroformPlugin.xForms.push(q);
          }
          if (c.appearanceStreamContent) {
            var j = "";
            for (var V in c.appearanceStreamContent) if (c.appearanceStreamContent.hasOwnProperty(V)) {
              var F = c.appearanceStreamContent[V];
              if (j += "/" + V + " ", j += "<<", Object.keys(F).length >= 1 || Array.isArray(F)) {
                for (var _ in F) if (F.hasOwnProperty(_)) {
                  var de = F[_];
                  typeof de == "function" && (de = de.call(S, c)), j += "/" + _ + " " + de + " ", S.internal.acroformPlugin.xForms.indexOf(de) >= 0 || S.internal.acroformPlugin.xForms.push(de);
                }
              } else typeof (de = F) == "function" && (de = de.call(S, c)), j += "/" + _ + " " + de, S.internal.acroformPlugin.xForms.indexOf(de) >= 0 || S.internal.acroformPlugin.xForms.push(de);
              j += ">>";
            }
            C.push({ key: "AP", value: `<<
` + j + ">>" });
          }
          S.internal.putStream({ additionalKeyValues: C, objectId: c.objId }), S.internal.out("endobj");
        }
        w && E0(S.internal.acroformPlugin.xForms, S);
      })(p, x);
    }), x.internal.acroformPlugin.isInitialized = !0;
  }
}, Ef = Nr.__acroform__.arrayToPdfArray = function(x, d, p) {
  var v = function(_) {
    return _;
  };
  if (Array.isArray(x)) {
    for (var S = "[", w = 0; w < x.length; w++) switch (w !== 0 && (S += " "), rr(x[w])) {
      case "boolean":
      case "number":
      case "object":
        S += x[w].toString();
        break;
      case "string":
        x[w].substr(0, 1) !== "/" ? (d !== void 0 && p && (v = p.internal.getEncryptor(d)), S += "(" + oc(v(x[w].toString())) + ")") : S += x[w].toString();
    }
    return S += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Ju = function(x, d, p) {
  var v = function(S) {
    return S;
  };
  return d !== void 0 && p && (v = p.internal.getEncryptor(d)), (x = x || "").toString(), x = "(" + oc(v(x)) + ")";
}, Ma = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(x) {
    this._objId = x;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Ma.prototype.toString = function() {
  return this.objId + " 0 R";
}, Ma.prototype.putStream = function() {
  var x = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: x, objectId: this.objId }), this.scope.internal.out("endobj");
}, Ma.prototype.getKeyValueListForStream = function() {
  var x = [], d = Object.getOwnPropertyNames(this).filter(function(w) {
    return w != "content" && w != "appearanceStreamContent" && w != "scope" && w != "objId" && w.substring(0, 1) != "_";
  });
  for (var p in d) if (Object.getOwnPropertyDescriptor(this, d[p]).configurable === !1) {
    var v = d[p], S = this[v];
    S && (Array.isArray(S) ? x.push({ key: v, value: Ef(S, this.objId, this.scope) }) : S instanceof Ma ? (S.scope = this.scope, x.push({ key: v, value: S.objId + " 0 R" })) : typeof S != "function" && x.push({ key: v, value: S }));
  }
  return x;
};
var Mf = function() {
  Ma.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var x, d = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return d;
  }, set: function(p) {
    d = p;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(p) {
    x = p.trim();
  }, get: function() {
    return x || null;
  } });
};
zs(Mf, Ma);
var zf = function() {
  Ma.call(this);
  var x, d = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return d.length > 0 ? d : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return d;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (x) {
      var p = function(v) {
        return v;
      };
      return this.scope && (p = this.scope.internal.getEncryptor(this.objId)), "(" + oc(p(x)) + ")";
    }
  }, set: function(p) {
    x = p;
  } });
};
zs(zf, Ma);
var Zo = function x() {
  Ma.call(this);
  var d = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return d;
  }, set: function(se) {
    if (isNaN(se)) throw new Error('Invalid value "' + se + '" for attribute F supplied.');
    d = se;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(d, 3);
  }, set: function(se) {
    se ? this.F = Vr(d, 3) : this.F = Ur(d, 3);
  } });
  var p = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return p;
  }, set: function(se) {
    if (isNaN(se)) throw new Error('Invalid value "' + se + '" for attribute Ff supplied.');
    p = se;
  } });
  var v = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (v.length !== 0) return v;
  }, set: function(se) {
    v = se !== void 0 ? se : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !v || isNaN(v[0]) ? 0 : v[0];
  }, set: function(se) {
    v[0] = se;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !v || isNaN(v[1]) ? 0 : v[1];
  }, set: function(se) {
    v[1] = se;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !v || isNaN(v[2]) ? 0 : v[2];
  }, set: function(se) {
    v[2] = se;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !v || isNaN(v[3]) ? 0 : v[3];
  }, set: function(se) {
    v[3] = se;
  } });
  var S = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return S;
  }, set: function(se) {
    switch (se) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        S = se;
        break;
      default:
        throw new Error('Invalid value "' + se + '" for attribute FT supplied.');
    }
  } });
  var w = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!w || w.length < 1) {
      if (this instanceof Jh) return;
      w = "FieldObject" + x.FieldNum++;
    }
    var se = function(ge) {
      return ge;
    };
    return this.scope && (se = this.scope.internal.getEncryptor(this.objId)), "(" + oc(se(w)) + ")";
  }, set: function(se) {
    w = se.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return w;
  }, set: function(se) {
    w = se;
  } });
  var _ = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return _;
  }, set: function(se) {
    _ = se;
  } });
  var c = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(se) {
    c = se;
  } });
  var C = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return C;
  }, set: function(se) {
    C = se;
  } });
  var N = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return N === void 0 ? 50 / gd : N;
  }, set: function(se) {
    N = se;
  } });
  var q = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return q;
  }, set: function(se) {
    q = se;
  } });
  var j = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!j || this instanceof Jh || this instanceof sc)) return Ju(j, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), j = se;
  } });
  var V = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (V) return this instanceof wn ? V : Ju(V, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), V = this instanceof wn ? se : se.substr(0, 1) === "(" ? kc(se.substr(1, se.length - 2)) : kc(se);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof wn ? kc(V.substr(1, V.length - 1)) : V;
  }, set: function(se) {
    se = se.toString(), V = this instanceof wn ? "/" + se : se;
  } });
  var F = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return F;
  }, set: function(se) {
    this.V = se;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return this instanceof wn ? F : Ju(F, this.objId, this.scope);
  }, set: function(se) {
    se = se.toString(), F = this instanceof wn ? se : se.substr(0, 1) === "(" ? kc(se.substr(1, se.length - 2)) : kc(se);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof wn ? kc(F.substr(1, F.length - 1)) : F;
  }, set: function(se) {
    se = se.toString(), F = this instanceof wn ? "/" + se : se;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var de, ae = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return ae;
  }, set: function(se) {
    se = !!se, ae = se;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (de) return de;
  }, set: function(se) {
    de = se;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 1);
  }, set: function(se) {
    se ? this.Ff = Vr(this.Ff, 1) : this.Ff = Ur(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 2);
  }, set: function(se) {
    se ? this.Ff = Vr(this.Ff, 2) : this.Ff = Ur(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 3);
  }, set: function(se) {
    se ? this.Ff = Vr(this.Ff, 3) : this.Ff = Ur(this.Ff, 3);
  } });
  var ye = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (ye !== null) return ye;
  }, set: function(se) {
    if ([0, 1, 2].indexOf(se) === -1) throw new Error('Invalid value "' + se + '" for attribute Q supplied.');
    ye = se;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var se;
    switch (ye) {
      case 0:
      default:
        se = "left";
        break;
      case 1:
        se = "center";
        break;
      case 2:
        se = "right";
    }
    return se;
  }, configurable: !0, enumerable: !0, set: function(se) {
    switch (se) {
      case "right":
      case 2:
        ye = 2;
        break;
      case "center":
      case 1:
        ye = 1;
        break;
      case "left":
      case 0:
      default:
        ye = 0;
    }
  } });
};
zs(Zo, Ma);
var Nc = function() {
  Zo.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var x = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(p) {
    x = p;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return x;
  }, set: function(p) {
    x = p;
  } });
  var d = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return Ef(d, this.objId, this.scope);
  }, set: function(p) {
    var v, S;
    S = [], typeof (v = p) == "string" && (S = function(w, _, c) {
      c || (c = 1);
      for (var C, N = []; C = _.exec(w); ) N.push(C[c]);
      return N;
    }(v, /\((.*?)\)/g)), d = S;
  } }), this.getOptions = function() {
    return d;
  }, this.setOptions = function(p) {
    d = p, this.sort && d.sort();
  }, this.addOption = function(p) {
    p = (p = p || "").toString(), d.push(p), this.sort && d.sort();
  }, this.removeOption = function(p, v) {
    for (v = v || !1, p = (p = p || "").toString(); d.indexOf(p) !== -1 && (d.splice(d.indexOf(p), 1), v !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 18);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 18) : this.Ff = Ur(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 19);
  }, set: function(p) {
    this.combo === !0 && (p ? this.Ff = Vr(this.Ff, 19) : this.Ff = Ur(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 20);
  }, set: function(p) {
    p ? (this.Ff = Vr(this.Ff, 20), d.sort()) : this.Ff = Ur(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 22);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 22) : this.Ff = Ur(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 23);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 23) : this.Ff = Ur(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 27);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 27) : this.Ff = Ur(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
zs(Nc, Zo);
var Fc = function() {
  Nc.call(this), this.fontName = "helvetica", this.combo = !1;
};
zs(Fc, Nc);
var Rc = function() {
  Fc.call(this), this.combo = !0;
};
zs(Rc, Fc);
var Uh = function() {
  Rc.call(this), this.edit = !0;
};
zs(Uh, Rc);
var wn = function() {
  Zo.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 15);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 15) : this.Ff = Ur(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 16);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 16) : this.Ff = Ur(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 17);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 17) : this.Ff = Ur(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 26);
  }, set: function(p) {
    p ? this.Ff = Vr(this.Ff, 26) : this.Ff = Ur(this.Ff, 26);
  } });
  var x, d = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var p = function(w) {
      return w;
    };
    if (this.scope && (p = this.scope.internal.getEncryptor(this.objId)), Object.keys(d).length !== 0) {
      var v, S = [];
      for (v in S.push("<<"), d) S.push("/" + v + " (" + oc(p(d[v])) + ")");
      return S.push(">>"), S.join(`
`);
    }
  }, set: function(p) {
    rr(p) === "object" && (d = p);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return d.CA || "";
  }, set: function(p) {
    typeof p == "string" && (d.CA = p);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return x;
  }, set: function(p) {
    x = p;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return x.substr(1, x.length - 1);
  }, set: function(p) {
    x = "/" + p;
  } });
};
zs(wn, Zo);
var $h = function() {
  wn.call(this), this.pushButton = !0;
};
zs($h, wn);
var Bc = function() {
  wn.call(this), this.radio = !0, this.pushButton = !1;
  var x = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(d) {
    x = d !== void 0 ? d : [];
  } });
};
zs(Bc, wn);
var Jh = function() {
  var x, d;
  Zo.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return x;
  }, set: function(S) {
    x = S;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return d;
  }, set: function(S) {
    d = S;
  } });
  var p, v = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var S = function(c) {
      return c;
    };
    this.scope && (S = this.scope.internal.getEncryptor(this.objId));
    var w, _ = [];
    for (w in _.push("<<"), v) _.push("/" + w + " (" + oc(S(v[w])) + ")");
    return _.push(">>"), _.join(`
`);
  }, set: function(S) {
    rr(S) === "object" && (v = S);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return v.CA || "";
  }, set: function(S) {
    typeof S == "string" && (v.CA = S);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return p;
  }, set: function(S) {
    p = S;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return p.substr(1, p.length - 1);
  }, set: function(S) {
    p = "/" + S;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Ht.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
zs(Jh, Zo), Bc.prototype.setAppearance = function(x) {
  if (!("createAppearanceStream" in x) || !("getCA" in x)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var d in this.Kids) if (this.Kids.hasOwnProperty(d)) {
    var p = this.Kids[d];
    p.appearanceStreamContent = x.createAppearanceStream(p.optionName), p.caption = x.getCA();
  }
}, Bc.prototype.createOption = function(x) {
  var d = new Jh();
  return d.Parent = this, d.optionName = x, this.Kids.push(d), z0.call(this.scope, d), d;
};
var Zh = function() {
  wn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Ht.CheckBox.createAppearanceStream();
};
zs(Zh, wn);
var sc = function() {
  Zo.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 13);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 13) : this.Ff = Ur(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 21);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 21) : this.Ff = Ur(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 23);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 23) : this.Ff = Ur(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 24);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 24) : this.Ff = Ur(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 25);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 25) : this.Ff = Ur(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 26);
  }, set: function(d) {
    d ? this.Ff = Vr(this.Ff, 26) : this.Ff = Ur(this.Ff, 26);
  } });
  var x = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(d) {
    x = d;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return x;
  }, set: function(d) {
    Number.isInteger(d) && (x = d);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
zs(sc, Zo);
var Gh = function() {
  sc.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!qr(this.Ff, 14);
  }, set: function(x) {
    x ? this.Ff = Vr(this.Ff, 14) : this.Ff = Ur(this.Ff, 14);
  } }), this.password = !0;
};
zs(Gh, sc);
var Ht = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Ht.CheckBox.YesNormal }, D: { On: Ht.CheckBox.YesPushDown, Off: Ht.CheckBox.OffPushDown } };
}, YesPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [], v = x.scope.internal.getFont(x.fontName, x.fontStyle).id, S = x.scope.__private__.encodeColorString(x.color), w = ud(x, x.caption);
  return p.push("0.749023 g"), p.push("0 0 " + Li(Ht.internal.getWidth(x)) + " " + Li(Ht.internal.getHeight(x)) + " re"), p.push("f"), p.push("BMC"), p.push("q"), p.push("0 0 1 rg"), p.push("/" + v + " " + Li(w.fontSize) + " Tf " + S), p.push("BT"), p.push(w.text), p.push("ET"), p.push("Q"), p.push("EMC"), d.stream = p.join(`
`), d;
}, YesNormal: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = x.scope.internal.getFont(x.fontName, x.fontStyle).id, v = x.scope.__private__.encodeColorString(x.color), S = [], w = Ht.internal.getHeight(x), _ = Ht.internal.getWidth(x), c = ud(x, x.caption);
  return S.push("1 g"), S.push("0 0 " + Li(_) + " " + Li(w) + " re"), S.push("f"), S.push("q"), S.push("0 0 1 rg"), S.push("0 0 " + Li(_ - 1) + " " + Li(w - 1) + " re"), S.push("W"), S.push("n"), S.push("0 g"), S.push("BT"), S.push("/" + p + " " + Li(c.fontSize) + " Tf " + v), S.push(c.text), S.push("ET"), S.push("Q"), d.stream = S.join(`
`), d;
}, OffPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [];
  return p.push("0.749023 g"), p.push("0 0 " + Li(Ht.internal.getWidth(x)) + " " + Li(Ht.internal.getHeight(x)) + " re"), p.push("f"), d.stream = p.join(`
`), d;
} }, RadioButton: { Circle: { createAppearanceStream: function(x) {
  var d = { D: { Off: Ht.RadioButton.Circle.OffPushDown }, N: {} };
  return d.N[x] = Ht.RadioButton.Circle.YesNormal, d.D[x] = Ht.RadioButton.Circle.YesPushDown, d;
}, getCA: function() {
  return "l";
}, YesNormal: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [], v = Ht.internal.getWidth(x) <= Ht.internal.getHeight(x) ? Ht.internal.getWidth(x) / 4 : Ht.internal.getHeight(x) / 4;
  v = Number((0.9 * v).toFixed(5));
  var S = Ht.internal.Bezier_C, w = Number((v * S).toFixed(5));
  return p.push("q"), p.push("1 0 0 1 " + Cl(Ht.internal.getWidth(x) / 2) + " " + Cl(Ht.internal.getHeight(x) / 2) + " cm"), p.push(v + " 0 m"), p.push(v + " " + w + " " + w + " " + v + " 0 " + v + " c"), p.push("-" + w + " " + v + " -" + v + " " + w + " -" + v + " 0 c"), p.push("-" + v + " -" + w + " -" + w + " -" + v + " 0 -" + v + " c"), p.push(w + " -" + v + " " + v + " -" + w + " " + v + " 0 c"), p.push("f"), p.push("Q"), d.stream = p.join(`
`), d;
}, YesPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [], v = Ht.internal.getWidth(x) <= Ht.internal.getHeight(x) ? Ht.internal.getWidth(x) / 4 : Ht.internal.getHeight(x) / 4;
  v = Number((0.9 * v).toFixed(5));
  var S = Number((2 * v).toFixed(5)), w = Number((S * Ht.internal.Bezier_C).toFixed(5)), _ = Number((v * Ht.internal.Bezier_C).toFixed(5));
  return p.push("0.749023 g"), p.push("q"), p.push("1 0 0 1 " + Cl(Ht.internal.getWidth(x) / 2) + " " + Cl(Ht.internal.getHeight(x) / 2) + " cm"), p.push(S + " 0 m"), p.push(S + " " + w + " " + w + " " + S + " 0 " + S + " c"), p.push("-" + w + " " + S + " -" + S + " " + w + " -" + S + " 0 c"), p.push("-" + S + " -" + w + " -" + w + " -" + S + " 0 -" + S + " c"), p.push(w + " -" + S + " " + S + " -" + w + " " + S + " 0 c"), p.push("f"), p.push("Q"), p.push("0 g"), p.push("q"), p.push("1 0 0 1 " + Cl(Ht.internal.getWidth(x) / 2) + " " + Cl(Ht.internal.getHeight(x) / 2) + " cm"), p.push(v + " 0 m"), p.push(v + " " + _ + " " + _ + " " + v + " 0 " + v + " c"), p.push("-" + _ + " " + v + " -" + v + " " + _ + " -" + v + " 0 c"), p.push("-" + v + " -" + _ + " -" + _ + " -" + v + " 0 -" + v + " c"), p.push(_ + " -" + v + " " + v + " -" + _ + " " + v + " 0 c"), p.push("f"), p.push("Q"), d.stream = p.join(`
`), d;
}, OffPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [], v = Ht.internal.getWidth(x) <= Ht.internal.getHeight(x) ? Ht.internal.getWidth(x) / 4 : Ht.internal.getHeight(x) / 4;
  v = Number((0.9 * v).toFixed(5));
  var S = Number((2 * v).toFixed(5)), w = Number((S * Ht.internal.Bezier_C).toFixed(5));
  return p.push("0.749023 g"), p.push("q"), p.push("1 0 0 1 " + Cl(Ht.internal.getWidth(x) / 2) + " " + Cl(Ht.internal.getHeight(x) / 2) + " cm"), p.push(S + " 0 m"), p.push(S + " " + w + " " + w + " " + S + " 0 " + S + " c"), p.push("-" + w + " " + S + " -" + S + " " + w + " -" + S + " 0 c"), p.push("-" + S + " -" + w + " -" + w + " -" + S + " 0 -" + S + " c"), p.push(w + " -" + S + " " + S + " -" + w + " " + S + " 0 c"), p.push("f"), p.push("Q"), d.stream = p.join(`
`), d;
} }, Cross: { createAppearanceStream: function(x) {
  var d = { D: { Off: Ht.RadioButton.Cross.OffPushDown }, N: {} };
  return d.N[x] = Ht.RadioButton.Cross.YesNormal, d.D[x] = Ht.RadioButton.Cross.YesPushDown, d;
}, getCA: function() {
  return "8";
}, YesNormal: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [], v = Ht.internal.calculateCross(x);
  return p.push("q"), p.push("1 1 " + Li(Ht.internal.getWidth(x) - 2) + " " + Li(Ht.internal.getHeight(x) - 2) + " re"), p.push("W"), p.push("n"), p.push(Li(v.x1.x) + " " + Li(v.x1.y) + " m"), p.push(Li(v.x2.x) + " " + Li(v.x2.y) + " l"), p.push(Li(v.x4.x) + " " + Li(v.x4.y) + " m"), p.push(Li(v.x3.x) + " " + Li(v.x3.y) + " l"), p.push("s"), p.push("Q"), d.stream = p.join(`
`), d;
}, YesPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = Ht.internal.calculateCross(x), v = [];
  return v.push("0.749023 g"), v.push("0 0 " + Li(Ht.internal.getWidth(x)) + " " + Li(Ht.internal.getHeight(x)) + " re"), v.push("f"), v.push("q"), v.push("1 1 " + Li(Ht.internal.getWidth(x) - 2) + " " + Li(Ht.internal.getHeight(x) - 2) + " re"), v.push("W"), v.push("n"), v.push(Li(p.x1.x) + " " + Li(p.x1.y) + " m"), v.push(Li(p.x2.x) + " " + Li(p.x2.y) + " l"), v.push(Li(p.x4.x) + " " + Li(p.x4.y) + " m"), v.push(Li(p.x3.x) + " " + Li(p.x3.y) + " l"), v.push("s"), v.push("Q"), d.stream = v.join(`
`), d;
}, OffPushDown: function(x) {
  var d = Ca(x);
  d.scope = x.scope;
  var p = [];
  return p.push("0.749023 g"), p.push("0 0 " + Li(Ht.internal.getWidth(x)) + " " + Li(Ht.internal.getHeight(x)) + " re"), p.push("f"), d.stream = p.join(`
`), d;
} } }, createDefaultAppearanceStream: function(x) {
  var d = x.scope.internal.getFont(x.fontName, x.fontStyle).id, p = x.scope.__private__.encodeColorString(x.color);
  return "/" + d + " " + x.fontSize + " Tf " + p;
} };
Ht.internal = { Bezier_C: 0.551915024494, calculateCross: function(x) {
  var d = Ht.internal.getWidth(x), p = Ht.internal.getHeight(x), v = Math.min(d, p);
  return { x1: { x: (d - v) / 2, y: (p - v) / 2 + v }, x2: { x: (d - v) / 2 + v, y: (p - v) / 2 }, x3: { x: (d - v) / 2, y: (p - v) / 2 }, x4: { x: (d - v) / 2 + v, y: (p - v) / 2 + v } };
} }, Ht.internal.getWidth = function(x) {
  var d = 0;
  return rr(x) === "object" && (d = ef(x.Rect[2])), d;
}, Ht.internal.getHeight = function(x) {
  var d = 0;
  return rr(x) === "object" && (d = ef(x.Rect[3])), d;
};
var z0 = Nr.addField = function(x) {
  if (M0(this, x), !(x instanceof Zo)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var d;
  return (d = x).scope.internal.acroformPlugin.printedOut && (d.scope.internal.acroformPlugin.printedOut = !1, d.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), d.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(d), x.page = x.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Nr.AcroFormChoiceField = Nc, Nr.AcroFormListBox = Fc, Nr.AcroFormComboBox = Rc, Nr.AcroFormEditBox = Uh, Nr.AcroFormButton = wn, Nr.AcroFormPushButton = $h, Nr.AcroFormRadioButton = Bc, Nr.AcroFormCheckBox = Zh, Nr.AcroFormTextField = sc, Nr.AcroFormPasswordField = Gh, Nr.AcroFormAppearance = Ht, Nr.AcroForm = { ChoiceField: Nc, ListBox: Fc, ComboBox: Rc, EditBox: Uh, Button: wn, PushButton: $h, RadioButton: Bc, CheckBox: Zh, TextField: sc, PasswordField: Gh, Appearance: Ht }, yi.AcroForm = { ChoiceField: Nc, ListBox: Fc, ComboBox: Rc, EditBox: Uh, Button: wn, PushButton: $h, RadioButton: Bc, CheckBox: Zh, TextField: sc, PasswordField: Gh, Appearance: Ht };
function Df(x) {
  return x.reduce(function(d, p, v) {
    return d[p] = v, d;
  }, {});
}
(function(x) {
  x.__addimage__ = {};
  var d = "UNKNOWN", p = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, v = x.__addimage__.getImageFileTypeByImageData = function(oe, le) {
    var Le, Se, He, We, Je, je = d;
    if ((le = le || d) === "RGBA" || oe.data !== void 0 && oe.data instanceof Uint8ClampedArray && "height" in oe && "width" in oe) return "RGBA";
    if (tt(oe)) for (Je in p) for (He = p[Je], Le = 0; Le < He.length; Le += 1) {
      for (We = !0, Se = 0; Se < He[Le].length; Se += 1) if (He[Le][Se] !== void 0 && He[Le][Se] !== oe[Se]) {
        We = !1;
        break;
      }
      if (We === !0) {
        je = Je;
        break;
      }
    }
    else for (Je in p) for (He = p[Je], Le = 0; Le < He.length; Le += 1) {
      for (We = !0, Se = 0; Se < He[Le].length; Se += 1) if (He[Le][Se] !== void 0 && He[Le][Se] !== oe.charCodeAt(Se)) {
        We = !1;
        break;
      }
      if (We === !0) {
        je = Je;
        break;
      }
    }
    return je === d && le !== d && (je = le), je;
  }, S = function oe(le) {
    for (var Le = this.internal.write, Se = this.internal.putStream, He = (0, this.internal.getFilters)(); He.indexOf("FlateEncode") !== -1; ) He.splice(He.indexOf("FlateEncode"), 1);
    le.objectId = this.internal.newObject();
    var We = [];
    if (We.push({ key: "Type", value: "/XObject" }), We.push({ key: "Subtype", value: "/Image" }), We.push({ key: "Width", value: le.width }), We.push({ key: "Height", value: le.height }), le.colorSpace === ye.INDEXED ? We.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (le.palette.length / 3 - 1) + " " + ("sMask" in le && le.sMask !== void 0 ? le.objectId + 2 : le.objectId + 1) + " 0 R]" }) : (We.push({ key: "ColorSpace", value: "/" + le.colorSpace }), le.colorSpace === ye.DEVICE_CMYK && We.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), We.push({ key: "BitsPerComponent", value: le.bitsPerComponent }), "decodeParameters" in le && le.decodeParameters !== void 0 && We.push({ key: "DecodeParms", value: "<<" + le.decodeParameters + ">>" }), "transparency" in le && Array.isArray(le.transparency)) {
      for (var Je = "", je = 0, rt = le.transparency.length; je < rt; je++) Je += le.transparency[je] + " " + le.transparency[je] + " ";
      We.push({ key: "Mask", value: "[" + Je + "]" });
    }
    le.sMask !== void 0 && We.push({ key: "SMask", value: le.objectId + 1 + " 0 R" });
    var Ke = le.filter !== void 0 ? ["/" + le.filter] : void 0;
    if (Se({ data: le.data, additionalKeyValues: We, alreadyAppliedFilters: Ke, objectId: le.objectId }), Le("endobj"), "sMask" in le && le.sMask !== void 0) {
      var St = "/Predictor " + le.predictor + " /Colors 1 /BitsPerComponent " + le.bitsPerComponent + " /Columns " + le.width, J = { width: le.width, height: le.height, colorSpace: "DeviceGray", bitsPerComponent: le.bitsPerComponent, decodeParameters: St, data: le.sMask };
      "filter" in le && (J.filter = le.filter), oe.call(this, J);
    }
    if (le.colorSpace === ye.INDEXED) {
      var fe = this.internal.newObject();
      Se({ data: Ie(new Uint8Array(le.palette)), objectId: fe }), Le("endobj");
    }
  }, w = function() {
    var oe = this.internal.collections.addImage_images;
    for (var le in oe) S.call(this, oe[le]);
  }, _ = function() {
    var oe, le = this.internal.collections.addImage_images, Le = this.internal.write;
    for (var Se in le) Le("/I" + (oe = le[Se]).index, oe.objectId, "0", "R");
  }, c = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", w), this.internal.events.subscribe("putXobjectDict", _));
  }, C = function() {
    var oe = this.internal.collections.addImage_images;
    return c.call(this), oe;
  }, N = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, q = function(oe) {
    return typeof x["process" + oe.toUpperCase()] == "function";
  }, j = function(oe) {
    return rr(oe) === "object" && oe.nodeType === 1;
  }, V = function(oe, le) {
    if (oe.nodeName === "IMG" && oe.hasAttribute("src")) {
      var Le = "" + oe.getAttribute("src");
      if (Le.indexOf("data:image/") === 0) return yh(unescape(Le).split("base64,").pop());
      var Se = x.loadFile(Le, !0);
      if (Se !== void 0) return Se;
    }
    if (oe.nodeName === "CANVAS") {
      if (oe.width === 0 || oe.height === 0) throw new Error("Given canvas must have data. Canvas width: " + oe.width + ", height: " + oe.height);
      var He;
      switch (le) {
        case "PNG":
          He = "image/png";
          break;
        case "WEBP":
          He = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          He = "image/jpeg";
      }
      return yh(oe.toDataURL(He, 1).split("base64,").pop());
    }
  }, F = function(oe) {
    var le = this.internal.collections.addImage_images;
    if (le) {
      for (var Le in le) if (oe === le[Le].alias) return le[Le];
    }
  }, de = function(oe, le, Le) {
    return oe || le || (oe = -96, le = -96), oe < 0 && (oe = -1 * Le.width * 72 / oe / this.internal.scaleFactor), le < 0 && (le = -1 * Le.height * 72 / le / this.internal.scaleFactor), oe === 0 && (oe = le * Le.width / Le.height), le === 0 && (le = oe * Le.height / Le.width), [oe, le];
  }, ae = function(oe, le, Le, Se, He, We) {
    var Je = de.call(this, Le, Se, He), je = this.internal.getCoordinateString, rt = this.internal.getVerticalCoordinateString, Ke = C.call(this);
    if (Le = Je[0], Se = Je[1], Ke[He.index] = He, We) {
      We *= Math.PI / 180;
      var St = Math.cos(We), J = Math.sin(We), fe = function(Ce) {
        return Ce.toFixed(4);
      }, _e = [fe(St), fe(J), fe(-1 * J), fe(St), 0, 0, "cm"];
    }
    this.internal.write("q"), We ? (this.internal.write([1, "0", "0", 1, je(oe), rt(le + Se), "cm"].join(" ")), this.internal.write(_e.join(" ")), this.internal.write([je(Le), "0", "0", je(Se), "0", "0", "cm"].join(" "))) : this.internal.write([je(Le), "0", "0", je(Se), je(oe), rt(le + Se), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + He.index + " Do"), this.internal.write("Q");
  }, ye = x.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  x.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var se = x.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, ge = x.__addimage__.sHashCode = function(oe) {
    var le, Le, Se = 0;
    if (typeof oe == "string") for (Le = oe.length, le = 0; le < Le; le++) Se = (Se << 5) - Se + oe.charCodeAt(le), Se |= 0;
    else if (tt(oe)) for (Le = oe.byteLength / 2, le = 0; le < Le; le++) Se = (Se << 5) - Se + oe[le], Se |= 0;
    return Se;
  }, Me = x.__addimage__.validateStringAsBase64 = function(oe) {
    (oe = oe || "").toString().trim();
    var le = !0;
    return oe.length === 0 && (le = !1), oe.length % 4 != 0 && (le = !1), /^[A-Za-z0-9+/]+$/.test(oe.substr(0, oe.length - 2)) === !1 && (le = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(oe.substr(-2)) === !1 && (le = !1), le;
  }, Ye = x.__addimage__.extractImageFromDataUrl = function(oe) {
    var le = (oe = oe || "").split("base64,"), Le = null;
    if (le.length === 2) {
      var Se = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(le[0]);
      Array.isArray(Se) && (Le = { mimeType: Se[1], charset: Se[2], data: le[1] });
    }
    return Le;
  }, $e = x.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  x.__addimage__.isArrayBuffer = function(oe) {
    return $e() && oe instanceof ArrayBuffer;
  };
  var tt = x.__addimage__.isArrayBufferView = function(oe) {
    return $e() && typeof Uint32Array < "u" && (oe instanceof Int8Array || oe instanceof Uint8Array || typeof Uint8ClampedArray < "u" && oe instanceof Uint8ClampedArray || oe instanceof Int16Array || oe instanceof Uint16Array || oe instanceof Int32Array || oe instanceof Uint32Array || oe instanceof Float32Array || oe instanceof Float64Array);
  }, Be = x.__addimage__.binaryStringToUint8Array = function(oe) {
    for (var le = oe.length, Le = new Uint8Array(le), Se = 0; Se < le; Se++) Le[Se] = oe.charCodeAt(Se);
    return Le;
  }, Ie = x.__addimage__.arrayBufferToBinaryString = function(oe) {
    for (var le = "", Le = tt(oe) ? oe : new Uint8Array(oe), Se = 0; Se < Le.length; Se += 8192) le += String.fromCharCode.apply(null, Le.subarray(Se, Se + 8192));
    return le;
  };
  x.addImage = function() {
    var oe, le, Le, Se, He, We, Je, je, rt;
    if (typeof arguments[1] == "number" ? (le = d, Le = arguments[1], Se = arguments[2], He = arguments[3], We = arguments[4], Je = arguments[5], je = arguments[6], rt = arguments[7]) : (le = arguments[1], Le = arguments[2], Se = arguments[3], He = arguments[4], We = arguments[5], Je = arguments[6], je = arguments[7], rt = arguments[8]), rr(oe = arguments[0]) === "object" && !j(oe) && "imageData" in oe) {
      var Ke = oe;
      oe = Ke.imageData, le = Ke.format || le || d, Le = Ke.x || Le || 0, Se = Ke.y || Se || 0, He = Ke.w || Ke.width || He, We = Ke.h || Ke.height || We, Je = Ke.alias || Je, je = Ke.compression || je, rt = Ke.rotation || Ke.angle || rt;
    }
    var St = this.internal.getFilters();
    if (je === void 0 && St.indexOf("FlateEncode") !== -1 && (je = "SLOW"), isNaN(Le) || isNaN(Se)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c.call(this);
    var J = ot.call(this, oe, le, Je, je);
    return ae.call(this, Le, Se, He, We, J, rt), this;
  };
  var ot = function(oe, le, Le, Se) {
    var He, We, Je;
    if (typeof oe == "string" && v(oe) === d) {
      oe = unescape(oe);
      var je = it(oe, !1);
      (je !== "" || (je = x.loadFile(oe, !0)) !== void 0) && (oe = je);
    }
    if (j(oe) && (oe = V(oe, le)), le = v(oe, le), !q(le)) throw new Error("addImage does not support files of type '" + le + "', please ensure that a plugin for '" + le + "' support is added.");
    if (((Je = Le) == null || Je.length === 0) && (Le = function(rt) {
      return typeof rt == "string" || tt(rt) ? ge(rt) : tt(rt.data) ? ge(rt.data) : null;
    }(oe)), (He = F.call(this, Le)) || ($e() && (oe instanceof Uint8Array || le === "RGBA" || (We = oe, oe = Be(oe))), He = this["process" + le.toUpperCase()](oe, N.call(this), Le, function(rt) {
      return rt && typeof rt == "string" && (rt = rt.toUpperCase()), rt in x.image_compression ? rt : se.NONE;
    }(Se), We)), !He) throw new Error("An unknown error occurred whilst processing the image.");
    return He;
  }, it = x.__addimage__.convertBase64ToBinaryString = function(oe, le) {
    var Le;
    le = typeof le != "boolean" || le;
    var Se, He = "";
    if (typeof oe == "string") {
      Se = (Le = Ye(oe)) !== null ? Le.data : oe;
      try {
        He = yh(Se);
      } catch (We) {
        if (le) throw Me(Se) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + We.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return He;
  };
  x.getImageProperties = function(oe) {
    var le, Le, Se = "";
    if (j(oe) && (oe = V(oe)), typeof oe == "string" && v(oe) === d && ((Se = it(oe, !1)) === "" && (Se = x.loadFile(oe) || ""), oe = Se), Le = v(oe), !q(Le)) throw new Error("addImage does not support files of type '" + Le + "', please ensure that a plugin for '" + Le + "' support is added.");
    if (!$e() || oe instanceof Uint8Array || (oe = Be(oe)), !(le = this["process" + Le.toUpperCase()](oe))) throw new Error("An unknown error occurred whilst processing the image");
    return le.fileType = Le, le;
  };
})(yi.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = function(p) {
    if (p !== void 0 && p != "") return !0;
  };
  yi.API.events.push(["addPage", function(p) {
    this.internal.getPageInfo(p.pageNumber).pageContext.annotations = [];
  }]), x.events.push(["putPage", function(p) {
    for (var v, S, w, _ = this.internal.getCoordinateString, c = this.internal.getVerticalCoordinateString, C = this.internal.getPageInfoByObjId(p.objId), N = p.pageContext.annotations, q = !1, j = 0; j < N.length && !q; j++) switch ((v = N[j]).type) {
      case "link":
        (d(v.options.url) || d(v.options.pageNumber)) && (q = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        q = !0;
    }
    if (q != 0) {
      this.internal.write("/Annots [");
      for (var V = 0; V < N.length; V++) {
        v = N[V];
        var F = this.internal.pdfEscape, de = this.internal.getEncryptor(p.objId);
        switch (v.type) {
          case "reference":
            this.internal.write(" " + v.object.objId + " 0 R ");
            break;
          case "text":
            var ae = this.internal.newAdditionalObject(), ye = this.internal.newAdditionalObject(), se = this.internal.getEncryptor(ae.objId), ge = v.title || "Note";
            w = "<</Type /Annot /Subtype /Text " + (S = "/Rect [" + _(v.bounds.x) + " " + c(v.bounds.y + v.bounds.h) + " " + _(v.bounds.x + v.bounds.w) + " " + c(v.bounds.y) + "] ") + "/Contents (" + F(se(v.contents)) + ")", w += " /Popup " + ye.objId + " 0 R", w += " /P " + C.objId + " 0 R", w += " /T (" + F(se(ge)) + ") >>", ae.content = w;
            var Me = ae.objId + " 0 R";
            w = "<</Type /Annot /Subtype /Popup " + (S = "/Rect [" + _(v.bounds.x + 30) + " " + c(v.bounds.y + v.bounds.h) + " " + _(v.bounds.x + v.bounds.w + 30) + " " + c(v.bounds.y) + "] ") + " /Parent " + Me, v.open && (w += " /Open true"), w += " >>", ye.content = w, this.internal.write(ae.objId, "0 R", ye.objId, "0 R");
            break;
          case "freetext":
            S = "/Rect [" + _(v.bounds.x) + " " + c(v.bounds.y) + " " + _(v.bounds.x + v.bounds.w) + " " + c(v.bounds.y + v.bounds.h) + "] ";
            var Ye = v.color || "#000000";
            w = "<</Type /Annot /Subtype /FreeText " + S + "/Contents (" + F(de(v.contents)) + ")", w += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + Ye + ")", w += " /Border [0 0 0]", w += " >>", this.internal.write(w);
            break;
          case "link":
            if (v.options.name) {
              var $e = this.annotations._nameMap[v.options.name];
              v.options.pageNumber = $e.page, v.options.top = $e.y;
            } else v.options.top || (v.options.top = 0);
            if (S = "/Rect [" + v.finalBounds.x + " " + v.finalBounds.y + " " + v.finalBounds.w + " " + v.finalBounds.h + "] ", w = "", v.options.url) w = "<</Type /Annot /Subtype /Link " + S + "/Border [0 0 0] /A <</S /URI /URI (" + F(de(v.options.url)) + ") >>";
            else if (v.options.pageNumber)
              switch (w = "<</Type /Annot /Subtype /Link " + S + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(v.options.pageNumber).objId + " 0 R", v.options.magFactor = v.options.magFactor || "XYZ", v.options.magFactor) {
                case "Fit":
                  w += " /Fit]";
                  break;
                case "FitH":
                  w += " /FitH " + v.options.top + "]";
                  break;
                case "FitV":
                  v.options.left = v.options.left || 0, w += " /FitV " + v.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var tt = c(v.options.top);
                  v.options.left = v.options.left || 0, v.options.zoom === void 0 && (v.options.zoom = 0), w += " /XYZ " + v.options.left + " " + tt + " " + v.options.zoom + "]";
              }
            w != "" && (w += " >>", this.internal.write(w));
        }
      }
      this.internal.write("]");
    }
  }]), x.createAnnotation = function(p) {
    var v = this.internal.getCurrentPageInfo();
    switch (p.type) {
      case "link":
        this.link(p.bounds.x, p.bounds.y, p.bounds.w, p.bounds.h, p);
        break;
      case "text":
      case "freetext":
        v.pageContext.annotations.push(p);
    }
  }, x.link = function(p, v, S, w, _) {
    var c = this.internal.getCurrentPageInfo(), C = this.internal.getCoordinateString, N = this.internal.getVerticalCoordinateString;
    c.pageContext.annotations.push({ finalBounds: { x: C(p), y: N(v), w: C(p + S), h: N(v + w) }, options: _, type: "link" });
  }, x.textWithLink = function(p, v, S, w) {
    var _, c, C = this.getTextWidth(p), N = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (w.maxWidth !== void 0) {
      c = w.maxWidth;
      var q = this.splitTextToSize(p, c).length;
      _ = Math.ceil(N * q);
    } else c = C, _ = N;
    return this.text(p, v, S, w), S += 0.2 * N, w.align === "center" && (v -= C / 2), w.align === "right" && (v -= C), this.link(v, S - N, c, _, w), C;
  }, x.getTextWidth = function(p) {
    var v = this.internal.getFontSize();
    return this.getStringUnitWidth(p) * v / this.internal.scaleFactor;
  };
}(yi.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, p = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, v = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, S = [1570, 1571, 1573, 1575];
  x.__arabicParser__ = {};
  var w = x.__arabicParser__.isInArabicSubstitutionA = function(ae) {
    return d[ae.charCodeAt(0)] !== void 0;
  }, _ = x.__arabicParser__.isArabicLetter = function(ae) {
    return typeof ae == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(ae);
  }, c = x.__arabicParser__.isArabicEndLetter = function(ae) {
    return _(ae) && w(ae) && d[ae.charCodeAt(0)].length <= 2;
  }, C = x.__arabicParser__.isArabicAlfLetter = function(ae) {
    return _(ae) && S.indexOf(ae.charCodeAt(0)) >= 0;
  };
  x.__arabicParser__.arabicLetterHasIsolatedForm = function(ae) {
    return _(ae) && w(ae) && d[ae.charCodeAt(0)].length >= 1;
  };
  var N = x.__arabicParser__.arabicLetterHasFinalForm = function(ae) {
    return _(ae) && w(ae) && d[ae.charCodeAt(0)].length >= 2;
  };
  x.__arabicParser__.arabicLetterHasInitialForm = function(ae) {
    return _(ae) && w(ae) && d[ae.charCodeAt(0)].length >= 3;
  };
  var q = x.__arabicParser__.arabicLetterHasMedialForm = function(ae) {
    return _(ae) && w(ae) && d[ae.charCodeAt(0)].length == 4;
  }, j = x.__arabicParser__.resolveLigatures = function(ae) {
    var ye = 0, se = p, ge = "", Me = 0;
    for (ye = 0; ye < ae.length; ye += 1) se[ae.charCodeAt(ye)] !== void 0 ? (Me++, typeof (se = se[ae.charCodeAt(ye)]) == "number" && (ge += String.fromCharCode(se), se = p, Me = 0), ye === ae.length - 1 && (se = p, ge += ae.charAt(ye - (Me - 1)), ye -= Me - 1, Me = 0)) : (se = p, ge += ae.charAt(ye - Me), ye -= Me, Me = 0);
    return ge;
  };
  x.__arabicParser__.isArabicDiacritic = function(ae) {
    return ae !== void 0 && v[ae.charCodeAt(0)] !== void 0;
  };
  var V = x.__arabicParser__.getCorrectForm = function(ae, ye, se) {
    return _(ae) ? w(ae) === !1 ? -1 : !N(ae) || !_(ye) && !_(se) || !_(se) && c(ye) || c(ae) && !_(ye) || c(ae) && C(ye) || c(ae) && c(ye) ? 0 : q(ae) && _(ye) && !c(ye) && _(se) && N(se) ? 3 : c(ae) || !_(se) ? 1 : 2 : -1;
  }, F = function(ae) {
    var ye = 0, se = 0, ge = 0, Me = "", Ye = "", $e = "", tt = (ae = ae || "").split("\\s+"), Be = [];
    for (ye = 0; ye < tt.length; ye += 1) {
      for (Be.push(""), se = 0; se < tt[ye].length; se += 1) Me = tt[ye][se], Ye = tt[ye][se - 1], $e = tt[ye][se + 1], _(Me) ? (ge = V(Me, Ye, $e), Be[ye] += ge !== -1 ? String.fromCharCode(d[Me.charCodeAt(0)][ge]) : Me) : Be[ye] += Me;
      Be[ye] = j(Be[ye]);
    }
    return Be.join(" ");
  }, de = x.__arabicParser__.processArabic = x.processArabic = function() {
    var ae, ye = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, se = [];
    if (Array.isArray(ye)) {
      var ge = 0;
      for (se = [], ge = 0; ge < ye.length; ge += 1) Array.isArray(ye[ge]) ? se.push([F(ye[ge][0]), ye[ge][1], ye[ge][2]]) : se.push([F(ye[ge])]);
      ae = se;
    } else ae = F(ye);
    return typeof arguments[0] == "string" ? ae : (arguments[0].text = ae, arguments[0]);
  };
  x.events.push(["preProcessText", de]);
}(yi.API), yi.API.autoPrint = function(x) {
  var d;
  switch ((x = x || {}).variant = x.variant || "non-conform", x.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        d = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + d + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = function() {
    var p = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return p;
    }, set: function(c) {
      p = c;
    } });
    var v = 150;
    Object.defineProperty(this, "width", { get: function() {
      return v;
    }, set: function(c) {
      v = isNaN(c) || Number.isInteger(c) === !1 || c < 0 ? 150 : c, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = v + 1);
    } });
    var S = 300;
    Object.defineProperty(this, "height", { get: function() {
      return S;
    }, set: function(c) {
      S = isNaN(c) || Number.isInteger(c) === !1 || c < 0 ? 300 : c, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = S + 1);
    } });
    var w = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return w;
    }, set: function(c) {
      w = c;
    } });
    var _ = {};
    Object.defineProperty(this, "style", { get: function() {
      return _;
    }, set: function(c) {
      _ = c;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  d.prototype.getContext = function(p, v) {
    var S;
    if ((p = p || "2d") !== "2d") return null;
    for (S in v) this.pdf.context2d.hasOwnProperty(S) && (this.pdf.context2d[S] = v[S]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, d.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, x.events.push(["initialized", function() {
    this.canvas = new d(), this.canvas.pdf = this;
  }]);
}(yi.API), function(x) {
  var d = { left: 0, top: 0, bottom: 0, right: 0 }, p = !1, v = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, d), this.internal.__cell__.margins.width = this.getPageWidth(), S.call(this));
  }, S = function() {
    this.internal.__cell__.lastCell = new w(), this.internal.__cell__.pages = 1;
  }, w = function() {
    var C = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return C;
    }, set: function(ae) {
      C = ae;
    } });
    var N = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return N;
    }, set: function(ae) {
      N = ae;
    } });
    var q = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return q;
    }, set: function(ae) {
      q = ae;
    } });
    var j = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return j;
    }, set: function(ae) {
      j = ae;
    } });
    var V = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return V;
    }, set: function(ae) {
      V = ae;
    } });
    var F = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return F;
    }, set: function(ae) {
      F = ae;
    } });
    var de = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return de;
    }, set: function(ae) {
      de = ae;
    } }), this;
  };
  w.prototype.clone = function() {
    return new w(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, w.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, x.setHeaderFunction = function(C) {
    return v.call(this), this.internal.__cell__.headerFunction = typeof C == "function" ? C : void 0, this;
  }, x.getTextDimensions = function(C, N) {
    v.call(this);
    var q = (N = N || {}).fontSize || this.getFontSize(), j = N.font || this.getFont(), V = N.scaleFactor || this.internal.scaleFactor, F = 0, de = 0, ae = 0, ye = this;
    if (!Array.isArray(C) && typeof C != "string") {
      if (typeof C != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      C = String(C);
    }
    var se = N.maxWidth;
    se > 0 ? typeof C == "string" ? C = this.splitTextToSize(C, se) : Object.prototype.toString.call(C) === "[object Array]" && (C = C.reduce(function(Me, Ye) {
      return Me.concat(ye.splitTextToSize(Ye, se));
    }, [])) : C = Array.isArray(C) ? C : [C];
    for (var ge = 0; ge < C.length; ge++) F < (ae = this.getStringUnitWidth(C[ge], { font: j }) * q) && (F = ae);
    return F !== 0 && (de = C.length), { w: F /= V, h: Math.max((de * q * this.getLineHeightFactor() - q * (this.getLineHeightFactor() - 1)) / V, 0) };
  }, x.cellAddPage = function() {
    v.call(this), this.addPage();
    var C = this.internal.__cell__.margins || d;
    return this.internal.__cell__.lastCell = new w(C.left, C.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var _ = x.cell = function() {
    var C;
    C = arguments[0] instanceof w ? arguments[0] : new w(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), v.call(this);
    var N = this.internal.__cell__.lastCell, q = this.internal.__cell__.padding, j = this.internal.__cell__.margins || d, V = this.internal.__cell__.tableHeaderRow, F = this.internal.__cell__.printHeaders;
    return N.lineNumber !== void 0 && (N.lineNumber === C.lineNumber ? (C.x = (N.x || 0) + (N.width || 0), C.y = N.y || 0) : N.y + N.height + C.height + j.bottom > this.getPageHeight() ? (this.cellAddPage(), C.y = j.top, F && V && (this.printHeaderRow(C.lineNumber, !0), C.y += V[0].height)) : C.y = N.y + N.height || C.y), C.text[0] !== void 0 && (this.rect(C.x, C.y, C.width, C.height, p === !0 ? "FD" : void 0), C.align === "right" ? this.text(C.text, C.x + C.width - q, C.y + q, { align: "right", baseline: "top" }) : C.align === "center" ? this.text(C.text, C.x + C.width / 2, C.y + q, { align: "center", baseline: "top", maxWidth: C.width - q - q }) : this.text(C.text, C.x + q, C.y + q, { align: "left", baseline: "top", maxWidth: C.width - q - q })), this.internal.__cell__.lastCell = C, this;
  };
  x.table = function(C, N, q, j, V) {
    if (v.call(this), !q) throw new Error("No data for PDF table.");
    var F, de, ae, ye, se = [], ge = [], Me = [], Ye = {}, $e = {}, tt = [], Be = [], Ie = (V = V || {}).autoSize || !1, ot = V.printHeaders !== !1, it = V.css && V.css["font-size"] !== void 0 ? 16 * V.css["font-size"] : V.fontSize || 12, oe = V.margins || Object.assign({ width: this.getPageWidth() }, d), le = typeof V.padding == "number" ? V.padding : 3, Le = V.headerBackgroundColor || "#c8c8c8", Se = V.headerTextColor || "#000";
    if (S.call(this), this.internal.__cell__.printHeaders = ot, this.internal.__cell__.margins = oe, this.internal.__cell__.table_font_size = it, this.internal.__cell__.padding = le, this.internal.__cell__.headerBackgroundColor = Le, this.internal.__cell__.headerTextColor = Se, this.setFontSize(it), j == null) ge = se = Object.keys(q[0]), Me = se.map(function() {
      return "left";
    });
    else if (Array.isArray(j) && rr(j[0]) === "object") for (se = j.map(function(Ke) {
      return Ke.name;
    }), ge = j.map(function(Ke) {
      return Ke.prompt || Ke.name || "";
    }), Me = j.map(function(Ke) {
      return Ke.align || "left";
    }), F = 0; F < j.length; F += 1) $e[j[F].name] = j[F].width * (19.049976 / 25.4);
    else Array.isArray(j) && typeof j[0] == "string" && (ge = se = j, Me = se.map(function() {
      return "left";
    }));
    if (Ie || Array.isArray(j) && typeof j[0] == "string") for (F = 0; F < se.length; F += 1) {
      for (Ye[ye = se[F]] = q.map(function(Ke) {
        return Ke[ye];
      }), this.setFont(void 0, "bold"), tt.push(this.getTextDimensions(ge[F], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), de = Ye[ye], this.setFont(void 0, "normal"), ae = 0; ae < de.length; ae += 1) tt.push(this.getTextDimensions(de[ae], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      $e[ye] = Math.max.apply(null, tt) + le + le, tt = [];
    }
    if (ot) {
      var He = {};
      for (F = 0; F < se.length; F += 1) He[se[F]] = {}, He[se[F]].text = ge[F], He[se[F]].align = Me[F];
      var We = c.call(this, He, $e);
      Be = se.map(function(Ke) {
        return new w(C, N, $e[Ke], We, He[Ke].text, void 0, He[Ke].align);
      }), this.setTableHeaderRow(Be), this.printHeaderRow(1, !1);
    }
    var Je = j.reduce(function(Ke, St) {
      return Ke[St.name] = St.align, Ke;
    }, {});
    for (F = 0; F < q.length; F += 1) {
      "rowStart" in V && V.rowStart instanceof Function && V.rowStart({ row: F, data: q[F] }, this);
      var je = c.call(this, q[F], $e);
      for (ae = 0; ae < se.length; ae += 1) {
        var rt = q[F][se[ae]];
        "cellStart" in V && V.cellStart instanceof Function && V.cellStart({ row: F, col: ae, data: rt }, this), _.call(this, new w(C, N, $e[se[ae]], je, rt, F + 2, Je[se[ae]]));
      }
    }
    return this.internal.__cell__.table_x = C, this.internal.__cell__.table_y = N, this;
  };
  var c = function(C, N) {
    var q = this.internal.__cell__.padding, j = this.internal.__cell__.table_font_size, V = this.internal.scaleFactor;
    return Object.keys(C).map(function(F) {
      var de = C[F];
      return this.splitTextToSize(de.hasOwnProperty("text") ? de.text : de, N[F] - q - q);
    }, this).map(function(F) {
      return this.getLineHeightFactor() * F.length * j / V + q + q;
    }, this).reduce(function(F, de) {
      return Math.max(F, de);
    }, 0);
  };
  x.setTableHeaderRow = function(C) {
    v.call(this), this.internal.__cell__.tableHeaderRow = C;
  }, x.printHeaderRow = function(C, N) {
    if (v.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var q;
    if (p = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var j = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new w(j[0], j[1], j[2], j[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var V = [], F = 0; F < this.internal.__cell__.tableHeaderRow.length; F += 1) {
      q = this.internal.__cell__.tableHeaderRow[F].clone(), N && (q.y = this.internal.__cell__.margins.top || 0, V.push(q)), q.lineNumber = C;
      var de = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), _.call(this, q), this.setTextColor(de);
    }
    V.length > 0 && this.setTableHeaderRow(V), this.setFont(void 0, "normal"), p = !1;
  };
}(yi.API);
var Nf = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, Ff = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], dd = Df(Ff), Rf = [100, 200, 300, 400, 500, 600, 700, 800, 900], D0 = Df(Rf);
function pd(x) {
  var d = x.family.replace(/"|'/g, "").toLowerCase(), p = function(w) {
    return Nf[w = w || "normal"] ? w : "normal";
  }(x.style), v = function(w) {
    if (!w) return 400;
    if (typeof w == "number") return w >= 100 && w <= 900 && w % 100 == 0 ? w : 400;
    if (/^\d00$/.test(w)) return parseInt(w);
    switch (w) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(x.weight), S = function(w) {
    return typeof dd[w = w || "normal"] == "number" ? w : "normal";
  }(x.stretch);
  return { family: d, style: p, weight: v, stretch: S, src: x.src || [], ref: x.ref || { name: d, style: [S, p, v].join(" ") } };
}
function tf(x, d, p, v) {
  var S;
  for (S = p; S >= 0 && S < d.length; S += v) if (x[d[S]]) return x[d[S]];
  for (S = p; S >= 0 && S < d.length; S -= v) if (x[d[S]]) return x[d[S]];
}
var N0 = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, rf = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function nf(x) {
  return [x.stretch, x.style, x.weight, x.family].join(" ");
}
function F0(x, d, p) {
  for (var v = (p = p || {}).defaultFontFamily || "times", S = Object.assign({}, N0, p.genericFontFamilies || {}), w = null, _ = null, c = 0; c < d.length; ++c) if (S[(w = pd(d[c])).family] && (w.family = S[w.family]), x.hasOwnProperty(w.family)) {
    _ = x[w.family];
    break;
  }
  if (!(_ = _ || x[v])) throw new Error("Could not find a font-family for the rule '" + nf(w) + "' and default family '" + v + "'.");
  if (_ = function(C, N) {
    if (N[C]) return N[C];
    var q = dd[C], j = q <= dd.normal ? -1 : 1, V = tf(N, Ff, q, j);
    if (!V) throw new Error("Could not find a matching font-stretch value for " + C);
    return V;
  }(w.stretch, _), _ = function(C, N) {
    if (N[C]) return N[C];
    for (var q = Nf[C], j = 0; j < q.length; ++j) if (N[q[j]]) return N[q[j]];
    throw new Error("Could not find a matching font-style for " + C);
  }(w.style, _), !(_ = function(C, N) {
    if (N[C]) return N[C];
    if (C === 400 && N[500]) return N[500];
    if (C === 500 && N[400]) return N[400];
    var q = D0[C], j = tf(N, Rf, q, C < 400 ? -1 : 1);
    if (!j) throw new Error("Could not find a matching font-weight for value " + C);
    return j;
  }(w.weight, _))) throw new Error("Failed to resolve a font for the rule '" + nf(w) + "'.");
  return _;
}
function sf(x) {
  return x.trimLeft();
}
function R0(x, d) {
  for (var p = 0; p < x.length; ) {
    if (x.charAt(p) === d) return [x.substring(0, p), x.substring(p + 1)];
    p += 1;
  }
  return null;
}
function B0(x) {
  var d = x.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return d === null ? null : [d[0], x.substring(d[0].length)];
}
var qh, of, af, lf = ["times"];
(function(x) {
  var d, p, v, S, w, _, c, C, N, q = function(J) {
    return J = J || {}, this.isStrokeTransparent = J.isStrokeTransparent || !1, this.strokeOpacity = J.strokeOpacity || 1, this.strokeStyle = J.strokeStyle || "#000000", this.fillStyle = J.fillStyle || "#000000", this.isFillTransparent = J.isFillTransparent || !1, this.fillOpacity = J.fillOpacity || 1, this.font = J.font || "10px sans-serif", this.textBaseline = J.textBaseline || "alphabetic", this.textAlign = J.textAlign || "left", this.lineWidth = J.lineWidth || 1, this.lineJoin = J.lineJoin || "miter", this.lineCap = J.lineCap || "butt", this.path = J.path || [], this.transform = J.transform !== void 0 ? J.transform.clone() : new C(), this.globalCompositeOperation = J.globalCompositeOperation || "normal", this.globalAlpha = J.globalAlpha || 1, this.clip_path = J.clip_path || [], this.currentPoint = J.currentPoint || new _(), this.miterLimit = J.miterLimit || 10, this.lastPoint = J.lastPoint || new _(), this.lineDashOffset = J.lineDashOffset || 0, this.lineDash = J.lineDash || [], this.margin = J.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = J.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof J.ignoreClearRect != "boolean" || J.ignoreClearRect, this;
  };
  x.events.push(["initialized", function() {
    this.context2d = new j(this), d = this.internal.f2, p = this.internal.getCoordinateString, v = this.internal.getVerticalCoordinateString, S = this.internal.getHorizontalCoordinate, w = this.internal.getVerticalCoordinate, _ = this.internal.Point, c = this.internal.Rectangle, C = this.internal.Matrix, N = new q();
  }]);
  var j = function(J) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var fe = J;
    Object.defineProperty(this, "pdf", { get: function() {
      return fe;
    } });
    var _e = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return _e;
    }, set: function(Qe) {
      _e = !!Qe;
    } });
    var Ce = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Ce;
    }, set: function(Qe) {
      Ce = !!Qe;
    } });
    var De = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return De;
    }, set: function(Qe) {
      isNaN(Qe) || (De = Qe);
    } });
    var Oe = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return Oe;
    }, set: function(Qe) {
      isNaN(Qe) || (Oe = Qe);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return N.margin;
    }, set: function(Qe) {
      var Y;
      typeof Qe == "number" ? Y = [Qe, Qe, Qe, Qe] : ((Y = new Array(4))[0] = Qe[0], Y[1] = Qe.length >= 2 ? Qe[1] : Y[0], Y[2] = Qe.length >= 3 ? Qe[2] : Y[0], Y[3] = Qe.length >= 4 ? Qe[3] : Y[1]), N.margin = Y;
    } });
    var qe = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return qe;
    }, set: function(Qe) {
      qe = Qe;
    } });
    var Ze = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Ze;
    }, set: function(Qe) {
      Ze = Qe;
    } });
    var wt = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return wt;
    }, set: function(Qe) {
      wt = Qe;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return N;
    }, set: function(Qe) {
      Qe instanceof q && (N = Qe);
    } }), Object.defineProperty(this, "path", { get: function() {
      return N.path;
    }, set: function(Qe) {
      N.path = Qe;
    } });
    var bt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return bt;
    }, set: function(Qe) {
      bt = Qe;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Qe) {
      var Y;
      Y = V(Qe), this.ctx.fillStyle = Y.style, this.ctx.isFillTransparent = Y.a === 0, this.ctx.fillOpacity = Y.a, this.pdf.setFillColor(Y.r, Y.g, Y.b, { a: Y.a }), this.pdf.setTextColor(Y.r, Y.g, Y.b, { a: Y.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Qe) {
      var Y = V(Qe);
      this.ctx.strokeStyle = Y.style, this.ctx.isStrokeTransparent = Y.a === 0, this.ctx.strokeOpacity = Y.a, Y.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Y.a, this.pdf.setDrawColor(Y.r, Y.g, Y.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Qe) {
      ["butt", "round", "square"].indexOf(Qe) !== -1 && (this.ctx.lineCap = Qe, this.pdf.setLineCap(Qe));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Qe) {
      isNaN(Qe) || (this.ctx.lineWidth = Qe, this.pdf.setLineWidth(Qe));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Qe) {
      ["bevel", "round", "miter"].indexOf(Qe) !== -1 && (this.ctx.lineJoin = Qe, this.pdf.setLineJoin(Qe));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Qe) {
      isNaN(Qe) || (this.ctx.miterLimit = Qe, this.pdf.setMiterLimit(Qe));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Qe) {
      this.ctx.textBaseline = Qe;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Qe) {
      ["right", "end", "center", "left", "start"].indexOf(Qe) !== -1 && (this.ctx.textAlign = Qe);
    } });
    var Tt = null;
    function Mt(Qe, Y) {
      if (Tt === null) {
        var ui = function($t) {
          var at = [];
          return Object.keys($t).forEach(function(yt) {
            $t[yt].forEach(function(zt) {
              var Pt = null;
              switch (zt) {
                case "bold":
                  Pt = { family: yt, weight: "bold" };
                  break;
                case "italic":
                  Pt = { family: yt, style: "italic" };
                  break;
                case "bolditalic":
                  Pt = { family: yt, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Pt = { family: yt };
              }
              Pt !== null && (Pt.ref = { name: yt, style: zt }, at.push(Pt));
            });
          }), at;
        }(Qe.getFontList());
        Tt = function($t) {
          for (var at = {}, yt = 0; yt < $t.length; ++yt) {
            var zt = pd($t[yt]), Pt = zt.family, Gt = zt.stretch, di = zt.style, oi = zt.weight;
            at[Pt] = at[Pt] || {}, at[Pt][Gt] = at[Pt][Gt] || {}, at[Pt][Gt][di] = at[Pt][Gt][di] || {}, at[Pt][Gt][di][oi] = zt;
          }
          return at;
        }(ui.concat(Y));
      }
      return Tt;
    }
    var Qt = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Qt;
    }, set: function(Qe) {
      Tt = null, Qt = Qe;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Qe) {
      var Y;
      if (this.ctx.font = Qe, (Y = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Qe)) !== null) {
        var ui = Y[1], $t = (Y[2], Y[3]), at = Y[4], yt = (Y[5], Y[6]), zt = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(at)[2];
        at = Math.floor(zt === "px" ? parseFloat(at) * this.pdf.internal.scaleFactor : zt === "em" ? parseFloat(at) * this.pdf.getFontSize() : parseFloat(at) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(at);
        var Pt = function(ei) {
          var ai, It, cr = [], ct = ei.trim();
          if (ct === "") return lf;
          if (ct in rf) return [rf[ct]];
          for (; ct !== ""; ) {
            switch (It = null, ai = (ct = sf(ct)).charAt(0)) {
              case '"':
              case "'":
                It = R0(ct.substring(1), ai);
                break;
              default:
                It = B0(ct);
            }
            if (It === null || (cr.push(It[0]), (ct = sf(It[1])) !== "" && ct.charAt(0) !== ",")) return lf;
            ct = ct.replace(/^,/, "");
          }
          return cr;
        }(yt);
        if (this.fontFaces) {
          var Gt = F0(Mt(this.pdf, this.fontFaces), Pt.map(function(ei) {
            return { family: ei, stretch: "normal", weight: $t, style: ui };
          }));
          this.pdf.setFont(Gt.ref.name, Gt.ref.style);
        } else {
          var di = "";
          ($t === "bold" || parseInt($t, 10) >= 700 || ui === "bold") && (di = "bold"), ui === "italic" && (di += "italic"), di.length === 0 && (di = "normal");
          for (var oi = "", bi = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Ci = 0; Ci < Pt.length; Ci++) {
            if (this.pdf.internal.getFont(Pt[Ci], di, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              oi = Pt[Ci];
              break;
            }
            if (di === "bolditalic" && this.pdf.internal.getFont(Pt[Ci], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) oi = Pt[Ci], di = "bold";
            else if (this.pdf.internal.getFont(Pt[Ci], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              oi = Pt[Ci], di = "normal";
              break;
            }
          }
          if (oi === "") {
            for (var lt = 0; lt < Pt.length; lt++) if (bi[Pt[lt]]) {
              oi = bi[Pt[lt]];
              break;
            }
          }
          oi = oi === "" ? "Times" : oi, this.pdf.setFont(oi, di);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Qe) {
      this.ctx.globalCompositeOperation = Qe;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Qe) {
      this.ctx.globalAlpha = Qe;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Qe) {
      this.ctx.lineDashOffset = Qe, St.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Qe) {
      this.ctx.lineDash = Qe, St.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Qe) {
      this.ctx.ignoreClearRect = !!Qe;
    } });
  };
  j.prototype.setLineDash = function(J) {
    this.lineDash = J;
  }, j.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, j.prototype.fill = function() {
    Ye.call(this, "fill", !1);
  }, j.prototype.stroke = function() {
    Ye.call(this, "stroke", !1);
  }, j.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, j.prototype.moveTo = function(J, fe) {
    if (isNaN(J) || isNaN(fe)) throw pr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var _e = this.ctx.transform.applyToPoint(new _(J, fe));
    this.path.push({ type: "mt", x: _e.x, y: _e.y }), this.ctx.lastPoint = new _(J, fe);
  }, j.prototype.closePath = function() {
    var J = new _(0, 0), fe = 0;
    for (fe = this.path.length - 1; fe !== -1; fe--) if (this.path[fe].type === "begin" && rr(this.path[fe + 1]) === "object" && typeof this.path[fe + 1].x == "number") {
      J = new _(this.path[fe + 1].x, this.path[fe + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new _(J.x, J.y);
  }, j.prototype.lineTo = function(J, fe) {
    if (isNaN(J) || isNaN(fe)) throw pr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var _e = this.ctx.transform.applyToPoint(new _(J, fe));
    this.path.push({ type: "lt", x: _e.x, y: _e.y }), this.ctx.lastPoint = new _(_e.x, _e.y);
  }, j.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), Ye.call(this, null, !0);
  }, j.prototype.quadraticCurveTo = function(J, fe, _e, Ce) {
    if (isNaN(_e) || isNaN(Ce) || isNaN(J) || isNaN(fe)) throw pr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var De = this.ctx.transform.applyToPoint(new _(_e, Ce)), Oe = this.ctx.transform.applyToPoint(new _(J, fe));
    this.path.push({ type: "qct", x1: Oe.x, y1: Oe.y, x: De.x, y: De.y }), this.ctx.lastPoint = new _(De.x, De.y);
  }, j.prototype.bezierCurveTo = function(J, fe, _e, Ce, De, Oe) {
    if (isNaN(De) || isNaN(Oe) || isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce)) throw pr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var qe = this.ctx.transform.applyToPoint(new _(De, Oe)), Ze = this.ctx.transform.applyToPoint(new _(J, fe)), wt = this.ctx.transform.applyToPoint(new _(_e, Ce));
    this.path.push({ type: "bct", x1: Ze.x, y1: Ze.y, x2: wt.x, y2: wt.y, x: qe.x, y: qe.y }), this.ctx.lastPoint = new _(qe.x, qe.y);
  }, j.prototype.arc = function(J, fe, _e, Ce, De, Oe) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce) || isNaN(De)) throw pr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (Oe = !!Oe, !this.ctx.transform.isIdentity) {
      var qe = this.ctx.transform.applyToPoint(new _(J, fe));
      J = qe.x, fe = qe.y;
      var Ze = this.ctx.transform.applyToPoint(new _(0, _e)), wt = this.ctx.transform.applyToPoint(new _(0, 0));
      _e = Math.sqrt(Math.pow(Ze.x - wt.x, 2) + Math.pow(Ze.y - wt.y, 2));
    }
    Math.abs(De - Ce) >= 2 * Math.PI && (Ce = 0, De = 2 * Math.PI), this.path.push({ type: "arc", x: J, y: fe, radius: _e, startAngle: Ce, endAngle: De, counterclockwise: Oe });
  }, j.prototype.arcTo = function(J, fe, _e, Ce, De) {
    throw new Error("arcTo not implemented.");
  }, j.prototype.rect = function(J, fe, _e, Ce) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce)) throw pr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(J, fe), this.lineTo(J + _e, fe), this.lineTo(J + _e, fe + Ce), this.lineTo(J, fe + Ce), this.lineTo(J, fe), this.lineTo(J + _e, fe), this.lineTo(J, fe);
  }, j.prototype.fillRect = function(J, fe, _e, Ce) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce)) throw pr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!F.call(this)) {
      var De = {};
      this.lineCap !== "butt" && (De.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (De.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(J, fe, _e, Ce), this.fill(), De.hasOwnProperty("lineCap") && (this.lineCap = De.lineCap), De.hasOwnProperty("lineJoin") && (this.lineJoin = De.lineJoin);
    }
  }, j.prototype.strokeRect = function(J, fe, _e, Ce) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce)) throw pr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    de.call(this) || (this.beginPath(), this.rect(J, fe, _e, Ce), this.stroke());
  }, j.prototype.clearRect = function(J, fe, _e, Ce) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce)) throw pr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(J, fe, _e, Ce));
  }, j.prototype.save = function(J) {
    J = typeof J != "boolean" || J;
    for (var fe = this.pdf.internal.getCurrentPageInfo().pageNumber, _e = 0; _e < this.pdf.internal.getNumberOfPages(); _e++) this.pdf.setPage(_e + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(fe), J) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Ce = new q(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Ce;
    }
  }, j.prototype.restore = function(J) {
    J = typeof J != "boolean" || J;
    for (var fe = this.pdf.internal.getCurrentPageInfo().pageNumber, _e = 0; _e < this.pdf.internal.getNumberOfPages(); _e++) this.pdf.setPage(_e + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(fe), J && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, j.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var V = function(J) {
    var fe, _e, Ce, De;
    if (J.isCanvasGradient === !0 && (J = J.getColor()), !J) return { r: 0, g: 0, b: 0, a: 0, style: J };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(J)) fe = 0, _e = 0, Ce = 0, De = 0;
    else {
      var Oe = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(J);
      if (Oe !== null) fe = parseInt(Oe[1]), _e = parseInt(Oe[2]), Ce = parseInt(Oe[3]), De = 1;
      else if ((Oe = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(J)) !== null) fe = parseInt(Oe[1]), _e = parseInt(Oe[2]), Ce = parseInt(Oe[3]), De = parseFloat(Oe[4]);
      else {
        if (De = 1, typeof J == "string" && J.charAt(0) !== "#") {
          var qe = new Tf(J);
          J = qe.ok ? qe.toHex() : "#000000";
        }
        J.length === 4 ? (fe = J.substring(1, 2), fe += fe, _e = J.substring(2, 3), _e += _e, Ce = J.substring(3, 4), Ce += Ce) : (fe = J.substring(1, 3), _e = J.substring(3, 5), Ce = J.substring(5, 7)), fe = parseInt(fe, 16), _e = parseInt(_e, 16), Ce = parseInt(Ce, 16);
      }
    }
    return { r: fe, g: _e, b: Ce, a: De, style: J };
  }, F = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, de = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  j.prototype.fillText = function(J, fe, _e, Ce) {
    if (isNaN(fe) || isNaN(_e) || typeof J != "string") throw pr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Ce = isNaN(Ce) ? void 0 : Ce, !F.call(this)) {
      var De = je(this.ctx.transform.rotation), Oe = this.ctx.transform.scaleX;
      le.call(this, { text: J, x: fe, y: _e, scale: Oe, angle: De, align: this.textAlign, maxWidth: Ce });
    }
  }, j.prototype.strokeText = function(J, fe, _e, Ce) {
    if (isNaN(fe) || isNaN(_e) || typeof J != "string") throw pr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!de.call(this)) {
      Ce = isNaN(Ce) ? void 0 : Ce;
      var De = je(this.ctx.transform.rotation), Oe = this.ctx.transform.scaleX;
      le.call(this, { text: J, x: fe, y: _e, scale: Oe, renderingMode: "stroke", angle: De, align: this.textAlign, maxWidth: Ce });
    }
  }, j.prototype.measureText = function(J) {
    if (typeof J != "string") throw pr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var fe = this.pdf, _e = this.pdf.internal.scaleFactor, Ce = fe.internal.getFontSize(), De = fe.getStringUnitWidth(J) * Ce / fe.internal.scaleFactor, Oe = function(qe) {
      var Ze = (qe = qe || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Ze;
      } }), this;
    };
    return new Oe({ width: De *= Math.round(96 * _e / 72 * 1e4) / 1e4 });
  }, j.prototype.scale = function(J, fe) {
    if (isNaN(J) || isNaN(fe)) throw pr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var _e = new C(J, 0, 0, fe, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(_e);
  }, j.prototype.rotate = function(J) {
    if (isNaN(J)) throw pr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var fe = new C(Math.cos(J), Math.sin(J), -Math.sin(J), Math.cos(J), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(fe);
  }, j.prototype.translate = function(J, fe) {
    if (isNaN(J) || isNaN(fe)) throw pr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var _e = new C(1, 0, 0, 1, J, fe);
    this.ctx.transform = this.ctx.transform.multiply(_e);
  }, j.prototype.transform = function(J, fe, _e, Ce, De, Oe) {
    if (isNaN(J) || isNaN(fe) || isNaN(_e) || isNaN(Ce) || isNaN(De) || isNaN(Oe)) throw pr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var qe = new C(J, fe, _e, Ce, De, Oe);
    this.ctx.transform = this.ctx.transform.multiply(qe);
  }, j.prototype.setTransform = function(J, fe, _e, Ce, De, Oe) {
    J = isNaN(J) ? 1 : J, fe = isNaN(fe) ? 0 : fe, _e = isNaN(_e) ? 0 : _e, Ce = isNaN(Ce) ? 1 : Ce, De = isNaN(De) ? 0 : De, Oe = isNaN(Oe) ? 0 : Oe, this.ctx.transform = new C(J, fe, _e, Ce, De, Oe);
  };
  var ae = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  j.prototype.drawImage = function(J, fe, _e, Ce, De, Oe, qe, Ze, wt) {
    var bt = this.pdf.getImageProperties(J), Tt = 1, Mt = 1, Qt = 1, Qe = 1;
    Ce !== void 0 && Ze !== void 0 && (Qt = Ze / Ce, Qe = wt / De, Tt = bt.width / Ce * Ze / Ce, Mt = bt.height / De * wt / De), Oe === void 0 && (Oe = fe, qe = _e, fe = 0, _e = 0), Ce !== void 0 && Ze === void 0 && (Ze = Ce, wt = De), Ce === void 0 && Ze === void 0 && (Ze = bt.width, wt = bt.height);
    for (var Y, ui = this.ctx.transform.decompose(), $t = je(ui.rotate.shx), at = new C(), yt = (at = (at = (at = at.multiply(ui.translate)).multiply(ui.skew)).multiply(ui.scale)).applyToRectangle(new c(Oe - fe * Qt, qe - _e * Qe, Ce * Tt, De * Mt)), zt = ye.call(this, yt), Pt = [], Gt = 0; Gt < zt.length; Gt += 1) Pt.indexOf(zt[Gt]) === -1 && Pt.push(zt[Gt]);
    if (Me(Pt), this.autoPaging) for (var di = Pt[0], oi = Pt[Pt.length - 1], bi = di; bi < oi + 1; bi++) {
      this.pdf.setPage(bi);
      var Ci = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], lt = bi === 1 ? this.posY + this.margin[0] : this.margin[0], ei = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ai = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], It = bi === 1 ? 0 : ei + (bi - 2) * ai;
      if (this.ctx.clip_path.length !== 0) {
        var cr = this.path;
        Y = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ge(Y, this.posX + this.margin[3], -It + lt + this.ctx.prevPageLastElemOffset), $e.call(this, "fill", !0), this.path = cr;
      }
      var ct = JSON.parse(JSON.stringify(yt));
      ct = ge([ct], this.posX + this.margin[3], -It + lt + this.ctx.prevPageLastElemOffset)[0];
      var si = (bi > di || bi < oi) && ae.call(this);
      si && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ci, ai, null).clip().discardPath()), this.pdf.addImage(J, "JPEG", ct.x, ct.y, ct.w, ct.h, null, null, $t), si && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(J, "JPEG", yt.x, yt.y, yt.w, yt.h, null, null, $t);
  };
  var ye = function(J, fe, _e) {
    var Ce = [];
    fe = fe || this.pdf.internal.pageSize.width, _e = _e || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var De = this.posY + this.ctx.prevPageLastElemOffset;
    switch (J.type) {
      default:
      case "mt":
      case "lt":
        Ce.push(Math.floor((J.y + De) / _e) + 1);
        break;
      case "arc":
        Ce.push(Math.floor((J.y + De - J.radius) / _e) + 1), Ce.push(Math.floor((J.y + De + J.radius) / _e) + 1);
        break;
      case "qct":
        var Oe = rt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, J.x1, J.y1, J.x, J.y);
        Ce.push(Math.floor((Oe.y + De) / _e) + 1), Ce.push(Math.floor((Oe.y + Oe.h + De) / _e) + 1);
        break;
      case "bct":
        var qe = Ke(this.ctx.lastPoint.x, this.ctx.lastPoint.y, J.x1, J.y1, J.x2, J.y2, J.x, J.y);
        Ce.push(Math.floor((qe.y + De) / _e) + 1), Ce.push(Math.floor((qe.y + qe.h + De) / _e) + 1);
        break;
      case "rect":
        Ce.push(Math.floor((J.y + De) / _e) + 1), Ce.push(Math.floor((J.y + J.h + De) / _e) + 1);
    }
    for (var Ze = 0; Ze < Ce.length; Ze += 1) for (; this.pdf.internal.getNumberOfPages() < Ce[Ze]; ) se.call(this);
    return Ce;
  }, se = function() {
    var J = this.fillStyle, fe = this.strokeStyle, _e = this.font, Ce = this.lineCap, De = this.lineWidth, Oe = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = J, this.strokeStyle = fe, this.font = _e, this.lineCap = Ce, this.lineWidth = De, this.lineJoin = Oe;
  }, ge = function(J, fe, _e) {
    for (var Ce = 0; Ce < J.length; Ce++) switch (J[Ce].type) {
      case "bct":
        J[Ce].x2 += fe, J[Ce].y2 += _e;
      case "qct":
        J[Ce].x1 += fe, J[Ce].y1 += _e;
      case "mt":
      case "lt":
      case "arc":
      default:
        J[Ce].x += fe, J[Ce].y += _e;
    }
    return J;
  }, Me = function(J) {
    return J.sort(function(fe, _e) {
      return fe - _e;
    });
  }, Ye = function(J, fe) {
    for (var _e, Ce, De = this.fillStyle, Oe = this.strokeStyle, qe = this.lineCap, Ze = this.lineWidth, wt = Math.abs(Ze * this.ctx.transform.scaleX), bt = this.lineJoin, Tt = JSON.parse(JSON.stringify(this.path)), Mt = JSON.parse(JSON.stringify(this.path)), Qt = [], Qe = 0; Qe < Mt.length; Qe++) if (Mt[Qe].x !== void 0) for (var Y = ye.call(this, Mt[Qe]), ui = 0; ui < Y.length; ui += 1) Qt.indexOf(Y[ui]) === -1 && Qt.push(Y[ui]);
    for (var $t = 0; $t < Qt.length; $t++) for (; this.pdf.internal.getNumberOfPages() < Qt[$t]; ) se.call(this);
    if (Me(Qt), this.autoPaging) for (var at = Qt[0], yt = Qt[Qt.length - 1], zt = at; zt < yt + 1; zt++) {
      this.pdf.setPage(zt), this.fillStyle = De, this.strokeStyle = Oe, this.lineCap = qe, this.lineWidth = wt, this.lineJoin = bt;
      var Pt = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Gt = zt === 1 ? this.posY + this.margin[0] : this.margin[0], di = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], oi = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], bi = zt === 1 ? 0 : di + (zt - 2) * oi;
      if (this.ctx.clip_path.length !== 0) {
        var Ci = this.path;
        _e = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ge(_e, this.posX + this.margin[3], -bi + Gt + this.ctx.prevPageLastElemOffset), $e.call(this, J, !0), this.path = Ci;
      }
      if (Ce = JSON.parse(JSON.stringify(Tt)), this.path = ge(Ce, this.posX + this.margin[3], -bi + Gt + this.ctx.prevPageLastElemOffset), fe === !1 || zt === 0) {
        var lt = (zt > at || zt < yt) && ae.call(this);
        lt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Pt, oi, null).clip().discardPath()), $e.call(this, J, fe), lt && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Ze;
    }
    else this.lineWidth = wt, $e.call(this, J, fe), this.lineWidth = Ze;
    this.path = Tt;
  }, $e = function(J, fe) {
    if ((J !== "stroke" || fe || !de.call(this)) && (J === "stroke" || fe || !F.call(this))) {
      for (var _e, Ce, De = [], Oe = this.path, qe = 0; qe < Oe.length; qe++) {
        var Ze = Oe[qe];
        switch (Ze.type) {
          case "begin":
            De.push({ begin: !0 });
            break;
          case "close":
            De.push({ close: !0 });
            break;
          case "mt":
            De.push({ start: Ze, deltas: [], abs: [] });
            break;
          case "lt":
            var wt = De.length;
            if (Oe[qe - 1] && !isNaN(Oe[qe - 1].x) && (_e = [Ze.x - Oe[qe - 1].x, Ze.y - Oe[qe - 1].y], wt > 0)) {
              for (; wt >= 0; wt--) if (De[wt - 1].close !== !0 && De[wt - 1].begin !== !0) {
                De[wt - 1].deltas.push(_e), De[wt - 1].abs.push(Ze);
                break;
              }
            }
            break;
          case "bct":
            _e = [Ze.x1 - Oe[qe - 1].x, Ze.y1 - Oe[qe - 1].y, Ze.x2 - Oe[qe - 1].x, Ze.y2 - Oe[qe - 1].y, Ze.x - Oe[qe - 1].x, Ze.y - Oe[qe - 1].y], De[De.length - 1].deltas.push(_e);
            break;
          case "qct":
            var bt = Oe[qe - 1].x + 2 / 3 * (Ze.x1 - Oe[qe - 1].x), Tt = Oe[qe - 1].y + 2 / 3 * (Ze.y1 - Oe[qe - 1].y), Mt = Ze.x + 2 / 3 * (Ze.x1 - Ze.x), Qt = Ze.y + 2 / 3 * (Ze.y1 - Ze.y), Qe = Ze.x, Y = Ze.y;
            _e = [bt - Oe[qe - 1].x, Tt - Oe[qe - 1].y, Mt - Oe[qe - 1].x, Qt - Oe[qe - 1].y, Qe - Oe[qe - 1].x, Y - Oe[qe - 1].y], De[De.length - 1].deltas.push(_e);
            break;
          case "arc":
            De.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(De[De.length - 1].abs) && De[De.length - 1].abs.push(Ze);
        }
      }
      Ce = fe ? null : J === "stroke" ? "stroke" : "fill";
      for (var ui = !1, $t = 0; $t < De.length; $t++) if (De[$t].arc) for (var at = De[$t].abs, yt = 0; yt < at.length; yt++) {
        var zt = at[yt];
        zt.type === "arc" ? Ie.call(this, zt.x, zt.y, zt.radius, zt.startAngle, zt.endAngle, zt.counterclockwise, void 0, fe, !ui) : Le.call(this, zt.x, zt.y), ui = !0;
      }
      else if (De[$t].close === !0) this.pdf.internal.out("h"), ui = !1;
      else if (De[$t].begin !== !0) {
        var Pt = De[$t].start.x, Gt = De[$t].start.y;
        Se.call(this, De[$t].deltas, Pt, Gt), ui = !0;
      }
      Ce && ot.call(this, Ce), fe && it.call(this);
    }
  }, tt = function(J) {
    var fe = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, _e = fe * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return J - _e;
      case "top":
        return J + fe - _e;
      case "hanging":
        return J + fe - 2 * _e;
      case "middle":
        return J + fe / 2 - _e;
      case "ideographic":
        return J;
      case "alphabetic":
      default:
        return J;
    }
  }, Be = function(J) {
    return J + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  j.prototype.createLinearGradient = function() {
    var J = function() {
    };
    return J.colorStops = [], J.addColorStop = function(fe, _e) {
      this.colorStops.push([fe, _e]);
    }, J.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, J.isCanvasGradient = !0, J;
  }, j.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, j.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Ie = function(J, fe, _e, Ce, De, Oe, qe, Ze, wt) {
    for (var bt = We.call(this, _e, Ce, De, Oe), Tt = 0; Tt < bt.length; Tt++) {
      var Mt = bt[Tt];
      Tt === 0 && (wt ? oe.call(this, Mt.x1 + J, Mt.y1 + fe) : Le.call(this, Mt.x1 + J, Mt.y1 + fe)), He.call(this, J, fe, Mt.x2, Mt.y2, Mt.x3, Mt.y3, Mt.x4, Mt.y4);
    }
    Ze ? it.call(this) : ot.call(this, qe);
  }, ot = function(J) {
    switch (J) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, it = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, oe = function(J, fe) {
    this.pdf.internal.out(p(J) + " " + v(fe) + " m");
  }, le = function(J) {
    var fe;
    switch (J.align) {
      case "right":
      case "end":
        fe = "right";
        break;
      case "center":
        fe = "center";
        break;
      case "left":
      case "start":
      default:
        fe = "left";
    }
    var _e = this.pdf.getTextDimensions(J.text), Ce = tt.call(this, J.y), De = Be.call(this, Ce) - _e.h, Oe = this.ctx.transform.applyToPoint(new _(J.x, Ce)), qe = this.ctx.transform.decompose(), Ze = new C();
    Ze = (Ze = (Ze = Ze.multiply(qe.translate)).multiply(qe.skew)).multiply(qe.scale);
    for (var wt, bt, Tt, Mt = this.ctx.transform.applyToRectangle(new c(J.x, Ce, _e.w, _e.h)), Qt = Ze.applyToRectangle(new c(J.x, De, _e.w, _e.h)), Qe = ye.call(this, Qt), Y = [], ui = 0; ui < Qe.length; ui += 1) Y.indexOf(Qe[ui]) === -1 && Y.push(Qe[ui]);
    if (Me(Y), this.autoPaging) for (var $t = Y[0], at = Y[Y.length - 1], yt = $t; yt < at + 1; yt++) {
      this.pdf.setPage(yt);
      var zt = yt === 1 ? this.posY + this.margin[0] : this.margin[0], Pt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Gt = this.pdf.internal.pageSize.height - this.margin[2], di = Gt - this.margin[0], oi = this.pdf.internal.pageSize.width - this.margin[1], bi = oi - this.margin[3], Ci = yt === 1 ? 0 : Pt + (yt - 2) * di;
      if (this.ctx.clip_path.length !== 0) {
        var lt = this.path;
        wt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = ge(wt, this.posX + this.margin[3], -1 * Ci + zt), $e.call(this, "fill", !0), this.path = lt;
      }
      var ei = ge([JSON.parse(JSON.stringify(Qt))], this.posX + this.margin[3], -Ci + zt + this.ctx.prevPageLastElemOffset)[0];
      J.scale >= 0.01 && (bt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(bt * J.scale), Tt = this.lineWidth, this.lineWidth = Tt * J.scale);
      var ai = this.autoPaging !== "text";
      if (ai || ei.y + ei.h <= Gt) {
        if (ai || ei.y >= zt && ei.x <= oi) {
          var It = ai ? J.text : this.pdf.splitTextToSize(J.text, J.maxWidth || oi - ei.x)[0], cr = ge([JSON.parse(JSON.stringify(Mt))], this.posX + this.margin[3], -Ci + zt + this.ctx.prevPageLastElemOffset)[0], ct = ai && (yt > $t || yt < at) && ae.call(this);
          ct && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], bi, di, null).clip().discardPath()), this.pdf.text(It, cr.x, cr.y, { angle: J.angle, align: fe, renderingMode: J.renderingMode }), ct && this.pdf.restoreGraphicsState();
        }
      } else ei.y < Gt && (this.ctx.prevPageLastElemOffset += Gt - ei.y);
      J.scale >= 0.01 && (this.pdf.setFontSize(bt), this.lineWidth = Tt);
    }
    else J.scale >= 0.01 && (bt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(bt * J.scale), Tt = this.lineWidth, this.lineWidth = Tt * J.scale), this.pdf.text(J.text, Oe.x + this.posX, Oe.y + this.posY, { angle: J.angle, align: fe, renderingMode: J.renderingMode, maxWidth: J.maxWidth }), J.scale >= 0.01 && (this.pdf.setFontSize(bt), this.lineWidth = Tt);
  }, Le = function(J, fe, _e, Ce) {
    _e = _e || 0, Ce = Ce || 0, this.pdf.internal.out(p(J + _e) + " " + v(fe + Ce) + " l");
  }, Se = function(J, fe, _e) {
    return this.pdf.lines(J, fe, _e, null, null);
  }, He = function(J, fe, _e, Ce, De, Oe, qe, Ze) {
    this.pdf.internal.out([d(S(_e + J)), d(w(Ce + fe)), d(S(De + J)), d(w(Oe + fe)), d(S(qe + J)), d(w(Ze + fe)), "c"].join(" "));
  }, We = function(J, fe, _e, Ce) {
    for (var De = 2 * Math.PI, Oe = Math.PI / 2; fe > _e; ) fe -= De;
    var qe = Math.abs(_e - fe);
    qe < De && Ce && (qe = De - qe);
    for (var Ze = [], wt = Ce ? -1 : 1, bt = fe; qe > 1e-5; ) {
      var Tt = bt + wt * Math.min(qe, Oe);
      Ze.push(Je.call(this, J, bt, Tt)), qe -= Math.abs(Tt - bt), bt = Tt;
    }
    return Ze;
  }, Je = function(J, fe, _e) {
    var Ce = (_e - fe) / 2, De = J * Math.cos(Ce), Oe = J * Math.sin(Ce), qe = De, Ze = -Oe, wt = qe * qe + Ze * Ze, bt = wt + qe * De + Ze * Oe, Tt = 4 / 3 * (Math.sqrt(2 * wt * bt) - bt) / (qe * Oe - Ze * De), Mt = qe - Tt * Ze, Qt = Ze + Tt * qe, Qe = Mt, Y = -Qt, ui = Ce + fe, $t = Math.cos(ui), at = Math.sin(ui);
    return { x1: J * Math.cos(fe), y1: J * Math.sin(fe), x2: Mt * $t - Qt * at, y2: Mt * at + Qt * $t, x3: Qe * $t - Y * at, y3: Qe * at + Y * $t, x4: J * Math.cos(_e), y4: J * Math.sin(_e) };
  }, je = function(J) {
    return 180 * J / Math.PI;
  }, rt = function(J, fe, _e, Ce, De, Oe) {
    var qe = J + 0.5 * (_e - J), Ze = fe + 0.5 * (Ce - fe), wt = De + 0.5 * (_e - De), bt = Oe + 0.5 * (Ce - Oe), Tt = Math.min(J, De, qe, wt), Mt = Math.max(J, De, qe, wt), Qt = Math.min(fe, Oe, Ze, bt), Qe = Math.max(fe, Oe, Ze, bt);
    return new c(Tt, Qt, Mt - Tt, Qe - Qt);
  }, Ke = function(J, fe, _e, Ce, De, Oe, qe, Ze) {
    var wt, bt, Tt, Mt, Qt, Qe, Y, ui, $t, at, yt, zt, Pt, Gt, di = _e - J, oi = Ce - fe, bi = De - _e, Ci = Oe - Ce, lt = qe - De, ei = Ze - Oe;
    for (bt = 0; bt < 41; bt++) $t = (Y = (Tt = J + (wt = bt / 40) * di) + wt * ((Qt = _e + wt * bi) - Tt)) + wt * (Qt + wt * (De + wt * lt - Qt) - Y), at = (ui = (Mt = fe + wt * oi) + wt * ((Qe = Ce + wt * Ci) - Mt)) + wt * (Qe + wt * (Oe + wt * ei - Qe) - ui), bt == 0 ? (yt = $t, zt = at, Pt = $t, Gt = at) : (yt = Math.min(yt, $t), zt = Math.min(zt, at), Pt = Math.max(Pt, $t), Gt = Math.max(Gt, at));
    return new c(Math.round(yt), Math.round(zt), Math.round(Pt - yt), Math.round(Gt - zt));
  }, St = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var J, fe, _e = (J = this.ctx.lineDash, fe = this.ctx.lineDashOffset, JSON.stringify({ lineDash: J, lineDashOffset: fe }));
      this.prevLineDash !== _e && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = _e);
    }
  };
})(yi.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = function(w) {
    var _, c, C, N, q, j, V, F, de, ae;
    for (c = [], C = 0, N = (w += _ = "\0\0\0\0".slice(w.length % 4 || 4)).length; N > C; C += 4) (q = (w.charCodeAt(C) << 24) + (w.charCodeAt(C + 1) << 16) + (w.charCodeAt(C + 2) << 8) + w.charCodeAt(C + 3)) !== 0 ? (j = (q = ((q = ((q = ((q = (q - (ae = q % 85)) / 85) - (de = q % 85)) / 85) - (F = q % 85)) / 85) - (V = q % 85)) / 85) % 85, c.push(j + 33, V + 33, F + 33, de + 33, ae + 33)) : c.push(122);
    return function(ye, se) {
      for (var ge = se; ge > 0; ge--) ye.pop();
    }(c, _.length), String.fromCharCode.apply(String, c) + "~>";
  }, p = function(w) {
    var _, c, C, N, q, j = String, V = "length", F = 255, de = "charCodeAt", ae = "slice", ye = "replace";
    for (w[ae](-2), w = w[ae](0, -2)[ye](/\s/g, "")[ye]("z", "!!!!!"), C = [], N = 0, q = (w += _ = "uuuuu"[ae](w[V] % 5 || 5))[V]; q > N; N += 5) c = 52200625 * (w[de](N) - 33) + 614125 * (w[de](N + 1) - 33) + 7225 * (w[de](N + 2) - 33) + 85 * (w[de](N + 3) - 33) + (w[de](N + 4) - 33), C.push(F & c >> 24, F & c >> 16, F & c >> 8, F & c);
    return function(se, ge) {
      for (var Me = ge; Me > 0; Me--) se.pop();
    }(C, _[V]), j.fromCharCode.apply(j, C);
  }, v = function(w) {
    var _ = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((w = w.replace(/\s/g, "")).indexOf(">") !== -1 && (w = w.substr(0, w.indexOf(">"))), w.length % 2 && (w += "0"), _.test(w) === !1) return "";
    for (var c = "", C = 0; C < w.length; C += 2) c += String.fromCharCode("0x" + (w[C] + w[C + 1]));
    return c;
  }, S = function(w) {
    for (var _ = new Uint8Array(w.length), c = w.length; c--; ) _[c] = w.charCodeAt(c);
    return w = (_ = ad(_)).reduce(function(C, N) {
      return C + String.fromCharCode(N);
    }, "");
  };
  x.processDataByFilters = function(w, _) {
    var c = 0, C = w || "", N = [];
    for (typeof (_ = _ || []) == "string" && (_ = [_]), c = 0; c < _.length; c += 1) switch (_[c]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        C = p(C), N.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        C = d(C), N.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        C = v(C), N.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        C = C.split("").map(function(q) {
          return ("0" + q.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", N.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        C = S(C), N.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + _[c] + '" is not implemented');
    }
    return { data: C, reverseChain: N.reverse().join(" ") };
  };
}(yi.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.loadFile = function(d, p, v) {
    return function(S, w, _) {
      w = w !== !1, _ = typeof _ == "function" ? _ : function() {
      };
      var c = void 0;
      try {
        c = function(C, N, q) {
          var j = new XMLHttpRequest(), V = 0, F = function(de) {
            var ae = de.length, ye = [], se = String.fromCharCode;
            for (V = 0; V < ae; V += 1) ye.push(se(255 & de.charCodeAt(V)));
            return ye.join("");
          };
          if (j.open("GET", C, !N), j.overrideMimeType("text/plain; charset=x-user-defined"), N === !1 && (j.onload = function() {
            j.status === 200 ? q(F(this.responseText)) : q(void 0);
          }), j.send(null), N && j.status === 200) return F(j.responseText);
        }(S, w, _);
      } catch {
      }
      return c;
    }(d, p, v);
  }, x.loadImageFile = x.loadFile;
}(yi.API), function(x) {
  function d() {
    return (_i.html2canvas ? Promise.resolve(_i.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.js")).catch(function(_) {
      return Promise.reject(new Error("Could not load html2canvas: " + _));
    }).then(function(_) {
      return _.default ? _.default : _;
    });
  }
  function p() {
    return (_i.DOMPurify ? Promise.resolve(_i.DOMPurify) : import("./purify.es-BwOkayRK--f1u9f-k.js")).catch(function(_) {
      return Promise.reject(new Error("Could not load dompurify: " + _));
    }).then(function(_) {
      return _.default ? _.default : _;
    });
  }
  var v = function(_) {
    var c = rr(_);
    return c === "undefined" ? "undefined" : c === "string" || _ instanceof String ? "string" : c === "number" || _ instanceof Number ? "number" : c === "function" || _ instanceof Function ? "function" : _ && _.constructor === Array ? "array" : _ && _.nodeType === 1 ? "element" : c === "object" ? "object" : "unknown";
  }, S = function(_, c) {
    var C = document.createElement(_);
    for (var N in c.className && (C.className = c.className), c.innerHTML && c.dompurify && (C.innerHTML = c.dompurify.sanitize(c.innerHTML)), c.style) C.style[N] = c.style[N];
    return C;
  }, w = function _(c) {
    var C = Object.assign(_.convert(Promise.resolve()), JSON.parse(JSON.stringify(_.template))), N = _.convert(Promise.resolve(), C);
    return N = (N = N.setProgress(1, _, 1, [_])).set(c);
  };
  (w.prototype = Object.create(Promise.prototype)).constructor = w, w.convert = function(_, c) {
    return _.__proto__ = c || w.prototype, _;
  }, w.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, w.prototype.from = function(_, c) {
    return this.then(function() {
      switch (c = c || function(C) {
        switch (v(C)) {
          case "string":
            return "string";
          case "element":
            return C.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(_)) {
        case "string":
          return this.then(p).then(function(C) {
            return this.set({ src: S("div", { innerHTML: _, dompurify: C }) });
          });
        case "element":
          return this.set({ src: _ });
        case "canvas":
          return this.set({ canvas: _ });
        case "img":
          return this.set({ img: _ });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, w.prototype.to = function(_) {
    switch (_) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, w.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var _ = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, c = function C(N, q) {
        for (var j = N.nodeType === 3 ? document.createTextNode(N.nodeValue) : N.cloneNode(!1), V = N.firstChild; V; V = V.nextSibling) q !== !0 && V.nodeType === 1 && V.nodeName === "SCRIPT" || j.appendChild(C(V, q));
        return N.nodeType === 1 && (N.nodeName === "CANVAS" ? (j.width = N.width, j.height = N.height, j.getContext("2d").drawImage(N, 0, 0)) : N.nodeName !== "TEXTAREA" && N.nodeName !== "SELECT" || (j.value = N.value), j.addEventListener("load", function() {
          j.scrollTop = N.scrollTop, j.scrollLeft = N.scrollLeft;
        }, !0)), j;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      c.tagName === "BODY" && (_.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = S("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = S("div", { className: "html2pdf__container", style: _ }), this.prop.container.appendChild(c), this.prop.container.firstChild.appendChild(S("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, w.prototype.toCanvas = function() {
    var _ = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(_).then(d).then(function(c) {
      var C = Object.assign({}, this.opt.html2canvas);
      return delete C.onrendered, c(this.prop.container, C);
    }).then(function(c) {
      (this.opt.html2canvas.onrendered || function() {
      })(c), this.prop.canvas = c, document.body.removeChild(this.prop.overlay);
    });
  }, w.prototype.toContext2d = function() {
    var _ = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(_).then(d).then(function(c) {
      var C = this.opt.jsPDF, N = this.opt.fontFaces, q = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, j = Object.assign({ async: !0, allowTaint: !0, scale: q, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete j.onrendered, C.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, C.context2d.posX = this.opt.x, C.context2d.posY = this.opt.y, C.context2d.margin = this.opt.margin, C.context2d.fontFaces = N, N) for (var V = 0; V < N.length; ++V) {
        var F = N[V], de = F.src.find(function(ae) {
          return ae.format === "truetype";
        });
        de && C.addFont(de.url, F.ref.name, F.ref.style);
      }
      return j.windowHeight = j.windowHeight || 0, j.windowHeight = j.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : j.windowHeight, C.context2d.save(!0), c(this.prop.container, j);
    }).then(function(c) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(c), this.prop.canvas = c, document.body.removeChild(this.prop.overlay);
    });
  }, w.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var _ = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = _;
    });
  }, w.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, w.prototype.output = function(_, c, C) {
    return (C = C || "pdf").toLowerCase() === "img" || C.toLowerCase() === "image" ? this.outputImg(_, c) : this.outputPdf(_, c);
  }, w.prototype.outputPdf = function(_, c) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(_, c);
    });
  }, w.prototype.outputImg = function(_) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (_) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + _ + '" is not supported.';
      }
    });
  }, w.prototype.save = function(_) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(_ ? { filename: _ } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, w.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, w.prototype.set = function(_) {
    if (v(_) !== "object") return this;
    var c = Object.keys(_ || {}).map(function(C) {
      if (C in w.template.prop) return function() {
        this.prop[C] = _[C];
      };
      switch (C) {
        case "margin":
          return this.setMargin.bind(this, _.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = _.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, _.pageSize);
        default:
          return function() {
            this.opt[C] = _[C];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(c);
    });
  }, w.prototype.get = function(_, c) {
    return this.then(function() {
      var C = _ in w.template.prop ? this.prop[_] : this.opt[_];
      return c ? c(C) : C;
    });
  }, w.prototype.setMargin = function(_) {
    return this.then(function() {
      switch (v(_)) {
        case "number":
          _ = [_, _, _, _];
        case "array":
          if (_.length === 2 && (_ = [_[0], _[1], _[0], _[1]]), _.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = _;
    }).then(this.setPageSize);
  }, w.prototype.setPageSize = function(_) {
    function c(C, N) {
      return Math.floor(C * N / 72 * 96);
    }
    return this.then(function() {
      (_ = _ || yi.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (_.inner = { width: _.width - this.opt.margin[1] - this.opt.margin[3], height: _.height - this.opt.margin[0] - this.opt.margin[2] }, _.inner.px = { width: c(_.inner.width, _.k), height: c(_.inner.height, _.k) }, _.inner.ratio = _.inner.height / _.inner.width), this.prop.pageSize = _;
    });
  }, w.prototype.setProgress = function(_, c, C, N) {
    return _ != null && (this.progress.val = _), c != null && (this.progress.state = c), C != null && (this.progress.n = C), N != null && (this.progress.stack = N), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, w.prototype.updateProgress = function(_, c, C, N) {
    return this.setProgress(_ ? this.progress.val + _ : null, c || null, C ? this.progress.n + C : null, N ? this.progress.stack.concat(N) : null);
  }, w.prototype.then = function(_, c) {
    var C = this;
    return this.thenCore(_, c, function(N, q) {
      return C.updateProgress(null, null, 1, [N]), Promise.prototype.then.call(this, function(j) {
        return C.updateProgress(null, N), j;
      }).then(N, q).then(function(j) {
        return C.updateProgress(1), j;
      });
    });
  }, w.prototype.thenCore = function(_, c, C) {
    C = C || Promise.prototype.then, _ && (_ = _.bind(this)), c && (c = c.bind(this));
    var N = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : w.convert(Object.assign({}, this), Promise.prototype), q = C.call(N, _, c);
    return w.convert(q, this.__proto__);
  }, w.prototype.thenExternal = function(_, c) {
    return Promise.prototype.then.call(this, _, c);
  }, w.prototype.thenList = function(_) {
    var c = this;
    return _.forEach(function(C) {
      c = c.thenCore(C);
    }), c;
  }, w.prototype.catch = function(_) {
    _ && (_ = _.bind(this));
    var c = Promise.prototype.catch.call(this, _);
    return w.convert(c, this);
  }, w.prototype.catchExternal = function(_) {
    return Promise.prototype.catch.call(this, _);
  }, w.prototype.error = function(_) {
    return this.then(function() {
      throw new Error(_);
    });
  }, w.prototype.using = w.prototype.set, w.prototype.saveAs = w.prototype.save, w.prototype.export = w.prototype.output, w.prototype.run = w.prototype.then, yi.getPageSize = function(_, c, C) {
    if (rr(_) === "object") {
      var N = _;
      _ = N.orientation, c = N.unit || c, C = N.format || C;
    }
    c = c || "mm", C = C || "a4", _ = ("" + (_ || "P")).toLowerCase();
    var q, j = ("" + C).toLowerCase(), V = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (c) {
      case "pt":
        q = 1;
        break;
      case "mm":
        q = 72 / 25.4;
        break;
      case "cm":
        q = 72 / 2.54;
        break;
      case "in":
        q = 72;
        break;
      case "px":
        q = 0.75;
        break;
      case "pc":
      case "em":
        q = 12;
        break;
      case "ex":
        q = 6;
        break;
      default:
        throw "Invalid unit: " + c;
    }
    var F, de = 0, ae = 0;
    if (V.hasOwnProperty(j)) de = V[j][1] / q, ae = V[j][0] / q;
    else try {
      de = C[1], ae = C[0];
    } catch {
      throw new Error("Invalid format: " + C);
    }
    if (_ === "p" || _ === "portrait") _ = "p", ae > de && (F = ae, ae = de, de = F);
    else {
      if (_ !== "l" && _ !== "landscape") throw "Invalid orientation: " + _;
      _ = "l", de > ae && (F = ae, ae = de, de = F);
    }
    return { width: ae, height: de, unit: c, k: q, orientation: _ };
  }, x.html = function(_, c) {
    (c = c || {}).callback = c.callback || function() {
    }, c.html2canvas = c.html2canvas || {}, c.html2canvas.canvas = c.html2canvas.canvas || this.canvas, c.jsPDF = c.jsPDF || this, c.fontFaces = c.fontFaces ? c.fontFaces.map(pd) : null;
    var C = new w(c);
    return c.worker ? C : C.from(_).doCallback();
  };
}(yi.API), yi.API.addJS = function(x) {
  return af = x, this.internal.events.subscribe("postPutResources", function() {
    qh = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (qh + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), of = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + af + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    qh !== void 0 && of !== void 0 && this.internal.out("/Names <</JavaScript " + qh + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d;
  x.events.push(["postPutResources", function() {
    var p = this, v = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var S = p.outline.render().split(/\r\n/), w = 0; w < S.length; w++) {
      var _ = S[w], c = v.exec(_);
      if (c != null) {
        var C = c[1];
        p.internal.newObjectDeferredBegin(C, !1);
      }
      p.internal.write(_);
    }
    if (this.outline.createNamedDestinations) {
      var N = this.internal.pages.length, q = [];
      for (w = 0; w < N; w++) {
        var j = p.internal.newObject();
        q.push(j);
        var V = p.internal.getPageInfo(w + 1);
        p.internal.write("<< /D[" + V.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var F = p.internal.newObject();
      for (p.internal.write("<< /Names [ "), w = 0; w < q.length; w++) p.internal.write("(page_" + (w + 1) + ")" + q[w] + " 0 R");
      p.internal.write(" ] >>", "endobj"), d = p.internal.newObject(), p.internal.write("<< /Dests " + F + " 0 R"), p.internal.write(">>", "endobj");
    }
  }]), x.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + d + " 0 R"));
  }]), x.events.push(["initialized", function() {
    var p = this;
    p.outline = { createNamedDestinations: !1, root: { children: [] } }, p.outline.add = function(v, S, w) {
      var _ = { title: S, options: w, children: [] };
      return v == null && (v = this.root), v.children.push(_), _;
    }, p.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = p, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, p.outline.genIds_r = function(v) {
      v.id = p.internal.newObjectDeferred();
      for (var S = 0; S < v.children.length; S++) this.genIds_r(v.children[S]);
    }, p.outline.renderRoot = function(v) {
      this.objStart(v), this.line("/Type /Outlines"), v.children.length > 0 && (this.line("/First " + this.makeRef(v.children[0])), this.line("/Last " + this.makeRef(v.children[v.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, v)), this.objEnd();
    }, p.outline.renderItems = function(v) {
      for (var S = this.ctx.pdf.internal.getVerticalCoordinateString, w = 0; w < v.children.length; w++) {
        var _ = v.children[w];
        this.objStart(_), this.line("/Title " + this.makeString(_.title)), this.line("/Parent " + this.makeRef(v)), w > 0 && this.line("/Prev " + this.makeRef(v.children[w - 1])), w < v.children.length - 1 && this.line("/Next " + this.makeRef(v.children[w + 1])), _.children.length > 0 && (this.line("/First " + this.makeRef(_.children[0])), this.line("/Last " + this.makeRef(_.children[_.children.length - 1])));
        var c = this.count = this.count_r({ count: 0 }, _);
        if (c > 0 && this.line("/Count " + c), _.options && _.options.pageNumber) {
          var C = p.internal.getPageInfo(_.options.pageNumber);
          this.line("/Dest [" + C.objId + " 0 R /XYZ 0 " + S(0) + " 0]");
        }
        this.objEnd();
      }
      for (var N = 0; N < v.children.length; N++) this.renderItems(v.children[N]);
    }, p.outline.line = function(v) {
      this.ctx.val += v + `\r
`;
    }, p.outline.makeRef = function(v) {
      return v.id + " 0 R";
    }, p.outline.makeString = function(v) {
      return "(" + p.internal.pdfEscape(v) + ")";
    }, p.outline.objStart = function(v) {
      this.ctx.val += `\r
` + v.id + ` 0 obj\r
<<\r
`;
    }, p.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, p.outline.count_r = function(v, S) {
      for (var w = 0; w < S.children.length; w++) v.count++, this.count_r(v, S.children[w]);
      return v.count;
    };
  }]);
}(yi.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = [192, 193, 194, 195, 196, 197, 198, 199];
  x.processJPEG = function(p, v, S, w, _, c) {
    var C, N = this.decode.DCT_DECODE, q = null;
    if (typeof p == "string" || this.__addimage__.isArrayBuffer(p) || this.__addimage__.isArrayBufferView(p)) {
      switch (p = _ || p, p = this.__addimage__.isArrayBuffer(p) ? new Uint8Array(p) : p, (C = function(j) {
        for (var V, F = 256 * j.charCodeAt(4) + j.charCodeAt(5), de = j.length, ae = { width: 0, height: 0, numcomponents: 1 }, ye = 4; ye < de; ye += 2) {
          if (ye += F, d.indexOf(j.charCodeAt(ye + 1)) !== -1) {
            V = 256 * j.charCodeAt(ye + 5) + j.charCodeAt(ye + 6), ae = { width: 256 * j.charCodeAt(ye + 7) + j.charCodeAt(ye + 8), height: V, numcomponents: j.charCodeAt(ye + 9) };
            break;
          }
          F = 256 * j.charCodeAt(ye + 2) + j.charCodeAt(ye + 3);
        }
        return ae;
      }(p = this.__addimage__.isArrayBufferView(p) ? this.__addimage__.arrayBufferToBinaryString(p) : p)).numcomponents) {
        case 1:
          c = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          c = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          c = this.color_spaces.DEVICE_RGB;
      }
      q = { data: p, width: C.width, height: C.height, colorSpace: c, bitsPerComponent: 8, filter: N, index: v, alias: S };
    }
    return q;
  };
}(yi.API);
var Cc, Vh, cf, hf, uf, O0 = function() {
  var x, d, p;
  function v(w) {
    var _, c, C, N, q, j, V, F, de, ae, ye, se, ge, Me;
    for (this.data = w, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, j = null; ; ) {
      switch (_ = this.readUInt32(), de = (function() {
        var Ye, $e;
        for ($e = [], Ye = 0; Ye < 4; ++Ye) $e.push(String.fromCharCode(this.data[this.pos++]));
        return $e;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(_);
          break;
        case "fcTL":
          j && this.animation.frames.push(j), this.pos += 4, j = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, q = this.readUInt16(), N = this.readUInt16() || 100, j.delay = 1e3 * q / N, j.disposeOp = this.data[this.pos++], j.blendOp = this.data[this.pos++], j.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (de === "fdAT" && (this.pos += 4, _ -= 4), w = (j != null ? j.data : void 0) || this.imgData, se = 0; 0 <= _ ? se < _ : se > _; 0 <= _ ? ++se : --se) w.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (C = this.palette.length / 3, this.transparency.indexed = this.read(_), this.transparency.indexed.length > C) throw new Error("More transparent colors than palette size");
              if ((ae = C - this.transparency.indexed.length) > 0) for (ge = 0; 0 <= ae ? ge < ae : ge > ae; 0 <= ae ? ++ge : --ge) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(_)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(_);
          }
          break;
        case "tEXt":
          V = (ye = this.read(_)).indexOf(0), F = String.fromCharCode.apply(String, ye.slice(0, V)), this.text[F] = String.fromCharCode.apply(String, ye.slice(V + 1));
          break;
        case "IEND":
          return j && this.animation.frames.push(j), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (Me = this.colorType) === 4 || Me === 6, c = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * c, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += _;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  v.prototype.read = function(w) {
    var _, c;
    for (c = [], _ = 0; 0 <= w ? _ < w : _ > w; 0 <= w ? ++_ : --_) c.push(this.data[this.pos++]);
    return c;
  }, v.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, v.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, v.prototype.decodePixels = function(w) {
    var _ = this.pixelBitlength / 8, c = new Uint8Array(this.width * this.height * _), C = 0, N = this;
    if (w == null && (w = this.imgData), w.length === 0) return new Uint8Array(0);
    function q(j, V, F, de) {
      var ae, ye, se, ge, Me, Ye, $e, tt, Be, Ie, ot, it, oe, le, Le, Se, He, We, Je, je, rt, Ke = Math.ceil((N.width - j) / F), St = Math.ceil((N.height - V) / de), J = N.width == Ke && N.height == St;
      for (le = _ * Ke, it = J ? c : new Uint8Array(le * St), Ye = w.length, oe = 0, ye = 0; oe < St && C < Ye; ) {
        switch (w[C++]) {
          case 0:
            for (ge = He = 0; He < le; ge = He += 1) it[ye++] = w[C++];
            break;
          case 1:
            for (ge = We = 0; We < le; ge = We += 1) ae = w[C++], Me = ge < _ ? 0 : it[ye - _], it[ye++] = (ae + Me) % 256;
            break;
          case 2:
            for (ge = Je = 0; Je < le; ge = Je += 1) ae = w[C++], se = (ge - ge % _) / _, Le = oe && it[(oe - 1) * le + se * _ + ge % _], it[ye++] = (Le + ae) % 256;
            break;
          case 3:
            for (ge = je = 0; je < le; ge = je += 1) ae = w[C++], se = (ge - ge % _) / _, Me = ge < _ ? 0 : it[ye - _], Le = oe && it[(oe - 1) * le + se * _ + ge % _], it[ye++] = (ae + Math.floor((Me + Le) / 2)) % 256;
            break;
          case 4:
            for (ge = rt = 0; rt < le; ge = rt += 1) ae = w[C++], se = (ge - ge % _) / _, Me = ge < _ ? 0 : it[ye - _], oe === 0 ? Le = Se = 0 : (Le = it[(oe - 1) * le + se * _ + ge % _], Se = se && it[(oe - 1) * le + (se - 1) * _ + ge % _]), $e = Me + Le - Se, tt = Math.abs($e - Me), Ie = Math.abs($e - Le), ot = Math.abs($e - Se), Be = tt <= Ie && tt <= ot ? Me : Ie <= ot ? Le : Se, it[ye++] = (ae + Be) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + w[C - 1]);
        }
        if (!J) {
          var fe = ((V + oe * de) * N.width + j) * _, _e = oe * le;
          for (ge = 0; ge < Ke; ge += 1) {
            for (var Ce = 0; Ce < _; Ce += 1) c[fe++] = it[_e++];
            fe += (F - 1) * _;
          }
        }
        oe++;
      }
    }
    return w = v0(w), N.interlaceMethod == 1 ? (q(0, 0, 8, 8), q(4, 0, 8, 8), q(0, 4, 4, 8), q(2, 0, 4, 4), q(0, 2, 2, 4), q(1, 0, 2, 2), q(0, 1, 1, 2)) : q(0, 0, 1, 1), c;
  }, v.prototype.decodePalette = function() {
    var w, _, c, C, N, q, j, V, F;
    for (c = this.palette, q = this.transparency.indexed || [], N = new Uint8Array((q.length || 0) + c.length), C = 0, w = 0, _ = j = 0, V = c.length; j < V; _ = j += 3) N[C++] = c[_], N[C++] = c[_ + 1], N[C++] = c[_ + 2], N[C++] = (F = q[w++]) != null ? F : 255;
    return N;
  }, v.prototype.copyToImageData = function(w, _) {
    var c, C, N, q, j, V, F, de, ae, ye, se;
    if (C = this.colors, ae = null, c = this.hasAlphaChannel, this.palette.length && (ae = (se = this._decodedPalette) != null ? se : this._decodedPalette = this.decodePalette(), C = 4, c = !0), de = (N = w.data || w).length, j = ae || _, q = V = 0, C === 1) for (; q < de; ) F = ae ? 4 * _[q / 4] : V, ye = j[F++], N[q++] = ye, N[q++] = ye, N[q++] = ye, N[q++] = c ? j[F++] : 255, V = F;
    else for (; q < de; ) F = ae ? 4 * _[q / 4] : V, N[q++] = j[F++], N[q++] = j[F++], N[q++] = j[F++], N[q++] = c ? j[F++] : 255, V = F;
  }, v.prototype.decode = function() {
    var w;
    return w = new Uint8Array(this.width * this.height * 4), this.copyToImageData(w, this.decodePixels()), w;
  };
  var S = function() {
    if (Object.prototype.toString.call(_i) === "[object Window]") {
      try {
        d = _i.document.createElement("canvas"), p = d.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return S(), x = function(w) {
    var _;
    if (S() === !0) return p.width = w.width, p.height = w.height, p.clearRect(0, 0, w.width, w.height), p.putImageData(w, 0, 0), (_ = new Image()).src = d.toDataURL(), _;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, v.prototype.decodeFrames = function(w) {
    var _, c, C, N, q, j, V, F;
    if (this.animation) {
      for (F = [], c = q = 0, j = (V = this.animation.frames).length; q < j; c = ++q) _ = V[c], C = w.createImageData(_.width, _.height), N = this.decodePixels(new Uint8Array(_.data)), this.copyToImageData(C, N), _.imageData = C, F.push(_.image = x(C));
      return F;
    }
  }, v.prototype.renderFrame = function(w, _) {
    var c, C, N;
    return c = (C = this.animation.frames)[_], N = C[_ - 1], _ === 0 && w.clearRect(0, 0, this.width, this.height), (N != null ? N.disposeOp : void 0) === 1 ? w.clearRect(N.xOffset, N.yOffset, N.width, N.height) : (N != null ? N.disposeOp : void 0) === 2 && w.putImageData(N.imageData, N.xOffset, N.yOffset), c.blendOp === 0 && w.clearRect(c.xOffset, c.yOffset, c.width, c.height), w.drawImage(c.image, c.xOffset, c.yOffset);
  }, v.prototype.animate = function(w) {
    var _, c, C, N, q, j, V = this;
    return c = 0, j = this.animation, N = j.numFrames, C = j.frames, q = j.numPlays, (_ = function() {
      var F, de;
      if (F = c++ % N, de = C[F], V.renderFrame(w, F), N > 1 && c / N < q) return V.animation._timeout = setTimeout(_, de.delay);
    })();
  }, v.prototype.stopAnimation = function() {
    var w;
    return clearTimeout((w = this.animation) != null ? w._timeout : void 0);
  }, v.prototype.render = function(w) {
    var _, c;
    return w._png && w._png.stopAnimation(), w._png = this, w.width = this.width, w.height = this.height, _ = w.getContext("2d"), this.animation ? (this.decodeFrames(_), this.animate(_)) : (c = _.createImageData(this.width, this.height), this.copyToImageData(c, this.decodePixels()), _.putImageData(c, 0, 0));
  }, v;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function j0(x) {
  var d = 0;
  if (x[d++] !== 71 || x[d++] !== 73 || x[d++] !== 70 || x[d++] !== 56 || (x[d++] + 1 & 253) != 56 || x[d++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var p = x[d++] | x[d++] << 8, v = x[d++] | x[d++] << 8, S = x[d++], w = S >> 7, _ = 1 << (7 & S) + 1;
  x[d++], x[d++];
  var c = null, C = null;
  w && (c = d, C = _, d += 3 * _);
  var N = !0, q = [], j = 0, V = null, F = 0, de = null;
  for (this.width = p, this.height = v; N && d < x.length; ) switch (x[d++]) {
    case 33:
      switch (x[d++]) {
        case 255:
          if (x[d] !== 11 || x[d + 1] == 78 && x[d + 2] == 69 && x[d + 3] == 84 && x[d + 4] == 83 && x[d + 5] == 67 && x[d + 6] == 65 && x[d + 7] == 80 && x[d + 8] == 69 && x[d + 9] == 50 && x[d + 10] == 46 && x[d + 11] == 48 && x[d + 12] == 3 && x[d + 13] == 1 && x[d + 16] == 0) d += 14, de = x[d++] | x[d++] << 8, d++;
          else for (d += 12; ; ) {
            if (!((oe = x[d++]) >= 0)) throw Error("Invalid block size");
            if (oe === 0) break;
            d += oe;
          }
          break;
        case 249:
          if (x[d++] !== 4 || x[d + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var ae = x[d++];
          j = x[d++] | x[d++] << 8, V = x[d++], !(1 & ae) && (V = null), F = ae >> 2 & 7, d++;
          break;
        case 254:
          for (; ; ) {
            if (!((oe = x[d++]) >= 0)) throw Error("Invalid block size");
            if (oe === 0) break;
            d += oe;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + x[d - 1].toString(16));
      }
      break;
    case 44:
      var ye = x[d++] | x[d++] << 8, se = x[d++] | x[d++] << 8, ge = x[d++] | x[d++] << 8, Me = x[d++] | x[d++] << 8, Ye = x[d++], $e = Ye >> 6 & 1, tt = 1 << (7 & Ye) + 1, Be = c, Ie = C, ot = !1;
      Ye >> 7 && (ot = !0, Be = d, Ie = tt, d += 3 * tt);
      var it = d;
      for (d++; ; ) {
        var oe;
        if (!((oe = x[d++]) >= 0)) throw Error("Invalid block size");
        if (oe === 0) break;
        d += oe;
      }
      q.push({ x: ye, y: se, width: ge, height: Me, has_local_palette: ot, palette_offset: Be, palette_size: Ie, data_offset: it, data_length: d - it, transparent_index: V, interlaced: !!$e, delay: j, disposal: F });
      break;
    case 59:
      N = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + x[d - 1].toString(16));
  }
  this.numFrames = function() {
    return q.length;
  }, this.loopCount = function() {
    return de;
  }, this.frameInfo = function(le) {
    if (le < 0 || le >= q.length) throw new Error("Frame index out of range.");
    return q[le];
  }, this.decodeAndBlitFrameBGRA = function(le, Le) {
    var Se = this.frameInfo(le), He = Se.width * Se.height, We = new Uint8Array(He);
    df(x, Se.data_offset, We, He);
    var Je = Se.palette_offset, je = Se.transparent_index;
    je === null && (je = 256);
    var rt = Se.width, Ke = p - rt, St = rt, J = 4 * (Se.y * p + Se.x), fe = 4 * ((Se.y + Se.height) * p + Se.x), _e = J, Ce = 4 * Ke;
    Se.interlaced === !0 && (Ce += 4 * p * 7);
    for (var De = 8, Oe = 0, qe = We.length; Oe < qe; ++Oe) {
      var Ze = We[Oe];
      if (St === 0 && (St = rt, (_e += Ce) >= fe && (Ce = 4 * Ke + 4 * p * (De - 1), _e = J + (rt + Ke) * (De << 1), De >>= 1)), Ze === je) _e += 4;
      else {
        var wt = x[Je + 3 * Ze], bt = x[Je + 3 * Ze + 1], Tt = x[Je + 3 * Ze + 2];
        Le[_e++] = Tt, Le[_e++] = bt, Le[_e++] = wt, Le[_e++] = 255;
      }
      --St;
    }
  }, this.decodeAndBlitFrameRGBA = function(le, Le) {
    var Se = this.frameInfo(le), He = Se.width * Se.height, We = new Uint8Array(He);
    df(x, Se.data_offset, We, He);
    var Je = Se.palette_offset, je = Se.transparent_index;
    je === null && (je = 256);
    var rt = Se.width, Ke = p - rt, St = rt, J = 4 * (Se.y * p + Se.x), fe = 4 * ((Se.y + Se.height) * p + Se.x), _e = J, Ce = 4 * Ke;
    Se.interlaced === !0 && (Ce += 4 * p * 7);
    for (var De = 8, Oe = 0, qe = We.length; Oe < qe; ++Oe) {
      var Ze = We[Oe];
      if (St === 0 && (St = rt, (_e += Ce) >= fe && (Ce = 4 * Ke + 4 * p * (De - 1), _e = J + (rt + Ke) * (De << 1), De >>= 1)), Ze === je) _e += 4;
      else {
        var wt = x[Je + 3 * Ze], bt = x[Je + 3 * Ze + 1], Tt = x[Je + 3 * Ze + 2];
        Le[_e++] = wt, Le[_e++] = bt, Le[_e++] = Tt, Le[_e++] = 255;
      }
      --St;
    }
  };
}
function df(x, d, p, v) {
  for (var S = x[d++], w = 1 << S, _ = w + 1, c = _ + 1, C = S + 1, N = (1 << C) - 1, q = 0, j = 0, V = 0, F = x[d++], de = new Int32Array(4096), ae = null; ; ) {
    for (; q < 16 && F !== 0; ) j |= x[d++] << q, q += 8, F === 1 ? F = x[d++] : --F;
    if (q < C) break;
    var ye = j & N;
    if (j >>= C, q -= C, ye !== w) {
      if (ye === _) break;
      for (var se = ye < c ? ye : ae, ge = 0, Me = se; Me > w; ) Me = de[Me] >> 8, ++ge;
      var Ye = Me;
      if (V + ge + (se !== ye ? 1 : 0) > v) return void pr.log("Warning, gif stream longer than expected.");
      p[V++] = Ye;
      var $e = V += ge;
      for (se !== ye && (p[V++] = Ye), Me = se; ge--; ) Me = de[Me], p[--$e] = 255 & Me, Me >>= 8;
      ae !== null && c < 4096 && (de[c++] = ae << 8 | Ye, c >= N + 1 && C < 12 && (++C, N = N << 1 | 1)), ae = ye;
    } else c = _ + 1, N = (1 << (C = S + 1)) - 1, ae = null;
  }
  return V !== v && pr.log("Warning, gif stream shorter than expected."), p;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Ku(x) {
  var d, p, v, S, w, _ = Math.floor, c = new Array(64), C = new Array(64), N = new Array(64), q = new Array(64), j = new Array(65535), V = new Array(65535), F = new Array(64), de = new Array(64), ae = [], ye = 0, se = 7, ge = new Array(64), Me = new Array(64), Ye = new Array(64), $e = new Array(256), tt = new Array(2048), Be = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Ie = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], ot = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], it = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], oe = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], le = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Le = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Se = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], He = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function We(J, fe) {
    for (var _e = 0, Ce = 0, De = new Array(), Oe = 1; Oe <= 16; Oe++) {
      for (var qe = 1; qe <= J[Oe]; qe++) De[fe[Ce]] = [], De[fe[Ce]][0] = _e, De[fe[Ce]][1] = Oe, Ce++, _e++;
      _e *= 2;
    }
    return De;
  }
  function Je(J) {
    for (var fe = J[0], _e = J[1] - 1; _e >= 0; ) fe & 1 << _e && (ye |= 1 << se), _e--, --se < 0 && (ye == 255 ? (je(255), je(0)) : je(ye), se = 7, ye = 0);
  }
  function je(J) {
    ae.push(J);
  }
  function rt(J) {
    je(J >> 8 & 255), je(255 & J);
  }
  function Ke(J, fe, _e, Ce, De) {
    for (var Oe, qe = De[0], Ze = De[240], wt = function(at, yt) {
      var zt, Pt, Gt, di, oi, bi, Ci, lt, ei, ai, It = 0;
      for (ei = 0; ei < 8; ++ei) {
        zt = at[It], Pt = at[It + 1], Gt = at[It + 2], di = at[It + 3], oi = at[It + 4], bi = at[It + 5], Ci = at[It + 6];
        var cr = zt + (lt = at[It + 7]), ct = zt - lt, si = Pt + Ci, kt = Pt - Ci, Ei = Gt + bi, Pr = Gt - bi, Et = di + oi, $r = di - oi, qi = cr + Et, Cr = cr - Et, Er = si + Ei, ue = si - Ei;
        at[It] = qi + Er, at[It + 4] = qi - Er;
        var $ = 0.707106781 * (ue + Cr);
        at[It + 2] = Cr + $, at[It + 6] = Cr - $;
        var W = 0.382683433 * ((qi = $r + Pr) - (ue = kt + ct)), te = 0.5411961 * qi + W, ce = 1.306562965 * ue + W, Pe = 0.707106781 * (Er = Pr + kt), Ee = ct + Pe, Ae = ct - Pe;
        at[It + 5] = Ae + te, at[It + 3] = Ae - te, at[It + 1] = Ee + ce, at[It + 7] = Ee - ce, It += 8;
      }
      for (It = 0, ei = 0; ei < 8; ++ei) {
        zt = at[It], Pt = at[It + 8], Gt = at[It + 16], di = at[It + 24], oi = at[It + 32], bi = at[It + 40], Ci = at[It + 48];
        var be = zt + (lt = at[It + 56]), Ve = zt - lt, et = Pt + Ci, Re = Pt - Ci, mt = Gt + bi, Dt = Gt - bi, Zt = di + oi, vi = di - oi, Jt = be + Zt, gi = be - Zt, pi = et + mt, Ui = et - mt;
        at[It] = Jt + pi, at[It + 32] = Jt - pi;
        var Fi = 0.707106781 * (Ui + gi);
        at[It + 16] = gi + Fi, at[It + 48] = gi - Fi;
        var li = 0.382683433 * ((Jt = vi + Dt) - (Ui = Re + Ve)), Di = 0.5411961 * Jt + li, Vi = 1.306562965 * Ui + li, hr = 0.707106781 * (pi = Dt + Re), fr = Ve + hr, Ir = Ve - hr;
        at[It + 40] = Ir + Di, at[It + 24] = Ir - Di, at[It + 8] = fr + Vi, at[It + 56] = fr - Vi, It++;
      }
      for (ei = 0; ei < 64; ++ei) ai = at[ei] * yt[ei], F[ei] = ai > 0 ? ai + 0.5 | 0 : ai - 0.5 | 0;
      return F;
    }(J, fe), bt = 0; bt < 64; ++bt) de[Be[bt]] = wt[bt];
    var Tt = de[0] - _e;
    _e = de[0], Tt == 0 ? Je(Ce[0]) : (Je(Ce[V[Oe = 32767 + Tt]]), Je(j[Oe]));
    for (var Mt = 63; Mt > 0 && de[Mt] == 0; ) Mt--;
    if (Mt == 0) return Je(qe), _e;
    for (var Qt, Qe = 1; Qe <= Mt; ) {
      for (var Y = Qe; de[Qe] == 0 && Qe <= Mt; ) ++Qe;
      var ui = Qe - Y;
      if (ui >= 16) {
        Qt = ui >> 4;
        for (var $t = 1; $t <= Qt; ++$t) Je(Ze);
        ui &= 15;
      }
      Oe = 32767 + de[Qe], Je(De[(ui << 4) + V[Oe]]), Je(j[Oe]), Qe++;
    }
    return Mt != 63 && Je(qe), _e;
  }
  function St(J) {
    J = Math.min(Math.max(J, 1), 100), w != J && (function(fe) {
      for (var _e = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Ce = 0; Ce < 64; Ce++) {
        var De = _((_e[Ce] * fe + 50) / 100);
        De = Math.min(Math.max(De, 1), 255), c[Be[Ce]] = De;
      }
      for (var Oe = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], qe = 0; qe < 64; qe++) {
        var Ze = _((Oe[qe] * fe + 50) / 100);
        Ze = Math.min(Math.max(Ze, 1), 255), C[Be[qe]] = Ze;
      }
      for (var wt = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], bt = 0, Tt = 0; Tt < 8; Tt++) for (var Mt = 0; Mt < 8; Mt++) N[bt] = 1 / (c[Be[bt]] * wt[Tt] * wt[Mt] * 8), q[bt] = 1 / (C[Be[bt]] * wt[Tt] * wt[Mt] * 8), bt++;
    }(J < 50 ? Math.floor(5e3 / J) : Math.floor(200 - 2 * J)), w = J);
  }
  this.encode = function(J, fe) {
    fe && St(fe), ae = new Array(), ye = 0, se = 7, rt(65496), rt(65504), rt(16), je(74), je(70), je(73), je(70), je(0), je(1), je(1), je(0), rt(1), rt(1), je(0), je(0), function() {
      rt(65499), rt(132), je(0);
      for (var Pt = 0; Pt < 64; Pt++) je(c[Pt]);
      je(1);
      for (var Gt = 0; Gt < 64; Gt++) je(C[Gt]);
    }(), function(Pt, Gt) {
      rt(65472), rt(17), je(8), rt(Gt), rt(Pt), je(3), je(1), je(17), je(0), je(2), je(17), je(1), je(3), je(17), je(1);
    }(J.width, J.height), function() {
      rt(65476), rt(418), je(0);
      for (var Pt = 0; Pt < 16; Pt++) je(Ie[Pt + 1]);
      for (var Gt = 0; Gt <= 11; Gt++) je(ot[Gt]);
      je(16);
      for (var di = 0; di < 16; di++) je(it[di + 1]);
      for (var oi = 0; oi <= 161; oi++) je(oe[oi]);
      je(1);
      for (var bi = 0; bi < 16; bi++) je(le[bi + 1]);
      for (var Ci = 0; Ci <= 11; Ci++) je(Le[Ci]);
      je(17);
      for (var lt = 0; lt < 16; lt++) je(Se[lt + 1]);
      for (var ei = 0; ei <= 161; ei++) je(He[ei]);
    }(), rt(65498), rt(12), je(3), je(1), je(0), je(2), je(17), je(3), je(17), je(0), je(63), je(0);
    var _e = 0, Ce = 0, De = 0;
    ye = 0, se = 7, this.encode.displayName = "_encode_";
    for (var Oe, qe, Ze, wt, bt, Tt, Mt, Qt, Qe, Y = J.data, ui = J.width, $t = J.height, at = 4 * ui, yt = 0; yt < $t; ) {
      for (Oe = 0; Oe < at; ) {
        for (bt = at * yt + Oe, Mt = -1, Qt = 0, Qe = 0; Qe < 64; Qe++) Tt = bt + (Qt = Qe >> 3) * at + (Mt = 4 * (7 & Qe)), yt + Qt >= $t && (Tt -= at * (yt + 1 + Qt - $t)), Oe + Mt >= at && (Tt -= Oe + Mt - at + 4), qe = Y[Tt++], Ze = Y[Tt++], wt = Y[Tt++], ge[Qe] = (tt[qe] + tt[Ze + 256 >> 0] + tt[wt + 512 >> 0] >> 16) - 128, Me[Qe] = (tt[qe + 768 >> 0] + tt[Ze + 1024 >> 0] + tt[wt + 1280 >> 0] >> 16) - 128, Ye[Qe] = (tt[qe + 1280 >> 0] + tt[Ze + 1536 >> 0] + tt[wt + 1792 >> 0] >> 16) - 128;
        _e = Ke(ge, N, _e, d, v), Ce = Ke(Me, q, Ce, p, S), De = Ke(Ye, q, De, p, S), Oe += 32;
      }
      yt += 8;
    }
    if (se >= 0) {
      var zt = [];
      zt[1] = se + 1, zt[0] = (1 << se + 1) - 1, Je(zt);
    }
    return rt(65497), new Uint8Array(ae);
  }, x = x || 50, function() {
    for (var J = String.fromCharCode, fe = 0; fe < 256; fe++) $e[fe] = J(fe);
  }(), d = We(Ie, ot), p = We(le, Le), v = We(it, oe), S = We(Se, He), function() {
    for (var J = 1, fe = 2, _e = 1; _e <= 15; _e++) {
      for (var Ce = J; Ce < fe; Ce++) V[32767 + Ce] = _e, j[32767 + Ce] = [], j[32767 + Ce][1] = _e, j[32767 + Ce][0] = Ce;
      for (var De = -(fe - 1); De <= -J; De++) V[32767 + De] = _e, j[32767 + De] = [], j[32767 + De][1] = _e, j[32767 + De][0] = fe - 1 + De;
      J <<= 1, fe <<= 1;
    }
  }(), function() {
    for (var J = 0; J < 256; J++) tt[J] = 19595 * J, tt[J + 256 >> 0] = 38470 * J, tt[J + 512 >> 0] = 7471 * J + 32768, tt[J + 768 >> 0] = -11059 * J, tt[J + 1024 >> 0] = -21709 * J, tt[J + 1280 >> 0] = 32768 * J + 8421375, tt[J + 1536 >> 0] = -27439 * J, tt[J + 1792 >> 0] = -5329 * J;
  }(), St(x);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function Uo(x, d) {
  if (this.pos = 0, this.buffer = x, this.datav = new DataView(x.buffer), this.is_with_alpha = !!d, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function pf(x) {
  function d(Ie) {
    if (!Ie) throw Error("assert :P");
  }
  function p(Ie, ot, it) {
    for (var oe = 0; 4 > oe; oe++) if (Ie[ot + oe] != it.charCodeAt(oe)) return !0;
    return !1;
  }
  function v(Ie, ot, it, oe, le) {
    for (var Le = 0; Le < le; Le++) Ie[ot + Le] = it[oe + Le];
  }
  function S(Ie, ot, it, oe) {
    for (var le = 0; le < oe; le++) Ie[ot + le] = it;
  }
  function w(Ie) {
    return new Int32Array(Ie);
  }
  function _(Ie, ot) {
    for (var it = [], oe = 0; oe < Ie; oe++) it.push(new ot());
    return it;
  }
  function c(Ie, ot) {
    var it = [];
    return function oe(le, Le, Se) {
      for (var He = Se[Le], We = 0; We < He && (le.push(Se.length > Le + 1 ? [] : new ot()), !(Se.length < Le + 1)); We++) oe(le[We], Le + 1, Se);
    }(it, 0, Ie), it;
  }
  var C = function() {
    var Ie = this;
    function ot(m, A) {
      for (var a = 1 << A - 1 >>> 0; m & a; ) a >>>= 1;
      return a ? (m & a - 1) + a : m;
    }
    function it(m, A, a, e, r) {
      d(!(e % a));
      do
        m[A + (e -= a)] = r;
      while (0 < e);
    }
    function oe(m, A, a, e, r) {
      if (d(2328 >= r), 512 >= r) var s = w(512);
      else if ((s = w(r)) == null) return 0;
      return function(l, h, y, b, I, k) {
        var z, M, O = h, U = 1 << y, B = w(16), G = w(16);
        for (d(I != 0), d(b != null), d(l != null), d(0 < y), M = 0; M < I; ++M) {
          if (15 < b[M]) return 0;
          ++B[b[M]];
        }
        if (B[0] == I) return 0;
        for (G[1] = 0, z = 1; 15 > z; ++z) {
          if (B[z] > 1 << z) return 0;
          G[z + 1] = G[z] + B[z];
        }
        for (M = 0; M < I; ++M) z = b[M], 0 < b[M] && (k[G[z]++] = M);
        if (G[15] == 1) return (b = new le()).g = 0, b.value = k[0], it(l, O, 1, U, b), U;
        var Q, ee = -1, ne = U - 1, ie = 0, he = 1, we = 1, ve = 1 << y;
        for (M = 0, z = 1, I = 2; z <= y; ++z, I <<= 1) {
          if (he += we <<= 1, 0 > (we -= B[z])) return 0;
          for (; 0 < B[z]; --B[z]) (b = new le()).g = z, b.value = k[M++], it(l, O + ie, I, ve, b), ie = ot(ie, z);
        }
        for (z = y + 1, I = 2; 15 >= z; ++z, I <<= 1) {
          if (he += we <<= 1, 0 > (we -= B[z])) return 0;
          for (; 0 < B[z]; --B[z]) {
            if (b = new le(), (ie & ne) != ee) {
              for (O += ve, Q = 1 << (ee = z) - y; 15 > ee && !(0 >= (Q -= B[ee])); ) ++ee, Q <<= 1;
              U += ve = 1 << (Q = ee - y), l[h + (ee = ie & ne)].g = Q + y, l[h + ee].value = O - h - ee;
            }
            b.g = z - y, b.value = k[M++], it(l, O + (ie >> y), I, ve, b), ie = ot(ie, z);
          }
        }
        return he != 2 * G[15] - 1 ? 0 : U;
      }(m, A, a, e, r, s);
    }
    function le() {
      this.value = this.g = 0;
    }
    function Le() {
      this.value = this.g = 0;
    }
    function Se() {
      this.G = _(5, le), this.H = w(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = _(Hr, Le);
    }
    function He(m, A, a, e) {
      d(m != null), d(A != null), d(2147483648 > e), m.Ca = 254, m.I = 0, m.b = -8, m.Ka = 0, m.oa = A, m.pa = a, m.Jd = A, m.Yc = a + e, m.Zc = 4 <= e ? a + e - 4 + 1 : a, Oe(m);
    }
    function We(m, A) {
      for (var a = 0; 0 < A--; ) a |= Ze(m, 128) << A;
      return a;
    }
    function Je(m, A) {
      var a = We(m, A);
      return qe(m) ? -a : a;
    }
    function je(m, A, a, e) {
      var r, s = 0;
      for (d(m != null), d(A != null), d(4294967288 > e), m.Sb = e, m.Ra = 0, m.u = 0, m.h = 0, 4 < e && (e = 4), r = 0; r < e; ++r) s += A[a + r] << 8 * r;
      m.Ra = s, m.bb = e, m.oa = A, m.pa = a;
    }
    function rt(m) {
      for (; 8 <= m.u && m.bb < m.Sb; ) m.Ra >>>= 8, m.Ra += m.oa[m.pa + m.bb] << Fn - 8 >>> 0, ++m.bb, m.u -= 8;
      _e(m) && (m.h = 1, m.u = 0);
    }
    function Ke(m, A) {
      if (d(0 <= A), !m.h && A <= lo) {
        var a = fe(m) & ao[A];
        return m.u += A, rt(m), a;
      }
      return m.h = 1, m.u = 0;
    }
    function St() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function J() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function fe(m) {
      return m.Ra >>> (m.u & Fn - 1) >>> 0;
    }
    function _e(m) {
      return d(m.bb <= m.Sb), m.h || m.bb == m.Sb && m.u > Fn;
    }
    function Ce(m, A) {
      m.u = A, m.h = _e(m);
    }
    function De(m) {
      m.u >= qs && (d(m.u >= qs), rt(m));
    }
    function Oe(m) {
      d(m != null && m.oa != null), m.pa < m.Zc ? (m.I = (m.oa[m.pa++] | m.I << 8) >>> 0, m.b += 8) : (d(m != null && m.oa != null), m.pa < m.Yc ? (m.b += 8, m.I = m.oa[m.pa++] | m.I << 8) : m.Ka ? m.b = 0 : (m.I <<= 8, m.b += 8, m.Ka = 1));
    }
    function qe(m) {
      return We(m, 1);
    }
    function Ze(m, A) {
      var a = m.Ca;
      0 > m.b && Oe(m);
      var e = m.b, r = a * A >>> 8, s = (m.I >>> e > r) + 0;
      for (s ? (a -= r, m.I -= r + 1 << e >>> 0) : a = r + 1, e = a, r = 0; 256 <= e; ) r += 8, e >>= 8;
      return e = 7 ^ r + Mr[e], m.b -= e, m.Ca = (a << e) - 1, s;
    }
    function wt(m, A, a) {
      m[A + 0] = a >> 24 & 255, m[A + 1] = a >> 16 & 255, m[A + 2] = a >> 8 & 255, m[A + 3] = a >> 0 & 255;
    }
    function bt(m, A) {
      return m[A + 0] << 0 | m[A + 1] << 8;
    }
    function Tt(m, A) {
      return bt(m, A) | m[A + 2] << 16;
    }
    function Mt(m, A) {
      return bt(m, A) | bt(m, A + 2) << 16;
    }
    function Qt(m, A) {
      var a = 1 << A;
      return d(m != null), d(0 < A), m.X = w(a), m.X == null ? 0 : (m.Mb = 32 - A, m.Xa = A, 1);
    }
    function Qe(m, A) {
      d(m != null), d(A != null), d(m.Xa == A.Xa), v(A.X, 0, m.X, 0, 1 << A.Xa);
    }
    function Y() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function ui(m, A, a, e) {
      d(a != null), d(e != null);
      var r = a[0], s = e[0];
      return r == 0 && (r = (m * s + A / 2) / A), s == 0 && (s = (A * r + m / 2) / m), 0 >= r || 0 >= s ? 0 : (a[0] = r, e[0] = s, 1);
    }
    function $t(m, A) {
      return m + (1 << A) - 1 >>> A;
    }
    function at(m, A) {
      return ((4278255360 & m) + (4278255360 & A) >>> 0 & 4278255360) + ((16711935 & m) + (16711935 & A) >>> 0 & 16711935) >>> 0;
    }
    function yt(m, A) {
      Ie[A] = function(a, e, r, s, l, h, y) {
        var b;
        for (b = 0; b < l; ++b) {
          var I = Ie[m](h[y + b - 1], r, s + b);
          h[y + b] = at(a[e + b], I);
        }
      };
    }
    function zt() {
      this.ud = this.hd = this.jd = 0;
    }
    function Pt(m, A) {
      return ((4278124286 & (m ^ A)) >>> 1) + (m & A) >>> 0;
    }
    function Gt(m) {
      return 0 <= m && 256 > m ? m : 0 > m ? 0 : 255 < m ? 255 : void 0;
    }
    function di(m, A) {
      return Gt(m + (m - A + 0.5 >> 1));
    }
    function oi(m, A, a) {
      return Math.abs(A - a) - Math.abs(m - a);
    }
    function bi(m, A, a, e, r, s, l) {
      for (e = s[l - 1], a = 0; a < r; ++a) s[l + a] = e = at(m[A + a], e);
    }
    function Ci(m, A, a, e, r) {
      var s;
      for (s = 0; s < a; ++s) {
        var l = m[A + s], h = l >> 8 & 255, y = 16711935 & (y = (y = 16711935 & l) + ((h << 16) + h));
        e[r + s] = (4278255360 & l) + y >>> 0;
      }
    }
    function lt(m, A) {
      A.jd = m >> 0 & 255, A.hd = m >> 8 & 255, A.ud = m >> 16 & 255;
    }
    function ei(m, A, a, e, r, s) {
      var l;
      for (l = 0; l < e; ++l) {
        var h = A[a + l], y = h >>> 8, b = h, I = 255 & (I = (I = h >>> 16) + ((m.jd << 24 >> 24) * (y << 24 >> 24) >>> 5));
        b = 255 & (b = (b = b + ((m.hd << 24 >> 24) * (y << 24 >> 24) >>> 5)) + ((m.ud << 24 >> 24) * (I << 24 >> 24) >>> 5)), r[s + l] = (4278255360 & h) + (I << 16) + b;
      }
    }
    function ai(m, A, a, e, r) {
      Ie[A] = function(s, l, h, y, b, I, k, z, M) {
        for (y = k; y < z; ++y) for (k = 0; k < M; ++k) b[I++] = r(h[e(s[l++])]);
      }, Ie[m] = function(s, l, h, y, b, I, k) {
        var z = 8 >> s.b, M = s.Ea, O = s.K[0], U = s.w;
        if (8 > z) for (s = (1 << s.b) - 1, U = (1 << z) - 1; l < h; ++l) {
          var B, G = 0;
          for (B = 0; B < M; ++B) B & s || (G = e(y[b++])), I[k++] = r(O[G & U]), G >>= z;
        }
        else Ie["VP8LMapColor" + a](y, b, O, U, I, k, l, h, M);
      };
    }
    function It(m, A, a, e, r) {
      for (a = A + a; A < a; ) {
        var s = m[A++];
        e[r++] = s >> 16 & 255, e[r++] = s >> 8 & 255, e[r++] = s >> 0 & 255;
      }
    }
    function cr(m, A, a, e, r) {
      for (a = A + a; A < a; ) {
        var s = m[A++];
        e[r++] = s >> 16 & 255, e[r++] = s >> 8 & 255, e[r++] = s >> 0 & 255, e[r++] = s >> 24 & 255;
      }
    }
    function ct(m, A, a, e, r) {
      for (a = A + a; A < a; ) {
        var s = (l = m[A++]) >> 16 & 240 | l >> 12 & 15, l = l >> 0 & 240 | l >> 28 & 15;
        e[r++] = s, e[r++] = l;
      }
    }
    function si(m, A, a, e, r) {
      for (a = A + a; A < a; ) {
        var s = (l = m[A++]) >> 16 & 248 | l >> 13 & 7, l = l >> 5 & 224 | l >> 3 & 31;
        e[r++] = s, e[r++] = l;
      }
    }
    function kt(m, A, a, e, r) {
      for (a = A + a; A < a; ) {
        var s = m[A++];
        e[r++] = s >> 0 & 255, e[r++] = s >> 8 & 255, e[r++] = s >> 16 & 255;
      }
    }
    function Ei(m, A, a, e, r, s) {
      if (s == 0) for (a = A + a; A < a; ) wt(e, ((s = m[A++])[0] >> 24 | s[1] >> 8 & 65280 | s[2] << 8 & 16711680 | s[3] << 24) >>> 0), r += 32;
      else v(e, r, m, A, a);
    }
    function Pr(m, A) {
      Ie[A][0] = Ie[m + "0"], Ie[A][1] = Ie[m + "1"], Ie[A][2] = Ie[m + "2"], Ie[A][3] = Ie[m + "3"], Ie[A][4] = Ie[m + "4"], Ie[A][5] = Ie[m + "5"], Ie[A][6] = Ie[m + "6"], Ie[A][7] = Ie[m + "7"], Ie[A][8] = Ie[m + "8"], Ie[A][9] = Ie[m + "9"], Ie[A][10] = Ie[m + "10"], Ie[A][11] = Ie[m + "11"], Ie[A][12] = Ie[m + "12"], Ie[A][13] = Ie[m + "13"], Ie[A][14] = Ie[m + "0"], Ie[A][15] = Ie[m + "0"];
    }
    function Et(m) {
      return m == pa || m == No || m == fa || m == Ha;
    }
    function $r() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function qi() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Cr() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new $r(), this.f.kb = new qi(), this.sd = null;
    }
    function Er() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ue() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function $(m) {
      return alert("todo:WebPSamplerProcessPlane"), m.T;
    }
    function W(m, A) {
      var a = m.T, e = A.ba.f.RGBA, r = e.eb, s = e.fb + m.ka * e.A, l = fi[A.ba.S], h = m.y, y = m.O, b = m.f, I = m.N, k = m.ea, z = m.W, M = A.cc, O = A.dc, U = A.Mc, B = A.Nc, G = m.ka, Q = m.ka + m.T, ee = m.U, ne = ee + 1 >> 1;
      for (G == 0 ? l(h, y, null, null, b, I, k, z, b, I, k, z, r, s, null, null, ee) : (l(A.ec, A.fc, h, y, M, O, U, B, b, I, k, z, r, s - e.A, r, s, ee), ++a); G + 2 < Q; G += 2) M = b, O = I, U = k, B = z, I += m.Rc, z += m.Rc, s += 2 * e.A, l(h, (y += 2 * m.fa) - m.fa, h, y, M, O, U, B, b, I, k, z, r, s - e.A, r, s, ee);
      return y += m.fa, m.j + Q < m.o ? (v(A.ec, A.fc, h, y, ee), v(A.cc, A.dc, b, I, ne), v(A.Mc, A.Nc, k, z, ne), a--) : 1 & Q || l(h, y, null, null, b, I, k, z, b, I, k, z, r, s + e.A, null, null, ee), a;
    }
    function te(m, A, a) {
      var e = m.F, r = [m.J];
      if (e != null) {
        var s = m.U, l = A.ba.S, h = l == da || l == fa;
        A = A.ba.f.RGBA;
        var y = [0], b = m.ka;
        y[0] = m.T, m.Kb && (b == 0 ? --y[0] : (--b, r[0] -= m.width), m.j + m.ka + m.T == m.o && (y[0] = m.o - m.j - b));
        var I = A.eb;
        b = A.fb + b * A.A, m = Ps(e, r[0], m.width, s, y, I, b + (h ? 0 : 3), A.A), d(a == y), m && Et(l) && qn(I, b, h, s, y, A.A);
      }
      return 0;
    }
    function ce(m) {
      var A = m.ma, a = A.ba.S, e = 11 > a, r = a == zo || a == Do || a == da || a == Wa || a == 12 || Et(a);
      if (A.memory = null, A.Ib = null, A.Jb = null, A.Nd = null, !as(A.Oa, m, r ? 11 : 12)) return 0;
      if (r && Et(a) && xt(), m.da) alert("todo:use_scaling");
      else {
        if (e) {
          if (A.Ib = $, m.Kb) {
            if (a = m.U + 1 >> 1, A.memory = w(m.U + 2 * a), A.memory == null) return 0;
            A.ec = A.memory, A.fc = 0, A.cc = A.ec, A.dc = A.fc + m.U, A.Mc = A.cc, A.Nc = A.dc + a, A.Ib = W, xt();
          }
        } else alert("todo:EmitYUV");
        r && (A.Jb = te, e && Fe());
      }
      if (e && !Gi) {
        for (m = 0; 256 > m; ++m) _a[m] = 89858 * (m - 128) + _l >> Ja, uc[m] = -22014 * (m - 128) + _l, xl[m] = -45773 * (m - 128), vl[m] = 113618 * (m - 128) + _l >> Ja;
        for (m = Bo; m < Hl; ++m) A = 76283 * (m - 16) + _l >> Ja, Ka[m - Bo] = ki(A, 255), Qa[m - Bo] = ki(A + 8 >> 4, 15);
        Gi = 1;
      }
      return 1;
    }
    function Pe(m) {
      var A = m.ma, a = m.U, e = m.T;
      return d(!(1 & m.ka)), 0 >= a || 0 >= e ? 0 : (a = A.Ib(m, A), A.Jb != null && A.Jb(m, A, a), A.Dc += a, 1);
    }
    function Ee(m) {
      m.ma.memory = null;
    }
    function Ae(m, A, a, e) {
      return Ke(m, 8) != 47 ? 0 : (A[0] = Ke(m, 14) + 1, a[0] = Ke(m, 14) + 1, e[0] = Ke(m, 1), Ke(m, 3) != 0 ? 0 : !m.h);
    }
    function be(m, A) {
      if (4 > m) return m + 1;
      var a = m - 2 >> 1;
      return (2 + (1 & m) << a) + Ke(A, a) + 1;
    }
    function Ve(m, A) {
      return 120 < A ? A - 120 : 1 <= (a = ((a = Un[A - 1]) >> 4) * m + (8 - (15 & a))) ? a : 1;
      var a;
    }
    function et(m, A, a) {
      var e = fe(a), r = m[A += 255 & e].g - 8;
      return 0 < r && (Ce(a, a.u + 8), e = fe(a), A += m[A].value, A += e & (1 << r) - 1), Ce(a, a.u + m[A].g), m[A].value;
    }
    function Re(m, A, a) {
      return a.g += m.g, a.value += m.value << A >>> 0, d(8 >= a.g), m.g;
    }
    function mt(m, A, a) {
      var e = m.xc;
      return d((A = e == 0 ? 0 : m.vc[m.md * (a >> e) + (A >> e)]) < m.Wb), m.Ya[A];
    }
    function Dt(m, A, a, e) {
      var r = m.ab, s = m.c * A, l = m.C;
      A = l + A;
      var h = a, y = e;
      for (e = m.Ta, a = m.Ua; 0 < r--; ) {
        var b = m.gc[r], I = l, k = A, z = h, M = y, O = (y = e, h = a, b.Ea);
        switch (d(I < k), d(k <= b.nc), b.hc) {
          case 2:
            Co(z, M, (k - I) * O, y, h);
            break;
          case 0:
            var U = I, B = k, G = y, Q = h, ee = (ve = b).Ea;
            U == 0 && (co(z, M, null, null, 1, G, Q), bi(z, M + 1, 0, 0, ee - 1, G, Q + 1), M += ee, Q += ee, ++U);
            for (var ne = 1 << ve.b, ie = ne - 1, he = $t(ee, ve.b), we = ve.K, ve = ve.w + (U >> ve.b) * he; U < B; ) {
              var Ue = we, nt = ve, ht = 1;
              for (Vs(z, M, G, Q - ee, 1, G, Q); ht < ee; ) {
                var pt = (ht & ~ie) + ne;
                pt > ee && (pt = ee), (0, Ai[Ue[nt++] >> 8 & 15])(z, M + +ht, G, Q + ht - ee, pt - ht, G, Q + ht), ht = pt;
              }
              M += ee, Q += ee, ++U & ie || (ve += he);
            }
            k != b.nc && v(y, h - O, y, h + (k - I - 1) * O, O);
            break;
          case 1:
            for (O = z, B = M, ee = (z = b.Ea) - (Q = z & ~(G = (M = 1 << b.b) - 1)), U = $t(z, b.b), ne = b.K, b = b.w + (I >> b.b) * U; I < k; ) {
              for (ie = ne, he = b, we = new zt(), ve = B + Q, Ue = B + z; B < ve; ) lt(ie[he++], we), an(we, O, B, M, y, h), B += M, h += M;
              B < Ue && (lt(ie[he++], we), an(we, O, B, ee, y, h), B += ee, h += ee), ++I & G || (b += U);
            }
            break;
          case 3:
            if (z == y && M == h && 0 < b.b) {
              for (B = y, z = O = h + (k - I) * O - (Q = (k - I) * $t(b.Ea, b.b)), M = y, G = h, U = [], Q = (ee = Q) - 1; 0 <= Q; --Q) U[Q] = M[G + Q];
              for (Q = ee - 1; 0 <= Q; --Q) B[z + Q] = U[Q];
              Xr(b, I, k, y, O, y, h);
            } else Xr(b, I, k, z, M, y, h);
        }
        h = e, y = a;
      }
      y != a && v(e, a, h, y, s);
    }
    function Zt(m, A) {
      var a = m.V, e = m.Ba + m.c * m.C, r = A - m.C;
      if (d(A <= m.l.o), d(16 >= r), 0 < r) {
        var s = m.l, l = m.Ta, h = m.Ua, y = s.width;
        if (Dt(m, r, a, e), r = h = [h], d((a = m.C) < (e = A)), d(s.v < s.va), e > s.o && (e = s.o), a < s.j) {
          var b = s.j - a;
          a = s.j, r[0] += b * y;
        }
        if (a >= e ? a = 0 : (r[0] += 4 * s.v, s.ka = a - s.j, s.U = s.va - s.v, s.T = e - a, a = 1), a) {
          if (h = h[0], 11 > (a = m.ca).S) {
            var I = a.f.RGBA, k = (e = a.S, r = s.U, s = s.T, b = I.eb, I.A), z = s;
            for (I = I.fb + m.Ma * I.A; 0 < z--; ) {
              var M = l, O = h, U = r, B = b, G = I;
              switch (e) {
                case ua:
                  ls(M, O, U, B, G);
                  break;
                case zo:
                  Us(M, O, U, B, G);
                  break;
                case pa:
                  Us(M, O, U, B, G), qn(B, G, 0, U, 1, 0);
                  break;
                case gl:
                  $s(M, O, U, B, G);
                  break;
                case Do:
                  Ei(M, O, U, B, G, 1);
                  break;
                case No:
                  Ei(M, O, U, B, G, 1), qn(B, G, 0, U, 1, 0);
                  break;
                case da:
                  Ei(M, O, U, B, G, 0);
                  break;
                case fa:
                  Ei(M, O, U, B, G, 0), qn(B, G, 1, U, 1, 0);
                  break;
                case Wa:
                  ln(M, O, U, B, G);
                  break;
                case Ha:
                  ln(M, O, U, B, G), br(B, G, U, 1, 0);
                  break;
                case fo:
                  As(M, O, U, B, G);
                  break;
                default:
                  d(0);
              }
              h += y, I += k;
            }
            m.Ma += s;
          } else alert("todo:EmitRescaledRowsYUVA");
          d(m.Ma <= a.height);
        }
      }
      m.C = A, d(m.C <= m.i);
    }
    function vi(m) {
      var A;
      if (0 < m.ua) return 0;
      for (A = 0; A < m.Wb; ++A) {
        var a = m.Ya[A].G, e = m.Ya[A].H;
        if (0 < a[1][e[1] + 0].g || 0 < a[2][e[2] + 0].g || 0 < a[3][e[3] + 0].g) return 0;
      }
      return 1;
    }
    function Jt(m, A, a, e, r, s) {
      if (m.Z != 0) {
        var l = m.qd, h = m.rd;
        for (d(Ts[m.Z] != null); A < a; ++A) Ts[m.Z](l, h, e, r, e, r, s), l = e, h = r, r += s;
        m.qd = l, m.rd = h;
      }
    }
    function gi(m, A) {
      var a = m.l.ma, e = a.Z == 0 || a.Z == 1 ? m.l.j : m.C;
      if (e = m.C < e ? e : m.C, d(A <= m.l.o), A > e) {
        var r = m.l.width, s = a.ca, l = a.tb + r * e, h = m.V, y = m.Ba + m.c * e, b = m.gc;
        d(m.ab == 1), d(b[0].hc == 3), ml(b[0], e, A, h, y, s, l), Jt(a, e, A, s, l, r);
      }
      m.C = m.Ma = A;
    }
    function pi(m, A, a, e, r, s, l) {
      var h = m.$ / e, y = m.$ % e, b = m.m, I = m.s, k = a + m.$, z = k;
      r = a + e * r;
      var M = a + e * s, O = 280 + I.ua, U = m.Pb ? h : 16777216, B = 0 < I.ua ? I.Wa : null, G = I.wc, Q = k < M ? mt(I, y, h) : null;
      d(m.C < s), d(M <= r);
      var ee = !1;
      e: for (; ; ) {
        for (; ee || k < M; ) {
          var ne = 0;
          if (h >= U) {
            var ie = k - a;
            d((U = m).Pb), U.wd = U.m, U.xd = ie, 0 < U.s.ua && Qe(U.s.Wa, U.s.vb), U = h + Vl;
          }
          if (y & G || (Q = mt(I, y, h)), d(Q != null), Q.Qb && (A[k] = Q.qb, ee = !0), !ee) if (De(b), Q.jc) {
            ne = b, ie = A;
            var he = k, we = Q.pd[fe(ne) & Hr - 1];
            d(Q.jc), 256 > we.g ? (Ce(ne, ne.u + we.g), ie[he] = we.value, ne = 0) : (Ce(ne, ne.u + we.g - 256), d(256 <= we.value), ne = we.value), ne == 0 && (ee = !0);
          } else ne = et(Q.G[0], Q.H[0], b);
          if (b.h) break;
          if (ee || 256 > ne) {
            if (!ee) if (Q.nd) A[k] = (Q.qb | ne << 8) >>> 0;
            else {
              if (De(b), ee = et(Q.G[1], Q.H[1], b), De(b), ie = et(Q.G[2], Q.H[2], b), he = et(Q.G[3], Q.H[3], b), b.h) break;
              A[k] = (he << 24 | ee << 16 | ne << 8 | ie) >>> 0;
            }
            if (ee = !1, ++k, ++y >= e && (y = 0, ++h, l != null && h <= s && !(h % 16) && l(m, h), B != null)) for (; z < k; ) ne = A[z++], B.X[(506832829 * ne & 4294967295) >>> B.Mb] = ne;
          } else if (280 > ne) {
            if (ne = be(ne - 256, b), ie = et(Q.G[4], Q.H[4], b), De(b), ie = Ve(e, ie = be(ie, b)), b.h) break;
            if (k - a < ie || r - k < ne) break e;
            for (he = 0; he < ne; ++he) A[k + he] = A[k + he - ie];
            for (k += ne, y += ne; y >= e; ) y -= e, ++h, l != null && h <= s && !(h % 16) && l(m, h);
            if (d(k <= r), y & G && (Q = mt(I, y, h)), B != null) for (; z < k; ) ne = A[z++], B.X[(506832829 * ne & 4294967295) >>> B.Mb] = ne;
          } else {
            if (!(ne < O)) break e;
            for (ee = ne - 280, d(B != null); z < k; ) ne = A[z++], B.X[(506832829 * ne & 4294967295) >>> B.Mb] = ne;
            ne = k, d(!(ee >>> (ie = B).Xa)), A[ne] = ie.X[ee], ee = !0;
          }
          ee || d(b.h == _e(b));
        }
        if (m.Pb && b.h && k < r) d(m.m.h), m.a = 5, m.m = m.wd, m.$ = m.xd, 0 < m.s.ua && Qe(m.s.vb, m.s.Wa);
        else {
          if (b.h) break e;
          l != null && l(m, h > s ? s : h), m.a = 0, m.$ = k - a;
        }
        return 1;
      }
      return m.a = 3, 0;
    }
    function Ui(m) {
      d(m != null), m.vc = null, m.yc = null, m.Ya = null;
      var A = m.Wa;
      A != null && (A.X = null), m.vb = null, d(m != null);
    }
    function Fi() {
      var m = new ko();
      return m == null ? null : (m.a = 0, m.xb = Fo, Pr("Predictor", "VP8LPredictors"), Pr("Predictor", "VP8LPredictors_C"), Pr("PredictorAdd", "VP8LPredictorsAdd"), Pr("PredictorAdd", "VP8LPredictorsAdd_C"), Co = Ci, an = ei, ls = It, Us = cr, ln = ct, As = si, $s = kt, Ie.VP8LMapColor32b = Ss, Ie.VP8LMapColor8b = Za, m);
    }
    function li(m, A, a, e, r) {
      var s = 1, l = [m], h = [A], y = e.m, b = e.s, I = null, k = 0;
      e: for (; ; ) {
        if (a) for (; s && Ke(y, 1); ) {
          var z = l, M = h, O = e, U = 1, B = O.m, G = O.gc[O.ab], Q = Ke(B, 2);
          if (O.Oc & 1 << Q) s = 0;
          else {
            switch (O.Oc |= 1 << Q, G.hc = Q, G.Ea = z[0], G.nc = M[0], G.K = [null], ++O.ab, d(4 >= O.ab), Q) {
              case 0:
              case 1:
                G.b = Ke(B, 3) + 2, U = li($t(G.Ea, G.b), $t(G.nc, G.b), 0, O, G.K), G.K = G.K[0];
                break;
              case 3:
                var ee, ne = Ke(B, 8) + 1, ie = 16 < ne ? 0 : 4 < ne ? 1 : 2 < ne ? 2 : 3;
                if (z[0] = $t(G.Ea, ie), G.b = ie, ee = U = li(ne, 1, 0, O, G.K)) {
                  var he, we = ne, ve = G, Ue = 1 << (8 >> ve.b), nt = w(Ue);
                  if (nt == null) ee = 0;
                  else {
                    var ht = ve.K[0], pt = ve.w;
                    for (nt[0] = ve.K[0][0], he = 1; he < 1 * we; ++he) nt[he] = at(ht[pt + he], nt[he - 1]);
                    for (; he < 4 * Ue; ++he) nt[he] = 0;
                    ve.K[0] = null, ve.K[0] = nt, ee = 1;
                  }
                }
                U = ee;
                break;
              case 2:
                break;
              default:
                d(0);
            }
            s = U;
          }
        }
        if (l = l[0], h = h[0], s && Ke(y, 1) && !(s = 1 <= (k = Ke(y, 4)) && 11 >= k)) {
          e.a = 3;
          break e;
        }
        var dt;
        if (dt = s) t: {
          var ut, ft, Ot, _t = e, vt = l, Vt = h, ni = k, ii = a, ci = _t.m, xi = _t.s, Bi = [null], Qi = 1, zi = 0, dr = Is[ni];
          i: for (; ; ) {
            if (ii && Ke(ci, 1)) {
              var Oi = Ke(ci, 3) + 2, or = $t(vt, Oi), wr = $t(Vt, Oi), hn = or * wr;
              if (!li(or, wr, 0, _t, Bi)) break i;
              for (Bi = Bi[0], xi.xc = Oi, ut = 0; ut < hn; ++ut) {
                var kn = Bi[ut] >> 8 & 65535;
                Bi[ut] = kn, kn >= Qi && (Qi = kn + 1);
              }
            }
            if (ci.h) break i;
            for (ft = 0; 5 > ft; ++ft) {
              var er = Xa[ft];
              !ft && 0 < ni && (er += 1 << ni), zi < er && (zi = er);
            }
            var go = _(Qi * dr, le), Cn = Qi, tl = _(Cn, Se);
            if (tl == null) var va = null;
            else d(65536 >= Cn), va = tl;
            var Jr = w(zi);
            if (va == null || Jr == null || go == null) {
              _t.a = 1;
              break i;
            }
            var un = go;
            for (ut = Ot = 0; ut < Qi; ++ut) {
              var Dr = va[ut], Kr = Dr.G, yr = Dr.H, Or = 0, Qr = 1, Ti = 0;
              for (ft = 0; 5 > ft; ++ft) {
                er = Xa[ft], Kr[ft] = un, yr[ft] = Ot, !ft && 0 < ni && (er += 1 << ni);
                n: {
                  var ks, yo = er, Gs = _t, xa = Jr, $c = un, dc = Ot, Cs = 0, Ws = Gs.m, bl = Ke(Ws, 1);
                  if (S(xa, 0, 0, yo), bl) {
                    var il = Ke(Ws, 1) + 1, wl = Ke(Ws, 1), rl = Ke(Ws, wl == 0 ? 1 : 8);
                    xa[rl] = 1, il == 2 && (xa[rl = Ke(Ws, 8)] = 1);
                    var Hs = 1;
                  } else {
                    var ba = w(19), Xl = Ke(Ws, 4) + 4;
                    if (19 < Xl) {
                      Gs.a = 3;
                      var Yl = 0;
                      break n;
                    }
                    for (ks = 0; ks < Xl; ++ks) ba[ac[ks]] = Ke(Ws, 3);
                    var pc = void 0, Jl = void 0, fc = Gs, Kl = ba, Oo = yo, _o = xa, ps = 0, En = fc.m, Zc = 8, wa = _(128, le);
                    r: for (; oe(wa, 0, 7, Kl, 19); ) {
                      if (Ke(En, 1)) {
                        var au = 2 + 2 * Ke(En, 3);
                        if ((pc = 2 + Ke(En, au)) > Oo) break r;
                      } else pc = Oo;
                      for (Jl = 0; Jl < Oo && pc--; ) {
                        De(En);
                        var Gc = wa[0 + (127 & fe(En))];
                        Ce(En, En.u + Gc.g);
                        var tr = Gc.value;
                        if (16 > tr) _o[Jl++] = tr, tr != 0 && (Zc = tr);
                        else {
                          var Wc = tr == 16, Hc = tr - 16, nl = ql[Hc], Sa = Ke(En, jl[Hc]) + nl;
                          if (Jl + Sa > Oo) break r;
                          for (var mc = Wc ? Zc : 0; 0 < Sa--; ) _o[Jl++] = mc;
                        }
                      }
                      ps = 1;
                      break r;
                    }
                    ps || (fc.a = 3), Hs = ps;
                  }
                  (Hs = Hs && !Ws.h) && (Cs = oe($c, dc, 8, xa, yo)), Hs && Cs != 0 ? Yl = Cs : (Gs.a = 3, Yl = 0);
                }
                if (Yl == 0) break i;
                if (Qr && ma[ft] == 1 && (Qr = un[Ot].g == 0), Or += un[Ot].g, Ot += Yl, 3 >= ft) {
                  var sl, gc = Jr[0];
                  for (sl = 1; sl < er; ++sl) Jr[sl] > gc && (gc = Jr[sl]);
                  Ti += gc;
                }
              }
              if (Dr.nd = Qr, Dr.Qb = 0, Qr && (Dr.qb = (Kr[3][yr[3] + 0].value << 24 | Kr[1][yr[1] + 0].value << 16 | Kr[2][yr[2] + 0].value) >>> 0, Or == 0 && 256 > Kr[0][yr[0] + 0].value && (Dr.Qb = 1, Dr.qb += Kr[0][yr[0] + 0].value << 8)), Dr.jc = !Dr.Qb && 6 > Ti, Dr.jc) {
                var yc, vo = Dr;
                for (yc = 0; yc < Hr; ++yc) {
                  var Aa = yc, xo = vo.pd[Aa], _c = vo.G[0][vo.H[0] + Aa];
                  256 <= _c.value ? (xo.g = _c.g + 256, xo.value = _c.value) : (xo.g = 0, xo.value = 0, Aa >>= Re(_c, 8, xo), Aa >>= Re(vo.G[1][vo.H[1] + Aa], 16, xo), Aa >>= Re(vo.G[2][vo.H[2] + Aa], 0, xo), Re(vo.G[3][vo.H[3] + Aa], 24, xo));
                }
              }
            }
            xi.vc = Bi, xi.Wb = Qi, xi.Ya = va, xi.yc = go, dt = 1;
            break t;
          }
          dt = 0;
        }
        if (!(s = dt)) {
          e.a = 3;
          break e;
        }
        if (0 < k) {
          if (b.ua = 1 << k, !Qt(b.Wa, k)) {
            e.a = 1, s = 0;
            break e;
          }
        } else b.ua = 0;
        var Ql = e, Xc = l, xh = h, Pa = Ql.s, Yc = Pa.xc;
        if (Ql.c = Xc, Ql.i = xh, Pa.md = $t(Xc, Yc), Pa.wc = Yc == 0 ? -1 : (1 << Yc) - 1, a) {
          e.xb = ya;
          break e;
        }
        if ((I = w(l * h)) == null) {
          e.a = 1, s = 0;
          break e;
        }
        s = (s = pi(e, I, 0, l, h, h, null)) && !y.h;
        break e;
      }
      return s ? (r != null ? r[0] = I : (d(I == null), d(a)), e.$ = 0, a || Ui(b)) : Ui(b), s;
    }
    function Di(m, A) {
      var a = m.c * m.i, e = a + A + 16 * A;
      return d(m.c <= A), m.V = w(e), m.V == null ? (m.Ta = null, m.Ua = 0, m.a = 1, 0) : (m.Ta = m.V, m.Ua = m.Ba + a + A, 1);
    }
    function Vi(m, A) {
      var a = m.C, e = A - a, r = m.V, s = m.Ba + m.c * a;
      for (d(A <= m.l.o); 0 < e; ) {
        var l = 16 < e ? 16 : e, h = m.l.ma, y = m.l.width, b = y * l, I = h.ca, k = h.tb + y * a, z = m.Ta, M = m.Ua;
        Dt(m, l, r, s), Bl(z, M, I, k, b), Jt(h, a, a + l, I, k, y), e -= l, r += l * m.c, a += l;
      }
      d(a == A), m.C = m.Ma = A;
    }
    function hr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function fr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Ir() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = w(4), this.Lb = w(4);
    }
    function Ns() {
      this.Yb = function() {
        var m = [];
        return function A(a, e, r) {
          for (var s = r[e], l = 0; l < s && (a.push(r.length > e + 1 ? [] : 0), !(r.length < e + 1)); l++) A(a[l], e + 1, r);
        }(m, 0, [3, 11]), m;
      }();
    }
    function Ri() {
      this.jb = w(3), this.Wc = c([4, 8], Ns), this.Xc = c([4, 17], Ns);
    }
    function Na() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new w(4), this.od = new w(4);
    }
    function eo() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Zr() {
      this.Na = this.la = 0;
    }
    function nn() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Fa() {
      this.ad = w(384), this.Za = 0, this.Ob = w(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function pn() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new eo()), this.Y = 0, this.ya = Array(new Fa()), this.aa = 0, this.l = new Dn();
    }
    function Gr() {
      this.y = w(16), this.f = w(8), this.ea = w(8);
    }
    function to() {
      this.cb = this.a = 0, this.sc = "", this.m = new St(), this.Od = new hr(), this.Kc = new fr(), this.ed = new Na(), this.Qa = new Ir(), this.Ic = this.$c = this.Aa = 0, this.D = new pn(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = _(8, St), this.ia = 0, this.pb = _(4, nn), this.Pa = new Ri(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Gr()), this.Hd = 0, this.rb = Array(new Zr()), this.sb = 0, this.wa = Array(new eo()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Fa()), this.L = this.aa = 0, this.gd = c([4, 2], eo), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Dn() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function mr() {
      var m = new to();
      return m != null && (m.a = 0, m.sc = "OK", m.cb = 0, m.Xb = 0, Ya || (Ya = So)), m;
    }
    function Ji(m, A, a) {
      return m.a == 0 && (m.a = A, m.sc = a, m.cb = 0), 0;
    }
    function fn(m, A, a) {
      return 3 <= a && m[A + 0] == 157 && m[A + 1] == 1 && m[A + 2] == 42;
    }
    function nr(m, A) {
      if (m == null) return 0;
      if (m.a = 0, m.sc = "OK", A == null) return Ji(m, 2, "null VP8Io passed to VP8GetHeaders()");
      var a = A.data, e = A.w, r = A.ha;
      if (4 > r) return Ji(m, 7, "Truncated header.");
      var s = a[e + 0] | a[e + 1] << 8 | a[e + 2] << 16, l = m.Od;
      if (l.Rb = !(1 & s), l.td = s >> 1 & 7, l.yd = s >> 4 & 1, l.ub = s >> 5, 3 < l.td) return Ji(m, 3, "Incorrect keyframe parameters.");
      if (!l.yd) return Ji(m, 4, "Frame not displayable.");
      e += 3, r -= 3;
      var h = m.Kc;
      if (l.Rb) {
        if (7 > r) return Ji(m, 7, "cannot parse picture header");
        if (!fn(a, e, r)) return Ji(m, 3, "Bad code word");
        h.c = 16383 & (a[e + 4] << 8 | a[e + 3]), h.Td = a[e + 4] >> 6, h.i = 16383 & (a[e + 6] << 8 | a[e + 5]), h.Ud = a[e + 6] >> 6, e += 7, r -= 7, m.za = h.c + 15 >> 4, m.Ub = h.i + 15 >> 4, A.width = h.c, A.height = h.i, A.Da = 0, A.j = 0, A.v = 0, A.va = A.width, A.o = A.height, A.da = 0, A.ib = A.width, A.hb = A.height, A.U = A.width, A.T = A.height, S((s = m.Pa).jb, 0, 255, s.jb.length), d((s = m.Qa) != null), s.Cb = 0, s.Bb = 0, s.Fb = 1, S(s.Zb, 0, 0, s.Zb.length), S(s.Lb, 0, 0, s.Lb);
      }
      if (l.ub > r) return Ji(m, 7, "bad partition length");
      He(s = m.m, a, e, l.ub), e += l.ub, r -= l.ub, l.Rb && (h.Ld = qe(s), h.Kd = qe(s)), h = m.Qa;
      var y, b = m.Pa;
      if (d(s != null), d(h != null), h.Cb = qe(s), h.Cb) {
        if (h.Bb = qe(s), qe(s)) {
          for (h.Fb = qe(s), y = 0; 4 > y; ++y) h.Zb[y] = qe(s) ? Je(s, 7) : 0;
          for (y = 0; 4 > y; ++y) h.Lb[y] = qe(s) ? Je(s, 6) : 0;
        }
        if (h.Bb) for (y = 0; 3 > y; ++y) b.jb[y] = qe(s) ? We(s, 8) : 255;
      } else h.Bb = 0;
      if (s.Ka) return Ji(m, 3, "cannot parse segment header");
      if ((h = m.ed).zd = qe(s), h.Tb = We(s, 6), h.wb = We(s, 3), h.Pc = qe(s), h.Pc && qe(s)) {
        for (b = 0; 4 > b; ++b) qe(s) && (h.vd[b] = Je(s, 6));
        for (b = 0; 4 > b; ++b) qe(s) && (h.od[b] = Je(s, 6));
      }
      if (m.L = h.Tb == 0 ? 0 : h.zd ? 1 : 2, s.Ka) return Ji(m, 3, "cannot parse filter header");
      var I = r;
      if (r = y = e, e = y + I, h = I, m.Xb = (1 << We(m.m, 2)) - 1, I < 3 * (b = m.Xb)) a = 7;
      else {
        for (y += 3 * b, h -= 3 * b, I = 0; I < b; ++I) {
          var k = a[r + 0] | a[r + 1] << 8 | a[r + 2] << 16;
          k > h && (k = h), He(m.Jc[+I], a, y, k), y += k, h -= k, r += 3;
        }
        He(m.Jc[+b], a, y, h), a = y < e ? 0 : 5;
      }
      if (a != 0) return Ji(m, a, "cannot parse partitions");
      for (a = We(y = m.m, 7), r = qe(y) ? Je(y, 4) : 0, e = qe(y) ? Je(y, 4) : 0, h = qe(y) ? Je(y, 4) : 0, b = qe(y) ? Je(y, 4) : 0, y = qe(y) ? Je(y, 4) : 0, I = m.Qa, k = 0; 4 > k; ++k) {
        if (I.Cb) {
          var z = I.Zb[k];
          I.Fb || (z += a);
        } else {
          if (0 < k) {
            m.pb[k] = m.pb[0];
            continue;
          }
          z = a;
        }
        var M = m.pb[k];
        M.Sc[0] = In[ki(z + r, 127)], M.Sc[1] = Zs[ki(z + 0, 127)], M.Eb[0] = 2 * In[ki(z + e, 127)], M.Eb[1] = 101581 * Zs[ki(z + h, 127)] >> 16, 8 > M.Eb[1] && (M.Eb[1] = 8), M.Qc[0] = In[ki(z + b, 117)], M.Qc[1] = Zs[ki(z + y, 127)], M.lc = z + y;
      }
      if (!l.Rb) return Ji(m, 4, "Not a key frame.");
      for (qe(s), l = m.Pa, a = 0; 4 > a; ++a) {
        for (r = 0; 8 > r; ++r) for (e = 0; 3 > e; ++e) for (h = 0; 11 > h; ++h) b = Ze(s, $n[a][r][e][h]) ? We(s, 8) : $l[a][r][e][h], l.Wc[a][r].Yb[e][h] = b;
        for (r = 0; 17 > r; ++r) l.Xc[a][r] = l.Wc[a][Nt[r]];
      }
      return m.kc = qe(s), m.kc && (m.Bd = We(s, 8)), m.cb = 1;
    }
    function So(m, A, a, e, r, s, l) {
      var h = A[r].Yb[a];
      for (a = 0; 16 > r; ++r) {
        if (!Ze(m, h[a + 0])) return r;
        for (; !Ze(m, h[a + 1]); ) if (h = A[++r].Yb[0], a = 0, r == 16) return 16;
        var y = A[r + 1].Yb;
        if (Ze(m, h[a + 2])) {
          var b = m, I = 0;
          if (Ze(b, (z = h)[(k = a) + 3])) if (Ze(b, z[k + 6])) {
            for (h = 0, k = 2 * (I = Ze(b, z[k + 8])) + (z = Ze(b, z[k + 9 + I])), I = 0, z = Vc[k]; z[h]; ++h) I += I + Ze(b, z[h]);
            I += 3 + (8 << k);
          } else Ze(b, z[k + 7]) ? (I = 7 + 2 * Ze(b, 165), I += Ze(b, 145)) : I = 5 + Ze(b, 159);
          else I = Ze(b, z[k + 4]) ? 3 + Ze(b, z[k + 5]) : 2;
          h = y[2];
        } else I = 1, h = y[1];
        y = l + lc[r], 0 > (b = m).b && Oe(b);
        var k, z = b.b, M = (k = b.Ca >> 1) - (b.I >> z) >> 31;
        --b.b, b.Ca += M, b.Ca |= 1, b.I -= (k + 1 & M) << z, s[y] = ((I ^ M) - M) * e[(0 < r) + 0];
      }
      return 16;
    }
    function sn(m) {
      var A = m.rb[m.sb - 1];
      A.la = 0, A.Na = 0, S(m.zc, 0, 0, m.zc.length), m.ja = 0;
    }
    function Ra(m, A) {
      if (m == null) return 0;
      if (A == null) return Ji(m, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!m.cb && !nr(m, A)) return 0;
      if (d(m.cb), A.ac == null || A.ac(A)) {
        A.ob && (m.L = 0);
        var a = mo[m.L];
        if (m.L == 2 ? (m.yb = 0, m.zb = 0) : (m.yb = A.v - a >> 4, m.zb = A.j - a >> 4, 0 > m.yb && (m.yb = 0), 0 > m.zb && (m.zb = 0)), m.Va = A.o + 15 + a >> 4, m.Hb = A.va + 15 + a >> 4, m.Hb > m.za && (m.Hb = m.za), m.Va > m.Ub && (m.Va = m.Ub), 0 < m.L) {
          var e = m.ed;
          for (a = 0; 4 > a; ++a) {
            var r;
            if (m.Qa.Cb) {
              var s = m.Qa.Lb[a];
              m.Qa.Fb || (s += e.Tb);
            } else s = e.Tb;
            for (r = 0; 1 >= r; ++r) {
              var l = m.gd[a][r], h = s;
              if (e.Pc && (h += e.vd[0], r && (h += e.od[0])), 0 < (h = 0 > h ? 0 : 63 < h ? 63 : h)) {
                var y = h;
                0 < e.wb && (y = 4 < e.wb ? y >> 2 : y >> 1) > 9 - e.wb && (y = 9 - e.wb), 1 > y && (y = 1), l.dd = y, l.tc = 2 * h + y, l.ld = 40 <= h ? 2 : 15 <= h ? 1 : 0;
              } else l.tc = 0;
              l.La = r;
            }
          }
        }
        a = 0;
      } else Ji(m, 6, "Frame setup failed"), a = m.a;
      if (a = a == 0) {
        if (a) {
          m.$c = 0, 0 < m.Aa || (m.Ic = Kt);
          e: {
            a = m.Ic, e = 4 * (y = m.za);
            var b = 32 * y, I = y + 1, k = 0 < m.L ? y * (0 < m.Aa ? 2 : 1) : 0, z = (m.Aa == 2 ? 2 : 1) * y;
            if ((l = e + 832 + (r = 3 * (16 * a + mo[m.L]) / 2 * b) + (s = m.Fa != null && 0 < m.Fa.length ? m.Kc.c * m.Kc.i : 0)) != l) a = 0;
            else {
              if (l > m.Vb) {
                if (m.Vb = 0, m.Ec = w(l), m.Fc = 0, m.Ec == null) {
                  a = Ji(m, 1, "no memory during frame initialization.");
                  break e;
                }
                m.Vb = l;
              }
              l = m.Ec, h = m.Fc, m.Ac = l, m.Bc = h, h += e, m.Gd = _(b, Gr), m.Hd = 0, m.rb = _(I + 1, Zr), m.sb = 1, m.wa = k ? _(k, eo) : null, m.Y = 0, m.D.Nb = 0, m.D.wa = m.wa, m.D.Y = m.Y, 0 < m.Aa && (m.D.Y += y), d(!0), m.oc = l, m.pc = h, h += 832, m.ya = _(z, Fa), m.aa = 0, m.D.ya = m.ya, m.D.aa = m.aa, m.Aa == 2 && (m.D.aa += y), m.R = 16 * y, m.B = 8 * y, y = (b = mo[m.L]) * m.R, b = b / 2 * m.B, m.sa = l, m.ta = h + y, m.qa = m.sa, m.ra = m.ta + 16 * a * m.R + b, m.Ha = m.qa, m.Ia = m.ra + 8 * a * m.B + b, m.$c = 0, h += r, m.mb = s ? l : null, m.nb = s ? h : null, d(h + s <= m.Fc + m.Vb), sn(m), S(m.Ac, m.Bc, 0, e), a = 1;
            }
          }
          if (a) {
            if (A.ka = 0, A.y = m.sa, A.O = m.ta, A.f = m.qa, A.N = m.ra, A.ea = m.Ha, A.Vd = m.Ia, A.fa = m.R, A.Rc = m.B, A.F = null, A.J = 0, !ha) {
              for (a = -255; 255 >= a; ++a) Ol[255 + a] = 0 > a ? -a : a;
              for (a = -1020; 1020 >= a; ++a) ur[1020 + a] = -128 > a ? -128 : 127 < a ? 127 : a;
              for (a = -112; 112 >= a; ++a) Vn[112 + a] = -16 > a ? -16 : 15 < a ? 15 : a;
              for (a = -255; 510 >= a; ++a) yn[255 + a] = 0 > a ? 0 : 255 < a ? 255 : a;
              ha = 1;
            }
            Rn = Oa, Eo = Ni, cs = Ho, Yr = Ba, gn = Fs, ho = is, Bn = na, uo = To, On = fl, jn = sa, po = pl, cn = no, hs = oa, Xi = qa, Zi = ns, sr = Pi, xr = ss, Pn = Rl, Ln[0] = Sn, Ln[1] = Ao, Ln[2] = Jo, Ln[3] = Ko, Ln[4] = ja, Ln[5] = Qo, Ln[6] = Rs, Ln[7] = ea, Ln[8] = Nl, Ln[9] = ul, us[0] = hl, us[1] = ro, us[2] = ys, us[3] = Yo, us[4] = gr, us[5] = Io, us[6] = Rr, Ls[0] = _s, Ls[1] = Xo, Ls[2] = Fl, Ls[3] = ta, Ls[4] = Bs, Ls[5] = ia, Ls[6] = Lo, a = 1;
          } else a = 0;
        }
        a && (a = function(M, O) {
          for (M.M = 0; M.M < M.Va; ++M.M) {
            var U, B = M.Jc[M.M & M.Xb], G = M.m, Q = M;
            for (U = 0; U < Q.za; ++U) {
              var ee = G, ne = Q, ie = ne.Ac, he = ne.Bc + 4 * U, we = ne.zc, ve = ne.ya[ne.aa + U];
              if (ne.Qa.Bb ? ve.$b = Ze(ee, ne.Pa.jb[0]) ? 2 + Ze(ee, ne.Pa.jb[2]) : Ze(ee, ne.Pa.jb[1]) : ve.$b = 0, ne.kc && (ve.Ad = Ze(ee, ne.Bd)), ve.Za = !Ze(ee, 145) + 0, ve.Za) {
                var Ue = ve.Ob, nt = 0;
                for (ne = 0; 4 > ne; ++ne) {
                  var ht, pt = we[0 + ne];
                  for (ht = 0; 4 > ht; ++ht) {
                    pt = ga[ie[he + ht]][pt];
                    for (var dt = Ul[Ze(ee, pt[0])]; 0 < dt; ) dt = Ul[2 * dt + Ze(ee, pt[dt])];
                    pt = -dt, ie[he + ht] = pt;
                  }
                  v(Ue, nt, ie, he, 4), nt += 4, we[0 + ne] = pt;
                }
              } else pt = Ze(ee, 156) ? Ze(ee, 128) ? 1 : 3 : Ze(ee, 163) ? 2 : 0, ve.Ob[0] = pt, S(ie, he, pt, 4), S(we, 0, pt, 4);
              ve.Dd = Ze(ee, 142) ? Ze(ee, 114) ? Ze(ee, 183) ? 1 : 3 : 2 : 0;
            }
            if (Q.m.Ka) return Ji(M, 7, "Premature end-of-partition0 encountered.");
            for (; M.ja < M.za; ++M.ja) {
              if (Q = B, ee = (G = M).rb[G.sb - 1], ie = G.rb[G.sb + G.ja], U = G.ya[G.aa + G.ja], he = G.kc ? U.Ad : 0) ee.la = ie.la = 0, U.Za || (ee.Na = ie.Na = 0), U.Hc = 0, U.Gc = 0, U.ia = 0;
              else {
                var ut, ft;
                if (ee = ie, ie = Q, he = G.Pa.Xc, we = G.ya[G.aa + G.ja], ve = G.pb[we.$b], ne = we.ad, Ue = 0, nt = G.rb[G.sb - 1], pt = ht = 0, S(ne, Ue, 0, 384), we.Za) var Ot = 0, _t = he[3];
                else {
                  dt = w(16);
                  var vt = ee.Na + nt.Na;
                  if (vt = Ya(ie, he[1], vt, ve.Eb, 0, dt, 0), ee.Na = nt.Na = (0 < vt) + 0, 1 < vt) Rn(dt, 0, ne, Ue);
                  else {
                    var Vt = dt[0] + 3 >> 3;
                    for (dt = 0; 256 > dt; dt += 16) ne[Ue + dt] = Vt;
                  }
                  Ot = 1, _t = he[0];
                }
                var ni = 15 & ee.la, ii = 15 & nt.la;
                for (dt = 0; 4 > dt; ++dt) {
                  var ci = 1 & ii;
                  for (Vt = ft = 0; 4 > Vt; ++Vt) ni = ni >> 1 | (ci = (vt = Ya(ie, _t, vt = ci + (1 & ni), ve.Sc, Ot, ne, Ue)) > Ot) << 7, ft = ft << 2 | (3 < vt ? 3 : 1 < vt ? 2 : ne[Ue + 0] != 0), Ue += 16;
                  ni >>= 4, ii = ii >> 1 | ci << 7, ht = (ht << 8 | ft) >>> 0;
                }
                for (_t = ni, Ot = ii >> 4, ut = 0; 4 > ut; ut += 2) {
                  for (ft = 0, ni = ee.la >> 4 + ut, ii = nt.la >> 4 + ut, dt = 0; 2 > dt; ++dt) {
                    for (ci = 1 & ii, Vt = 0; 2 > Vt; ++Vt) vt = ci + (1 & ni), ni = ni >> 1 | (ci = 0 < (vt = Ya(ie, he[2], vt, ve.Qc, 0, ne, Ue))) << 3, ft = ft << 2 | (3 < vt ? 3 : 1 < vt ? 2 : ne[Ue + 0] != 0), Ue += 16;
                    ni >>= 2, ii = ii >> 1 | ci << 5;
                  }
                  pt |= ft << 4 * ut, _t |= ni << 4 << ut, Ot |= (240 & ii) << ut;
                }
                ee.la = _t, nt.la = Ot, we.Hc = ht, we.Gc = pt, we.ia = 43690 & pt ? 0 : ve.ia, he = !(ht | pt);
              }
              if (0 < G.L && (G.wa[G.Y + G.ja] = G.gd[U.$b][U.Za], G.wa[G.Y + G.ja].La |= !he), Q.Ka) return Ji(M, 7, "Premature end-of-file encountered.");
            }
            if (sn(M), G = O, Q = 1, U = (B = M).D, ee = 0 < B.L && B.M >= B.zb && B.M <= B.Va, B.Aa == 0) e: {
              if (U.M = B.M, U.uc = ee, js(B, U), Q = 1, U = (ft = B.D).Nb, ee = (pt = mo[B.L]) * B.R, ie = pt / 2 * B.B, dt = 16 * U * B.R, Vt = 8 * U * B.B, he = B.sa, we = B.ta - ee + dt, ve = B.qa, ne = B.ra - ie + Vt, Ue = B.Ha, nt = B.Ia - ie + Vt, ii = (ni = ft.M) == 0, ht = ni >= B.Va - 1, B.Aa == 2 && js(B, ft), ft.uc) for (ci = (vt = B).D.M, d(vt.D.uc), ft = vt.yb; ft < vt.Hb; ++ft) {
                Ot = ft, _t = ci;
                var xi = (Bi = (er = vt).D).Nb;
                ut = er.R;
                var Bi = Bi.wa[Bi.Y + Ot], Qi = er.sa, zi = er.ta + 16 * xi * ut + 16 * Ot, dr = Bi.dd, Oi = Bi.tc;
                if (Oi != 0) if (d(3 <= Oi), er.L == 1) 0 < Ot && sr(Qi, zi, ut, Oi + 4), Bi.La && Pn(Qi, zi, ut, Oi), 0 < _t && Zi(Qi, zi, ut, Oi + 4), Bi.La && xr(Qi, zi, ut, Oi);
                else {
                  var or = er.B, wr = er.qa, hn = er.ra + 8 * xi * or + 8 * Ot, kn = er.Ha, er = er.Ia + 8 * xi * or + 8 * Ot;
                  xi = Bi.ld, 0 < Ot && (uo(Qi, zi, ut, Oi + 4, dr, xi), jn(wr, hn, kn, er, or, Oi + 4, dr, xi)), Bi.La && (cn(Qi, zi, ut, Oi, dr, xi), Xi(wr, hn, kn, er, or, Oi, dr, xi)), 0 < _t && (Bn(Qi, zi, ut, Oi + 4, dr, xi), On(wr, hn, kn, er, or, Oi + 4, dr, xi)), Bi.La && (po(Qi, zi, ut, Oi, dr, xi), hs(wr, hn, kn, er, or, Oi, dr, xi));
                }
              }
              if (B.ia && alert("todo:DitherRow"), G.put != null) {
                if (ft = 16 * ni, ni = 16 * (ni + 1), ii ? (G.y = B.sa, G.O = B.ta + dt, G.f = B.qa, G.N = B.ra + Vt, G.ea = B.Ha, G.W = B.Ia + Vt) : (ft -= pt, G.y = he, G.O = we, G.f = ve, G.N = ne, G.ea = Ue, G.W = nt), ht || (ni -= pt), ni > G.o && (ni = G.o), G.F = null, G.J = null, B.Fa != null && 0 < B.Fa.length && ft < ni && (G.J = ca(B, G, ft, ni - ft), G.F = B.mb, G.F == null && G.F.length == 0)) {
                  Q = Ji(B, 3, "Could not decode alpha data.");
                  break e;
                }
                ft < G.j && (pt = G.j - ft, ft = G.j, d(!(1 & pt)), G.O += B.R * pt, G.N += B.B * (pt >> 1), G.W += B.B * (pt >> 1), G.F != null && (G.J += G.width * pt)), ft < ni && (G.O += G.v, G.N += G.v >> 1, G.W += G.v >> 1, G.F != null && (G.J += G.v), G.ka = ft - G.j, G.U = G.va - G.v, G.T = ni - ft, Q = G.put(G));
              }
              U + 1 != B.Ic || ht || (v(B.sa, B.ta - ee, he, we + 16 * B.R, ee), v(B.qa, B.ra - ie, ve, ne + 8 * B.B, ie), v(B.Ha, B.Ia - ie, Ue, nt + 8 * B.B, ie));
            }
            if (!Q) return Ji(M, 6, "Output aborted.");
          }
          return 1;
        }(m, A)), A.bc != null && A.bc(A), a &= 1;
      }
      return a ? (m.cb = 0, a) : 0;
    }
    function _r(m, A, a, e, r) {
      r = m[A + a + 32 * e] + (r >> 3), m[A + a + 32 * e] = -256 & r ? 0 > r ? 0 : 255 : r;
    }
    function Wo(m, A, a, e, r, s) {
      _r(m, A, 0, a, e + r), _r(m, A, 1, a, e + s), _r(m, A, 2, a, e - s), _r(m, A, 3, a, e - r);
    }
    function Fr(m) {
      return (20091 * m >> 16) + m;
    }
    function ts(m, A, a, e) {
      var r, s = 0, l = w(16);
      for (r = 0; 4 > r; ++r) {
        var h = m[A + 0] + m[A + 8], y = m[A + 0] - m[A + 8], b = (35468 * m[A + 4] >> 16) - Fr(m[A + 12]), I = Fr(m[A + 4]) + (35468 * m[A + 12] >> 16);
        l[s + 0] = h + I, l[s + 1] = y + b, l[s + 2] = y - b, l[s + 3] = h - I, s += 4, A++;
      }
      for (r = s = 0; 4 > r; ++r) h = (m = l[s + 0] + 4) + l[s + 8], y = m - l[s + 8], b = (35468 * l[s + 4] >> 16) - Fr(l[s + 12]), _r(a, e, 0, 0, h + (I = Fr(l[s + 4]) + (35468 * l[s + 12] >> 16))), _r(a, e, 1, 0, y + b), _r(a, e, 2, 0, y - b), _r(a, e, 3, 0, h - I), s++, e += 32;
    }
    function is(m, A, a, e) {
      var r = m[A + 0] + 4, s = 35468 * m[A + 4] >> 16, l = Fr(m[A + 4]), h = 35468 * m[A + 1] >> 16;
      Wo(a, e, 0, r + l, m = Fr(m[A + 1]), h), Wo(a, e, 1, r + s, m, h), Wo(a, e, 2, r - s, m, h), Wo(a, e, 3, r - l, m, h);
    }
    function Ni(m, A, a, e, r) {
      ts(m, A, a, e), r && ts(m, A + 16, a, e + 4);
    }
    function Ho(m, A, a, e) {
      Eo(m, A + 0, a, e, 1), Eo(m, A + 32, a, e + 128, 1);
    }
    function Ba(m, A, a, e) {
      var r;
      for (m = m[A + 0] + 4, r = 0; 4 > r; ++r) for (A = 0; 4 > A; ++A) _r(a, e, A, r, m);
    }
    function Fs(m, A, a, e) {
      m[A + 0] && Yr(m, A + 0, a, e), m[A + 16] && Yr(m, A + 16, a, e + 4), m[A + 32] && Yr(m, A + 32, a, e + 128), m[A + 48] && Yr(m, A + 48, a, e + 128 + 4);
    }
    function Oa(m, A, a, e) {
      var r, s = w(16);
      for (r = 0; 4 > r; ++r) {
        var l = m[A + 0 + r] + m[A + 12 + r], h = m[A + 4 + r] + m[A + 8 + r], y = m[A + 4 + r] - m[A + 8 + r], b = m[A + 0 + r] - m[A + 12 + r];
        s[0 + r] = l + h, s[8 + r] = l - h, s[4 + r] = b + y, s[12 + r] = b - y;
      }
      for (r = 0; 4 > r; ++r) l = (m = s[0 + 4 * r] + 3) + s[3 + 4 * r], h = s[1 + 4 * r] + s[2 + 4 * r], y = s[1 + 4 * r] - s[2 + 4 * r], b = m - s[3 + 4 * r], a[e + 0] = l + h >> 3, a[e + 16] = b + y >> 3, a[e + 32] = l - h >> 3, a[e + 48] = b - y >> 3, e += 64;
    }
    function io(m, A, a) {
      var e, r = A - 32, s = zr, l = 255 - m[r - 1];
      for (e = 0; e < a; ++e) {
        var h, y = s, b = l + m[A - 1];
        for (h = 0; h < a; ++h) m[A + h] = y[b + m[r + h]];
        A += 32;
      }
    }
    function Ao(m, A) {
      io(m, A, 4);
    }
    function Xo(m, A) {
      io(m, A, 8);
    }
    function ro(m, A) {
      io(m, A, 16);
    }
    function ys(m, A) {
      var a;
      for (a = 0; 16 > a; ++a) v(m, A + 32 * a, m, A - 32, 16);
    }
    function Yo(m, A) {
      var a;
      for (a = 16; 0 < a; --a) S(m, A, m[A - 1], 16), A += 32;
    }
    function Po(m, A, a) {
      var e;
      for (e = 0; 16 > e; ++e) S(A, a + 32 * e, m, 16);
    }
    function hl(m, A) {
      var a, e = 16;
      for (a = 0; 16 > a; ++a) e += m[A - 1 + 32 * a] + m[A + a - 32];
      Po(e >> 5, m, A);
    }
    function gr(m, A) {
      var a, e = 8;
      for (a = 0; 16 > a; ++a) e += m[A - 1 + 32 * a];
      Po(e >> 4, m, A);
    }
    function Io(m, A) {
      var a, e = 8;
      for (a = 0; 16 > a; ++a) e += m[A + a - 32];
      Po(e >> 4, m, A);
    }
    function Rr(m, A) {
      Po(128, m, A);
    }
    function Xt(m, A, a) {
      return m + 2 * A + a + 2 >> 2;
    }
    function Jo(m, A) {
      var a, e = A - 32;
      for (e = new Uint8Array([Xt(m[e - 1], m[e + 0], m[e + 1]), Xt(m[e + 0], m[e + 1], m[e + 2]), Xt(m[e + 1], m[e + 2], m[e + 3]), Xt(m[e + 2], m[e + 3], m[e + 4])]), a = 0; 4 > a; ++a) v(m, A + 32 * a, e, 0, e.length);
    }
    function Ko(m, A) {
      var a = m[A - 1], e = m[A - 1 + 32], r = m[A - 1 + 64], s = m[A - 1 + 96];
      wt(m, A + 0, 16843009 * Xt(m[A - 1 - 32], a, e)), wt(m, A + 32, 16843009 * Xt(a, e, r)), wt(m, A + 64, 16843009 * Xt(e, r, s)), wt(m, A + 96, 16843009 * Xt(r, s, s));
    }
    function Sn(m, A) {
      var a, e = 4;
      for (a = 0; 4 > a; ++a) e += m[A + a - 32] + m[A - 1 + 32 * a];
      for (e >>= 3, a = 0; 4 > a; ++a) S(m, A + 32 * a, e, 4);
    }
    function ja(m, A) {
      var a = m[A - 1 + 0], e = m[A - 1 + 32], r = m[A - 1 + 64], s = m[A - 1 - 32], l = m[A + 0 - 32], h = m[A + 1 - 32], y = m[A + 2 - 32], b = m[A + 3 - 32];
      m[A + 0 + 96] = Xt(e, r, m[A - 1 + 96]), m[A + 1 + 96] = m[A + 0 + 64] = Xt(a, e, r), m[A + 2 + 96] = m[A + 1 + 64] = m[A + 0 + 32] = Xt(s, a, e), m[A + 3 + 96] = m[A + 2 + 64] = m[A + 1 + 32] = m[A + 0 + 0] = Xt(l, s, a), m[A + 3 + 64] = m[A + 2 + 32] = m[A + 1 + 0] = Xt(h, l, s), m[A + 3 + 32] = m[A + 2 + 0] = Xt(y, h, l), m[A + 3 + 0] = Xt(b, y, h);
    }
    function Rs(m, A) {
      var a = m[A + 1 - 32], e = m[A + 2 - 32], r = m[A + 3 - 32], s = m[A + 4 - 32], l = m[A + 5 - 32], h = m[A + 6 - 32], y = m[A + 7 - 32];
      m[A + 0 + 0] = Xt(m[A + 0 - 32], a, e), m[A + 1 + 0] = m[A + 0 + 32] = Xt(a, e, r), m[A + 2 + 0] = m[A + 1 + 32] = m[A + 0 + 64] = Xt(e, r, s), m[A + 3 + 0] = m[A + 2 + 32] = m[A + 1 + 64] = m[A + 0 + 96] = Xt(r, s, l), m[A + 3 + 32] = m[A + 2 + 64] = m[A + 1 + 96] = Xt(s, l, h), m[A + 3 + 64] = m[A + 2 + 96] = Xt(l, h, y), m[A + 3 + 96] = Xt(h, y, y);
    }
    function Qo(m, A) {
      var a = m[A - 1 + 0], e = m[A - 1 + 32], r = m[A - 1 + 64], s = m[A - 1 - 32], l = m[A + 0 - 32], h = m[A + 1 - 32], y = m[A + 2 - 32], b = m[A + 3 - 32];
      m[A + 0 + 0] = m[A + 1 + 64] = s + l + 1 >> 1, m[A + 1 + 0] = m[A + 2 + 64] = l + h + 1 >> 1, m[A + 2 + 0] = m[A + 3 + 64] = h + y + 1 >> 1, m[A + 3 + 0] = y + b + 1 >> 1, m[A + 0 + 96] = Xt(r, e, a), m[A + 0 + 64] = Xt(e, a, s), m[A + 0 + 32] = m[A + 1 + 96] = Xt(a, s, l), m[A + 1 + 32] = m[A + 2 + 96] = Xt(s, l, h), m[A + 2 + 32] = m[A + 3 + 96] = Xt(l, h, y), m[A + 3 + 32] = Xt(h, y, b);
    }
    function ea(m, A) {
      var a = m[A + 0 - 32], e = m[A + 1 - 32], r = m[A + 2 - 32], s = m[A + 3 - 32], l = m[A + 4 - 32], h = m[A + 5 - 32], y = m[A + 6 - 32], b = m[A + 7 - 32];
      m[A + 0 + 0] = a + e + 1 >> 1, m[A + 1 + 0] = m[A + 0 + 64] = e + r + 1 >> 1, m[A + 2 + 0] = m[A + 1 + 64] = r + s + 1 >> 1, m[A + 3 + 0] = m[A + 2 + 64] = s + l + 1 >> 1, m[A + 0 + 32] = Xt(a, e, r), m[A + 1 + 32] = m[A + 0 + 96] = Xt(e, r, s), m[A + 2 + 32] = m[A + 1 + 96] = Xt(r, s, l), m[A + 3 + 32] = m[A + 2 + 96] = Xt(s, l, h), m[A + 3 + 64] = Xt(l, h, y), m[A + 3 + 96] = Xt(h, y, b);
    }
    function ul(m, A) {
      var a = m[A - 1 + 0], e = m[A - 1 + 32], r = m[A - 1 + 64], s = m[A - 1 + 96];
      m[A + 0 + 0] = a + e + 1 >> 1, m[A + 2 + 0] = m[A + 0 + 32] = e + r + 1 >> 1, m[A + 2 + 32] = m[A + 0 + 64] = r + s + 1 >> 1, m[A + 1 + 0] = Xt(a, e, r), m[A + 3 + 0] = m[A + 1 + 32] = Xt(e, r, s), m[A + 3 + 32] = m[A + 1 + 64] = Xt(r, s, s), m[A + 3 + 64] = m[A + 2 + 64] = m[A + 0 + 96] = m[A + 1 + 96] = m[A + 2 + 96] = m[A + 3 + 96] = s;
    }
    function Nl(m, A) {
      var a = m[A - 1 + 0], e = m[A - 1 + 32], r = m[A - 1 + 64], s = m[A - 1 + 96], l = m[A - 1 - 32], h = m[A + 0 - 32], y = m[A + 1 - 32], b = m[A + 2 - 32];
      m[A + 0 + 0] = m[A + 2 + 32] = a + l + 1 >> 1, m[A + 0 + 32] = m[A + 2 + 64] = e + a + 1 >> 1, m[A + 0 + 64] = m[A + 2 + 96] = r + e + 1 >> 1, m[A + 0 + 96] = s + r + 1 >> 1, m[A + 3 + 0] = Xt(h, y, b), m[A + 2 + 0] = Xt(l, h, y), m[A + 1 + 0] = m[A + 3 + 32] = Xt(a, l, h), m[A + 1 + 32] = m[A + 3 + 64] = Xt(e, a, l), m[A + 1 + 64] = m[A + 3 + 96] = Xt(r, e, a), m[A + 1 + 96] = Xt(s, r, e);
    }
    function Fl(m, A) {
      var a;
      for (a = 0; 8 > a; ++a) v(m, A + 32 * a, m, A - 32, 8);
    }
    function ta(m, A) {
      var a;
      for (a = 0; 8 > a; ++a) S(m, A, m[A - 1], 8), A += 32;
    }
    function rs(m, A, a) {
      var e;
      for (e = 0; 8 > e; ++e) S(A, a + 32 * e, m, 8);
    }
    function _s(m, A) {
      var a, e = 8;
      for (a = 0; 8 > a; ++a) e += m[A + a - 32] + m[A - 1 + 32 * a];
      rs(e >> 4, m, A);
    }
    function ia(m, A) {
      var a, e = 4;
      for (a = 0; 8 > a; ++a) e += m[A + a - 32];
      rs(e >> 3, m, A);
    }
    function Bs(m, A) {
      var a, e = 4;
      for (a = 0; 8 > a; ++a) e += m[A - 1 + 32 * a];
      rs(e >> 3, m, A);
    }
    function Lo(m, A) {
      rs(128, m, A);
    }
    function on(m, A, a) {
      var e = m[A - a], r = m[A + 0], s = 3 * (r - e) + Ga[1020 + m[A - 2 * a] - m[A + a]], l = Mo[112 + (s + 4 >> 3)];
      m[A - a] = zr[255 + e + Mo[112 + (s + 3 >> 3)]], m[A + 0] = zr[255 + r - l];
    }
    function dl(m, A, a, e) {
      var r = m[A + 0], s = m[A + a];
      return Lr[255 + m[A - 2 * a] - m[A - a]] > e || Lr[255 + s - r] > e;
    }
    function ra(m, A, a, e) {
      return 4 * Lr[255 + m[A - a] - m[A + 0]] + Lr[255 + m[A - 2 * a] - m[A + a]] <= e;
    }
    function vs(m, A, a, e, r) {
      var s = m[A - 3 * a], l = m[A - 2 * a], h = m[A - a], y = m[A + 0], b = m[A + a], I = m[A + 2 * a], k = m[A + 3 * a];
      return 4 * Lr[255 + h - y] + Lr[255 + l - b] > e ? 0 : Lr[255 + m[A - 4 * a] - s] <= r && Lr[255 + s - l] <= r && Lr[255 + l - h] <= r && Lr[255 + k - I] <= r && Lr[255 + I - b] <= r && Lr[255 + b - y] <= r;
    }
    function ns(m, A, a, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) ra(m, A + e, a, r) && on(m, A + e, a);
    }
    function Pi(m, A, a, e) {
      var r = 2 * e + 1;
      for (e = 0; 16 > e; ++e) ra(m, A + e * a, 1, r) && on(m, A + e * a, 1);
    }
    function ss(m, A, a, e) {
      var r;
      for (r = 3; 0 < r; --r) ns(m, A += 4 * a, a, e);
    }
    function Rl(m, A, a, e) {
      var r;
      for (r = 3; 0 < r; --r) Pi(m, A += 4, a, e);
    }
    function An(m, A, a, e, r, s, l, h) {
      for (s = 2 * s + 1; 0 < r--; ) {
        if (vs(m, A, a, s, l)) if (dl(m, A, a, h)) on(m, A, a);
        else {
          var y = m, b = A, I = a, k = y[b - 2 * I], z = y[b - I], M = y[b + 0], O = y[b + I], U = y[b + 2 * I], B = 27 * (Q = Ga[1020 + 3 * (M - z) + Ga[1020 + k - O]]) + 63 >> 7, G = 18 * Q + 63 >> 7, Q = 9 * Q + 63 >> 7;
          y[b - 3 * I] = zr[255 + y[b - 3 * I] + Q], y[b - 2 * I] = zr[255 + k + G], y[b - I] = zr[255 + z + B], y[b + 0] = zr[255 + M - B], y[b + I] = zr[255 + O - G], y[b + 2 * I] = zr[255 + U - Q];
        }
        A += e;
      }
    }
    function os(m, A, a, e, r, s, l, h) {
      for (s = 2 * s + 1; 0 < r--; ) {
        if (vs(m, A, a, s, l)) if (dl(m, A, a, h)) on(m, A, a);
        else {
          var y = m, b = A, I = a, k = y[b - I], z = y[b + 0], M = y[b + I], O = Mo[112 + ((U = 3 * (z - k)) + 4 >> 3)], U = Mo[112 + (U + 3 >> 3)], B = O + 1 >> 1;
          y[b - 2 * I] = zr[255 + y[b - 2 * I] + B], y[b - I] = zr[255 + k + U], y[b + 0] = zr[255 + z - O], y[b + I] = zr[255 + M - B];
        }
        A += e;
      }
    }
    function na(m, A, a, e, r, s) {
      An(m, A, a, 1, 16, e, r, s);
    }
    function To(m, A, a, e, r, s) {
      An(m, A, 1, a, 16, e, r, s);
    }
    function pl(m, A, a, e, r, s) {
      var l;
      for (l = 3; 0 < l; --l) os(m, A += 4 * a, a, 1, 16, e, r, s);
    }
    function no(m, A, a, e, r, s) {
      var l;
      for (l = 3; 0 < l; --l) os(m, A += 4, 1, a, 16, e, r, s);
    }
    function fl(m, A, a, e, r, s, l, h) {
      An(m, A, r, 1, 8, s, l, h), An(a, e, r, 1, 8, s, l, h);
    }
    function sa(m, A, a, e, r, s, l, h) {
      An(m, A, 1, r, 8, s, l, h), An(a, e, 1, r, 8, s, l, h);
    }
    function oa(m, A, a, e, r, s, l, h) {
      os(m, A + 4 * r, r, 1, 8, s, l, h), os(a, e + 4 * r, r, 1, 8, s, l, h);
    }
    function qa(m, A, a, e, r, s, l, h) {
      os(m, A + 4, 1, r, 8, s, l, h), os(a, e + 4, 1, r, 8, s, l, h);
    }
    function Nn() {
      this.ba = new Cr(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ue(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function aa() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Va() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Ua() {
      this.ua = 0, this.Wa = new Y(), this.vb = new Y(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Se(), this.yc = new le();
    }
    function ko() {
      this.xb = this.a = 0, this.l = new Dn(), this.ca = new Cr(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new J(), this.Pb = 0, this.wd = new J(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Ua(), this.ab = 0, this.gc = _(4, Va), this.Oc = 0;
    }
    function la() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Dn(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function xs(m, A, a, e, r, s, l) {
      for (m = m == null ? 0 : m[A + 0], A = 0; A < l; ++A) r[s + A] = m + a[e + A] & 255, m = r[s + A];
    }
    function $a(m, A, a, e, r, s, l) {
      var h;
      if (m == null) xs(null, null, a, e, r, s, l);
      else for (h = 0; h < l; ++h) r[s + h] = m[A + h] + a[e + h] & 255;
    }
    function so(m, A, a, e, r, s, l) {
      if (m == null) xs(null, null, a, e, r, s, l);
      else {
        var h, y = m[A + 0], b = y, I = y;
        for (h = 0; h < l; ++h) b = I + (y = m[A + h]) - b, I = a[e + h] + (-256 & b ? 0 > b ? 0 : 255 : b) & 255, b = y, r[s + h] = I;
      }
    }
    function ca(m, A, a, e) {
      var r = A.width, s = A.o;
      if (d(m != null && A != null), 0 > a || 0 >= e || a + e > s) return null;
      if (!m.Cc) {
        if (m.ga == null) {
          var l;
          if (m.ga = new la(), (l = m.ga == null) || (l = A.width * A.o, d(m.Gb.length == 0), m.Gb = w(l), m.Uc = 0, m.Gb == null ? l = 0 : (m.mb = m.Gb, m.nb = m.Uc, m.rc = null, l = 1), l = !l), !l) {
            l = m.ga;
            var h = m.Fa, y = m.P, b = m.qc, I = m.mb, k = m.nb, z = y + 1, M = b - 1, O = l.l;
            if (d(h != null && I != null && A != null), Ts[0] = null, Ts[1] = xs, Ts[2] = $a, Ts[3] = so, l.ca = I, l.tb = k, l.c = A.width, l.i = A.height, d(0 < l.c && 0 < l.i), 1 >= b) A = 0;
            else if (l.$a = h[y + 0] >> 0 & 3, l.Z = h[y + 0] >> 2 & 3, l.Lc = h[y + 0] >> 4 & 3, y = h[y + 0] >> 6 & 3, 0 > l.$a || 1 < l.$a || 4 <= l.Z || 1 < l.Lc || y) A = 0;
            else if (O.put = Pe, O.ac = ce, O.bc = Ee, O.ma = l, O.width = A.width, O.height = A.height, O.Da = A.Da, O.v = A.v, O.va = A.va, O.j = A.j, O.o = A.o, l.$a) e: {
              d(l.$a == 1), A = Fi();
              t: for (; ; ) {
                if (A == null) {
                  A = 0;
                  break e;
                }
                if (d(l != null), l.mc = A, A.c = l.c, A.i = l.i, A.l = l.l, A.l.ma = l, A.l.width = l.c, A.l.height = l.i, A.a = 0, je(A.m, h, z, M), !li(l.c, l.i, 1, A, null) || (A.ab == 1 && A.gc[0].hc == 3 && vi(A.s) ? (l.ic = 1, h = A.c * A.i, A.Ta = null, A.Ua = 0, A.V = w(h), A.Ba = 0, A.V == null ? (A.a = 1, A = 0) : A = 1) : (l.ic = 0, A = Di(A, l.c)), !A)) break t;
                A = 1;
                break e;
              }
              l.mc = null, A = 0;
            }
            else A = M >= l.c * l.i;
            l = !A;
          }
          if (l) return null;
          m.ga.Lc != 1 ? m.Ga = 0 : e = s - a;
        }
        d(m.ga != null), d(a + e <= s);
        e: {
          if (A = (h = m.ga).c, s = h.l.o, h.$a == 0) {
            if (z = m.rc, M = m.Vc, O = m.Fa, y = m.P + 1 + a * A, b = m.mb, I = m.nb + a * A, d(y <= m.P + m.qc), h.Z != 0) for (d(Ts[h.Z] != null), l = 0; l < e; ++l) Ts[h.Z](z, M, O, y, b, I, A), z = b, M = I, I += A, y += A;
            else for (l = 0; l < e; ++l) v(b, I, O, y, A), z = b, M = I, I += A, y += A;
            m.rc = z, m.Vc = M;
          } else {
            if (d(h.mc != null), A = a + e, d((l = h.mc) != null), d(A <= l.i), l.C >= A) A = 1;
            else if (h.ic || Fe(), h.ic) {
              h = l.V, z = l.Ba, M = l.c;
              var U = l.i, B = (O = 1, y = l.$ / M, b = l.$ % M, I = l.m, k = l.s, l.$), G = M * U, Q = M * A, ee = k.wc, ne = B < Q ? mt(k, b, y) : null;
              d(B <= G), d(A <= U), d(vi(k));
              t: for (; ; ) {
                for (; !I.h && B < Q; ) {
                  if (b & ee || (ne = mt(k, b, y)), d(ne != null), De(I), 256 > (U = et(ne.G[0], ne.H[0], I))) h[z + B] = U, ++B, ++b >= M && (b = 0, ++y <= A && !(y % 16) && gi(l, y));
                  else {
                    if (!(280 > U)) {
                      O = 0;
                      break t;
                    }
                    U = be(U - 256, I);
                    var ie, he = et(ne.G[4], ne.H[4], I);
                    if (De(I), !(B >= (he = Ve(M, he = be(he, I))) && G - B >= U)) {
                      O = 0;
                      break t;
                    }
                    for (ie = 0; ie < U; ++ie) h[z + B + ie] = h[z + B + ie - he];
                    for (B += U, b += U; b >= M; ) b -= M, ++y <= A && !(y % 16) && gi(l, y);
                    B < Q && b & ee && (ne = mt(k, b, y));
                  }
                  d(I.h == _e(I));
                }
                gi(l, y > A ? A : y);
                break t;
              }
              !O || I.h && B < G ? (O = 0, l.a = I.h ? 5 : 3) : l.$ = B, A = O;
            } else A = pi(l, l.V, l.Ba, l.c, l.i, A, Vi);
            if (!A) {
              e = 0;
              break e;
            }
          }
          a + e >= s && (m.Cc = 1), e = 1;
        }
        if (!e) return null;
        if (m.Cc && ((e = m.ga) != null && (e.mc = null), m.ga = null, 0 < m.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return m.nb + a * r;
    }
    function T(m, A, a, e, r, s) {
      for (; 0 < r--; ) {
        var l, h = m, y = A + (a ? 1 : 0), b = m, I = A + (a ? 0 : 3);
        for (l = 0; l < e; ++l) {
          var k = b[I + 4 * l];
          k != 255 && (k *= 32897, h[y + 4 * l + 0] = h[y + 4 * l + 0] * k >> 23, h[y + 4 * l + 1] = h[y + 4 * l + 1] * k >> 23, h[y + 4 * l + 2] = h[y + 4 * l + 2] * k >> 23);
        }
        A += s;
      }
    }
    function X(m, A, a, e, r) {
      for (; 0 < e--; ) {
        var s;
        for (s = 0; s < a; ++s) {
          var l = m[A + 2 * s + 0], h = 15 & (b = m[A + 2 * s + 1]), y = 4369 * h, b = (240 & b | b >> 4) * y >> 16;
          m[A + 2 * s + 0] = (240 & l | l >> 4) * y >> 16 & 240 | (15 & l | l << 4) * y >> 16 >> 4 & 15, m[A + 2 * s + 1] = 240 & b | h;
        }
        A += r;
      }
    }
    function me(m, A, a, e, r, s, l, h) {
      var y, b, I = 255;
      for (b = 0; b < r; ++b) {
        for (y = 0; y < e; ++y) {
          var k = m[A + y];
          s[l + 4 * y] = k, I &= k;
        }
        A += a, l += h;
      }
      return I != 255;
    }
    function ke(m, A, a, e, r) {
      var s;
      for (s = 0; s < r; ++s) a[e + s] = m[A + s] >> 8;
    }
    function Fe() {
      qn = T, br = X, Ps = me, Bl = ke;
    }
    function Xe(m, A, a) {
      Ie[m] = function(e, r, s, l, h, y, b, I, k, z, M, O, U, B, G, Q, ee) {
        var ne, ie = ee - 1 >> 1, he = h[y + 0] | b[I + 0] << 16, we = k[z + 0] | M[O + 0] << 16;
        d(e != null);
        var ve = 3 * he + we + 131074 >> 2;
        for (A(e[r + 0], 255 & ve, ve >> 16, U, B), s != null && (ve = 3 * we + he + 131074 >> 2, A(s[l + 0], 255 & ve, ve >> 16, G, Q)), ne = 1; ne <= ie; ++ne) {
          var Ue = h[y + ne] | b[I + ne] << 16, nt = k[z + ne] | M[O + ne] << 16, ht = he + Ue + we + nt + 524296, pt = ht + 2 * (Ue + we) >> 3;
          ve = pt + he >> 1, he = (ht = ht + 2 * (he + nt) >> 3) + Ue >> 1, A(e[r + 2 * ne - 1], 255 & ve, ve >> 16, U, B + (2 * ne - 1) * a), A(e[r + 2 * ne - 0], 255 & he, he >> 16, U, B + (2 * ne - 0) * a), s != null && (ve = ht + we >> 1, he = pt + nt >> 1, A(s[l + 2 * ne - 1], 255 & ve, ve >> 16, G, Q + (2 * ne - 1) * a), A(s[l + 2 * ne + 0], 255 & he, he >> 16, G, Q + (2 * ne + 0) * a)), he = Ue, we = nt;
        }
        1 & ee || (ve = 3 * he + we + 131074 >> 2, A(e[r + ee - 1], 255 & ve, ve >> 16, U, B + (ee - 1) * a), s != null && (ve = 3 * we + he + 131074 >> 2, A(s[l + ee - 1], 255 & ve, ve >> 16, G, Q + (ee - 1) * a)));
      };
    }
    function xt() {
      fi[ua] = Zl, fi[zo] = yl, fi[gl] = Uc, fi[Do] = cc, fi[da] = Ro, fi[Wa] = Gl, fi[fo] = Wl, fi[pa] = yl, fi[No] = cc, fi[fa] = Ro, fi[Ha] = Gl;
    }
    function Rt(m) {
      return m & ~Tn ? 0 > m ? 0 : 255 : m >> hc;
    }
    function ti(m, A) {
      return Rt((19077 * m >> 8) + (26149 * A >> 8) - 14234);
    }
    function mi(m, A, a) {
      return Rt((19077 * m >> 8) - (6419 * A >> 8) - (13320 * a >> 8) + 8708);
    }
    function wi(m, A) {
      return Rt((19077 * m >> 8) + (33050 * A >> 8) - 17685);
    }
    function Ii(m, A, a, e, r) {
      e[r + 0] = ti(m, a), e[r + 1] = mi(m, A, a), e[r + 2] = wi(m, A);
    }
    function Ki(m, A, a, e, r) {
      e[r + 0] = wi(m, A), e[r + 1] = mi(m, A, a), e[r + 2] = ti(m, a);
    }
    function vr(m, A, a, e, r) {
      var s = mi(m, A, a);
      A = s << 3 & 224 | wi(m, A) >> 3, e[r + 0] = 248 & ti(m, a) | s >> 5, e[r + 1] = A;
    }
    function Si(m, A, a, e, r) {
      var s = 240 & wi(m, A) | 15;
      e[r + 0] = 240 & ti(m, a) | mi(m, A, a) >> 4, e[r + 1] = s;
    }
    function Wr(m, A, a, e, r) {
      e[r + 0] = 255, Ii(m, A, a, e, r + 1);
    }
    function Yt(m, A, a, e, r) {
      Ki(m, A, a, e, r), e[r + 3] = 255;
    }
    function mn(m, A, a, e, r) {
      Ii(m, A, a, e, r), e[r + 3] = 255;
    }
    function ki(m, A) {
      return 0 > m ? 0 : m > A ? A : m;
    }
    function Mi(m, A, a) {
      Ie[m] = function(e, r, s, l, h, y, b, I, k) {
        for (var z = I + (-2 & k) * a; I != z; ) A(e[r + 0], s[l + 0], h[y + 0], b, I), A(e[r + 1], s[l + 0], h[y + 0], b, I + a), r += 2, ++l, ++y, I += 2 * a;
        1 & k && A(e[r + 0], s[l + 0], h[y + 0], b, I);
      };
    }
    function bs(m, A, a) {
      return a == 0 ? m == 0 ? A == 0 ? 6 : 5 : A == 0 ? 4 : 0 : a;
    }
    function Os(m, A, a, e, r) {
      switch (m >>> 30) {
        case 3:
          Eo(A, a, e, r, 0);
          break;
        case 2:
          ho(A, a, e, r);
          break;
        case 1:
          Yr(A, a, e, r);
      }
    }
    function js(m, A) {
      var a, e, r = A.M, s = A.Nb, l = m.oc, h = m.pc + 40, y = m.oc, b = m.pc + 584, I = m.oc, k = m.pc + 600;
      for (a = 0; 16 > a; ++a) l[h + 32 * a - 1] = 129;
      for (a = 0; 8 > a; ++a) y[b + 32 * a - 1] = 129, I[k + 32 * a - 1] = 129;
      for (0 < r ? l[h - 1 - 32] = y[b - 1 - 32] = I[k - 1 - 32] = 129 : (S(l, h - 32 - 1, 127, 21), S(y, b - 32 - 1, 127, 9), S(I, k - 32 - 1, 127, 9)), e = 0; e < m.za; ++e) {
        var z = A.ya[A.aa + e];
        if (0 < e) {
          for (a = -1; 16 > a; ++a) v(l, h + 32 * a - 4, l, h + 32 * a + 12, 4);
          for (a = -1; 8 > a; ++a) v(y, b + 32 * a - 4, y, b + 32 * a + 4, 4), v(I, k + 32 * a - 4, I, k + 32 * a + 4, 4);
        }
        var M = m.Gd, O = m.Hd + e, U = z.ad, B = z.Hc;
        if (0 < r && (v(l, h - 32, M[O].y, 0, 16), v(y, b - 32, M[O].f, 0, 8), v(I, k - 32, M[O].ea, 0, 8)), z.Za) {
          var G = l, Q = h - 32 + 16;
          for (0 < r && (e >= m.za - 1 ? S(G, Q, M[O].y[15], 4) : v(G, Q, M[O + 1].y, 0, 4)), a = 0; 4 > a; a++) G[Q + 128 + a] = G[Q + 256 + a] = G[Q + 384 + a] = G[Q + 0 + a];
          for (a = 0; 16 > a; ++a, B <<= 2) G = l, Q = h + ds[a], Ln[z.Ob[a]](G, Q), Os(B, U, 16 * +a, G, Q);
        } else if (G = bs(e, r, z.Ob[0]), us[G](l, h), B != 0) for (a = 0; 16 > a; ++a, B <<= 2) Os(B, U, 16 * +a, l, h + ds[a]);
        for (a = z.Gc, G = bs(e, r, z.Dd), Ls[G](y, b), Ls[G](I, k), B = U, G = y, Q = b, 255 & (z = a >> 0) && (170 & z ? cs(B, 256, G, Q) : gn(B, 256, G, Q)), z = I, B = k, 255 & (a >>= 8) && (170 & a ? cs(U, 320, z, B) : gn(U, 320, z, B)), r < m.Ub - 1 && (v(M[O].y, 0, l, h + 480, 16), v(M[O].f, 0, y, b + 224, 8), v(M[O].ea, 0, I, k + 224, 8)), a = 8 * s * m.B, M = m.sa, O = m.ta + 16 * e + 16 * s * m.R, U = m.qa, z = m.ra + 8 * e + a, B = m.Ha, G = m.Ia + 8 * e + a, a = 0; 16 > a; ++a) v(M, O + a * m.R, l, h + 32 * a, 16);
        for (a = 0; 8 > a; ++a) v(U, z + a * m.B, y, b + 32 * a, 8), v(B, G + a * m.B, I, k + 32 * a, 8);
      }
    }
    function oo(m, A, a, e, r, s, l, h, y) {
      var b = [0], I = [0], k = 0, z = y != null ? y.kd : 0, M = y ?? new aa();
      if (m == null || 12 > a) return 7;
      M.data = m, M.w = A, M.ha = a, A = [A], a = [a], M.gb = [M.gb];
      e: {
        var O = A, U = a, B = M.gb;
        if (d(m != null), d(U != null), d(B != null), B[0] = 0, 12 <= U[0] && !p(m, O[0], "RIFF")) {
          if (p(m, O[0] + 8, "WEBP")) {
            B = 3;
            break e;
          }
          var G = Mt(m, O[0] + 4);
          if (12 > G || 4294967286 < G) {
            B = 3;
            break e;
          }
          if (z && G > U[0] - 8) {
            B = 7;
            break e;
          }
          B[0] = G, O[0] += 12, U[0] -= 12;
        }
        B = 0;
      }
      if (B != 0) return B;
      for (G = 0 < M.gb[0], a = a[0]; ; ) {
        e: {
          var Q = m;
          U = A, B = a;
          var ee = b, ne = I, ie = O = [0];
          if ((ve = k = [k])[0] = 0, 8 > B[0]) B = 7;
          else {
            if (!p(Q, U[0], "VP8X")) {
              if (Mt(Q, U[0] + 4) != 10) {
                B = 3;
                break e;
              }
              if (18 > B[0]) {
                B = 7;
                break e;
              }
              var he = Mt(Q, U[0] + 8), we = 1 + Tt(Q, U[0] + 12);
              if (2147483648 <= we * (Q = 1 + Tt(Q, U[0] + 15))) {
                B = 3;
                break e;
              }
              ie != null && (ie[0] = he), ee != null && (ee[0] = we), ne != null && (ne[0] = Q), U[0] += 18, B[0] -= 18, ve[0] = 1;
            }
            B = 0;
          }
        }
        if (k = k[0], O = O[0], B != 0) return B;
        if (U = !!(2 & O), !G && k) return 3;
        if (s != null && (s[0] = !!(16 & O)), l != null && (l[0] = U), h != null && (h[0] = 0), l = b[0], O = I[0], k && U && y == null) {
          B = 0;
          break;
        }
        if (4 > a) {
          B = 7;
          break;
        }
        if (G && k || !G && !k && !p(m, A[0], "ALPH")) {
          a = [a], M.na = [M.na], M.P = [M.P], M.Sa = [M.Sa];
          e: {
            he = m, B = A, G = a;
            var ve = M.gb;
            ee = M.na, ne = M.P, ie = M.Sa, we = 22, d(he != null), d(G != null), Q = B[0];
            var Ue = G[0];
            for (d(ee != null), d(ie != null), ee[0] = null, ne[0] = null, ie[0] = 0; ; ) {
              if (B[0] = Q, G[0] = Ue, 8 > Ue) {
                B = 7;
                break e;
              }
              var nt = Mt(he, Q + 4);
              if (4294967286 < nt) {
                B = 3;
                break e;
              }
              var ht = 8 + nt + 1 & -2;
              if (we += ht, 0 < ve && we > ve) {
                B = 3;
                break e;
              }
              if (!p(he, Q, "VP8 ") || !p(he, Q, "VP8L")) {
                B = 0;
                break e;
              }
              if (Ue[0] < ht) {
                B = 7;
                break e;
              }
              p(he, Q, "ALPH") || (ee[0] = he, ne[0] = Q + 8, ie[0] = nt), Q += ht, Ue -= ht;
            }
          }
          if (a = a[0], M.na = M.na[0], M.P = M.P[0], M.Sa = M.Sa[0], B != 0) break;
        }
        a = [a], M.Ja = [M.Ja], M.xa = [M.xa];
        e: if (ve = m, B = A, G = a, ee = M.gb[0], ne = M.Ja, ie = M.xa, he = B[0], Q = !p(ve, he, "VP8 "), we = !p(ve, he, "VP8L"), d(ve != null), d(G != null), d(ne != null), d(ie != null), 8 > G[0]) B = 7;
        else {
          if (Q || we) {
            if (ve = Mt(ve, he + 4), 12 <= ee && ve > ee - 12) {
              B = 3;
              break e;
            }
            if (z && ve > G[0] - 8) {
              B = 7;
              break e;
            }
            ne[0] = ve, B[0] += 8, G[0] -= 8, ie[0] = we;
          } else ie[0] = 5 <= G[0] && ve[he + 0] == 47 && !(ve[he + 4] >> 5), ne[0] = G[0];
          B = 0;
        }
        if (a = a[0], M.Ja = M.Ja[0], M.xa = M.xa[0], A = A[0], B != 0) break;
        if (4294967286 < M.Ja) return 3;
        if (h == null || U || (h[0] = M.xa ? 2 : 1), l = [l], O = [O], M.xa) {
          if (5 > a) {
            B = 7;
            break;
          }
          h = l, z = O, U = s, m == null || 5 > a ? m = 0 : 5 <= a && m[A + 0] == 47 && !(m[A + 4] >> 5) ? (G = [0], ve = [0], ee = [0], je(ne = new J(), m, A, a), Ae(ne, G, ve, ee) ? (h != null && (h[0] = G[0]), z != null && (z[0] = ve[0]), U != null && (U[0] = ee[0]), m = 1) : m = 0) : m = 0;
        } else {
          if (10 > a) {
            B = 7;
            break;
          }
          h = O, m == null || 10 > a || !fn(m, A + 3, a - 3) ? m = 0 : (z = m[A + 0] | m[A + 1] << 8 | m[A + 2] << 16, U = 16383 & (m[A + 7] << 8 | m[A + 6]), m = 16383 & (m[A + 9] << 8 | m[A + 8]), 1 & z || 3 < (z >> 1 & 7) || !(z >> 4 & 1) || z >> 5 >= M.Ja || !U || !m ? m = 0 : (l && (l[0] = U), h && (h[0] = m), m = 1));
        }
        if (!m || (l = l[0], O = O[0], k && (b[0] != l || I[0] != O))) return 3;
        y != null && (y[0] = M, y.offset = A - y.w, d(4294967286 > A - y.w), d(y.offset == y.ha - a));
        break;
      }
      return B == 0 || B == 7 && k && y == null ? (s != null && (s[0] |= M.na != null && 0 < M.na.length), e != null && (e[0] = l), r != null && (r[0] = O), 0) : B;
    }
    function as(m, A, a) {
      var e = A.width, r = A.height, s = 0, l = 0, h = e, y = r;
      if (A.Da = m != null && 0 < m.Da, A.Da && (h = m.cd, y = m.bd, s = m.v, l = m.j, 11 > a || (s &= -2, l &= -2), 0 > s || 0 > l || 0 >= h || 0 >= y || s + h > e || l + y > r)) return 0;
      if (A.v = s, A.j = l, A.va = s + h, A.o = l + y, A.U = h, A.T = y, A.da = m != null && 0 < m.da, A.da) {
        if (!ui(h, y, a = [m.ib], s = [m.hb])) return 0;
        A.ib = a[0], A.hb = s[0];
      }
      return A.ob = m != null && m.ob, A.Kb = m == null || !m.Sd, A.da && (A.ob = A.ib < 3 * e / 4 && A.hb < 3 * r / 4, A.Kb = 0), 1;
    }
    function ws(m) {
      if (m == null) return 2;
      if (11 > m.S) {
        var A = m.f.RGBA;
        A.fb += (m.height - 1) * A.A, A.A = -A.A;
      } else A = m.f.kb, m = m.height, A.O += (m - 1) * A.fa, A.fa = -A.fa, A.N += (m - 1 >> 1) * A.Ab, A.Ab = -A.Ab, A.W += (m - 1 >> 1) * A.Db, A.Db = -A.Db, A.F != null && (A.J += (m - 1) * A.lb, A.lb = -A.lb);
      return 0;
    }
    function Br(m, A, a, e) {
      if (e == null || 0 >= m || 0 >= A) return 2;
      if (a != null) {
        if (a.Da) {
          var r = a.cd, s = a.bd, l = -2 & a.v, h = -2 & a.j;
          if (0 > l || 0 > h || 0 >= r || 0 >= s || l + r > m || h + s > A) return 2;
          m = r, A = s;
        }
        if (a.da) {
          if (!ui(m, A, r = [a.ib], s = [a.hb])) return 2;
          m = r[0], A = s[0];
        }
      }
      e.width = m, e.height = A;
      e: {
        var y = e.width, b = e.height;
        if (m = e.S, 0 >= y || 0 >= b || !(m >= ua && 13 > m)) m = 2;
        else {
          if (0 >= e.Rd && e.sd == null) {
            l = s = r = A = 0;
            var I = (h = y * el[m]) * b;
            if (11 > m || (s = (b + 1) / 2 * (A = (y + 1) / 2), m == 12 && (l = (r = y) * b)), (b = w(I + 2 * s + l)) == null) {
              m = 1;
              break e;
            }
            e.sd = b, 11 > m ? ((y = e.f.RGBA).eb = b, y.fb = 0, y.A = h, y.size = I) : ((y = e.f.kb).y = b, y.O = 0, y.fa = h, y.Fd = I, y.f = b, y.N = 0 + I, y.Ab = A, y.Cd = s, y.ea = b, y.W = 0 + I + s, y.Db = A, y.Ed = s, m == 12 && (y.F = b, y.J = 0 + I + 2 * s), y.Tc = l, y.lb = r);
          }
          if (A = 1, r = e.S, s = e.width, l = e.height, r >= ua && 13 > r) if (11 > r) m = e.f.RGBA, A &= (h = Math.abs(m.A)) * (l - 1) + s <= m.size, A &= h >= s * el[r], A &= m.eb != null;
          else {
            m = e.f.kb, h = (s + 1) / 2, I = (l + 1) / 2, y = Math.abs(m.fa), b = Math.abs(m.Ab);
            var k = Math.abs(m.Db), z = Math.abs(m.lb), M = z * (l - 1) + s;
            A &= y * (l - 1) + s <= m.Fd, A &= b * (I - 1) + h <= m.Cd, A = (A &= k * (I - 1) + h <= m.Ed) & y >= s & b >= h & k >= h, A &= m.y != null, A &= m.f != null, A &= m.ea != null, r == 12 && (A &= z >= s, A &= M <= m.Tc, A &= m.F != null);
          }
          else A = 0;
          m = A ? 0 : 2;
        }
      }
      return m != 0 || a != null && a.fd && (m = ws(e)), m;
    }
    var Hr = 64, ao = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], lo = 24, Fn = 32, qs = 8, Mr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    yt("Predictor0", "PredictorAdd0"), Ie.Predictor0 = function() {
      return 4278190080;
    }, Ie.Predictor1 = function(m) {
      return m;
    }, Ie.Predictor2 = function(m, A, a) {
      return A[a + 0];
    }, Ie.Predictor3 = function(m, A, a) {
      return A[a + 1];
    }, Ie.Predictor4 = function(m, A, a) {
      return A[a - 1];
    }, Ie.Predictor5 = function(m, A, a) {
      return Pt(Pt(m, A[a + 1]), A[a + 0]);
    }, Ie.Predictor6 = function(m, A, a) {
      return Pt(m, A[a - 1]);
    }, Ie.Predictor7 = function(m, A, a) {
      return Pt(m, A[a + 0]);
    }, Ie.Predictor8 = function(m, A, a) {
      return Pt(A[a - 1], A[a + 0]);
    }, Ie.Predictor9 = function(m, A, a) {
      return Pt(A[a + 0], A[a + 1]);
    }, Ie.Predictor10 = function(m, A, a) {
      return Pt(Pt(m, A[a - 1]), Pt(A[a + 0], A[a + 1]));
    }, Ie.Predictor11 = function(m, A, a) {
      var e = A[a + 0];
      return 0 >= oi(e >> 24 & 255, m >> 24 & 255, (A = A[a - 1]) >> 24 & 255) + oi(e >> 16 & 255, m >> 16 & 255, A >> 16 & 255) + oi(e >> 8 & 255, m >> 8 & 255, A >> 8 & 255) + oi(255 & e, 255 & m, 255 & A) ? e : m;
    }, Ie.Predictor12 = function(m, A, a) {
      var e = A[a + 0];
      return (Gt((m >> 24 & 255) + (e >> 24 & 255) - ((A = A[a - 1]) >> 24 & 255)) << 24 | Gt((m >> 16 & 255) + (e >> 16 & 255) - (A >> 16 & 255)) << 16 | Gt((m >> 8 & 255) + (e >> 8 & 255) - (A >> 8 & 255)) << 8 | Gt((255 & m) + (255 & e) - (255 & A))) >>> 0;
    }, Ie.Predictor13 = function(m, A, a) {
      var e = A[a - 1];
      return (di((m = Pt(m, A[a + 0])) >> 24 & 255, e >> 24 & 255) << 24 | di(m >> 16 & 255, e >> 16 & 255) << 16 | di(m >> 8 & 255, e >> 8 & 255) << 8 | di(m >> 0 & 255, e >> 0 & 255)) >>> 0;
    };
    var co = Ie.PredictorAdd0;
    Ie.PredictorAdd1 = bi, yt("Predictor2", "PredictorAdd2"), yt("Predictor3", "PredictorAdd3"), yt("Predictor4", "PredictorAdd4"), yt("Predictor5", "PredictorAdd5"), yt("Predictor6", "PredictorAdd6"), yt("Predictor7", "PredictorAdd7"), yt("Predictor8", "PredictorAdd8"), yt("Predictor9", "PredictorAdd9"), yt("Predictor10", "PredictorAdd10"), yt("Predictor11", "PredictorAdd11"), yt("Predictor12", "PredictorAdd12"), yt("Predictor13", "PredictorAdd13");
    var Vs = Ie.PredictorAdd2;
    ai("ColorIndexInverseTransform", "MapARGB", "32b", function(m) {
      return m >> 8 & 255;
    }, function(m) {
      return m;
    }), ai("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(m) {
      return m;
    }, function(m) {
      return m >> 8 & 255;
    });
    var Co, Xr = Ie.ColorIndexInverseTransform, Ss = Ie.MapARGB, ml = Ie.VP8LColorIndexInverseTransformAlpha, Za = Ie.MapAlpha, Ai = Ie.VP8LPredictorsAdd = [];
    Ai.length = 16, (Ie.VP8LPredictors = []).length = 16, (Ie.VP8LPredictorsAdd_C = []).length = 16, (Ie.VP8LPredictors_C = []).length = 16;
    var an, ls, Us, ln, As, $s, Rn, Eo, ho, cs, Yr, gn, Bn, uo, On, jn, po, cn, hs, Xi, Zi, sr, xr, Pn, qn, br, Ps, Bl, Ol = w(511), ur = w(2041), Vn = w(225), yn = w(767), ha = 0, Ga = ur, Mo = Vn, zr = yn, Lr = Ol, ua = 0, zo = 1, gl = 2, Do = 3, da = 4, Wa = 5, fo = 6, pa = 7, No = 8, fa = 9, Ha = 10, jl = [2, 3, 7], ql = [3, 3, 11], Xa = [280, 256, 256, 256, 40], ma = [0, 1, 1, 1, 0], ac = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Un = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Is = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Vl = 8, In = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Zs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Ya = null, Vc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], lc = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Ul = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], $l = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ga = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], $n = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Nt = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], us = [], Ln = [], Ls = [], ya = 1, Fo = 2, Ts = [], fi = [];
    Xe("UpsampleRgbLinePair", Ii, 3), Xe("UpsampleBgrLinePair", Ki, 3), Xe("UpsampleRgbaLinePair", mn, 4), Xe("UpsampleBgraLinePair", Yt, 4), Xe("UpsampleArgbLinePair", Wr, 4), Xe("UpsampleRgba4444LinePair", Si, 2), Xe("UpsampleRgb565LinePair", vr, 2);
    var Zl = Ie.UpsampleRgbLinePair, Uc = Ie.UpsampleBgrLinePair, yl = Ie.UpsampleRgbaLinePair, cc = Ie.UpsampleBgraLinePair, Ro = Ie.UpsampleArgbLinePair, Gl = Ie.UpsampleRgba4444LinePair, Wl = Ie.UpsampleRgb565LinePair, Ja = 16, _l = 1 << Ja - 1, Bo = -227, Hl = 482, hc = 6, Tn = (256 << hc) - 1, Gi = 0, _a = w(256), vl = w(256), xl = w(256), uc = w(256), Ka = w(Hl - Bo), Qa = w(Hl - Bo);
    Mi("YuvToRgbRow", Ii, 3), Mi("YuvToBgrRow", Ki, 3), Mi("YuvToRgbaRow", mn, 4), Mi("YuvToBgraRow", Yt, 4), Mi("YuvToArgbRow", Wr, 4), Mi("YuvToRgba4444Row", Si, 2), Mi("YuvToRgb565Row", vr, 2);
    var ds = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], mo = [0, 2, 8], jt = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Kt = 1;
    this.WebPDecodeRGBA = function(m, A, a, e, r) {
      var s = zo, l = new Nn(), h = new Cr();
      l.ba = h, h.S = s, h.width = [h.width], h.height = [h.height];
      var y = h.width, b = h.height, I = new Er();
      if (I == null || m == null) var k = 2;
      else d(I != null), k = oo(m, A, a, I.width, I.height, I.Pd, I.Qd, I.format, null);
      if (k != 0 ? y = 0 : (y != null && (y[0] = I.width[0]), b != null && (b[0] = I.height[0]), y = 1), y) {
        h.width = h.width[0], h.height = h.height[0], e != null && (e[0] = h.width), r != null && (r[0] = h.height);
        e: {
          if (e = new Dn(), (r = new aa()).data = m, r.w = A, r.ha = a, r.kd = 1, A = [0], d(r != null), ((m = oo(r.data, r.w, r.ha, null, null, null, A, null, r)) == 0 || m == 7) && A[0] && (m = 4), (A = m) == 0) {
            if (d(l != null), e.data = r.data, e.w = r.w + r.offset, e.ha = r.ha - r.offset, e.put = Pe, e.ac = ce, e.bc = Ee, e.ma = l, r.xa) {
              if ((m = Fi()) == null) {
                l = 1;
                break e;
              }
              if (function(z, M) {
                var O = [0], U = [0], B = [0];
                t: for (; ; ) {
                  if (z == null) return 0;
                  if (M == null) return z.a = 2, 0;
                  if (z.l = M, z.a = 0, je(z.m, M.data, M.w, M.ha), !Ae(z.m, O, U, B)) {
                    z.a = 3;
                    break t;
                  }
                  if (z.xb = Fo, M.width = O[0], M.height = U[0], !li(O[0], U[0], 1, z, null)) break t;
                  return 1;
                }
                return d(z.a != 0), 0;
              }(m, e)) {
                if (e = (A = Br(e.width, e.height, l.Oa, l.ba)) == 0) {
                  t: {
                    e = m;
                    i: for (; ; ) {
                      if (e == null) {
                        e = 0;
                        break t;
                      }
                      if (d(e.s.yc != null), d(e.s.Ya != null), d(0 < e.s.Wb), d((a = e.l) != null), d((r = a.ma) != null), e.xb != 0) {
                        if (e.ca = r.ba, e.tb = r.tb, d(e.ca != null), !as(r.Oa, a, Do)) {
                          e.a = 2;
                          break i;
                        }
                        if (!Di(e, a.width) || a.da) break i;
                        if ((a.da || Et(e.ca.S)) && Fe(), 11 > e.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), e.ca.f.kb.F != null && Fe()), e.Pb && 0 < e.s.ua && e.s.vb.X == null && !Qt(e.s.vb, e.s.Wa.Xa)) {
                          e.a = 1;
                          break i;
                        }
                        e.xb = 0;
                      }
                      if (!pi(e, e.V, e.Ba, e.c, e.i, a.o, Zt)) break i;
                      r.Dc = e.Ma, e = 1;
                      break t;
                    }
                    d(e.a != 0), e = 0;
                  }
                  e = !e;
                }
                e && (A = m.a);
              } else A = m.a;
            } else {
              if ((m = new mr()) == null) {
                l = 1;
                break e;
              }
              if (m.Fa = r.na, m.P = r.P, m.qc = r.Sa, nr(m, e)) {
                if ((A = Br(e.width, e.height, l.Oa, l.ba)) == 0) {
                  if (m.Aa = 0, a = l.Oa, d((r = m) != null), a != null) {
                    if (0 < (y = 0 > (y = a.Md) ? 0 : 100 < y ? 255 : 255 * y / 100)) {
                      for (b = I = 0; 4 > b; ++b) 12 > (k = r.pb[b]).lc && (k.ia = y * jt[0 > k.lc ? 0 : k.lc] >> 3), I |= k.ia;
                      I && (alert("todo:VP8InitRandom"), r.ia = 1);
                    }
                    r.Ga = a.Id, 100 < r.Ga ? r.Ga = 100 : 0 > r.Ga && (r.Ga = 0);
                  }
                  Ra(m, e) || (A = m.a);
                }
              } else A = m.a;
            }
            A == 0 && l.Oa != null && l.Oa.fd && (A = ws(l.ba));
          }
          l = A;
        }
        s = l != 0 ? null : 11 > s ? h.f.RGBA.eb : h.f.kb.y;
      } else s = null;
      return s;
    };
    var el = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function N(Ie, ot) {
    for (var it = "", oe = 0; oe < 4; oe++) it += String.fromCharCode(Ie[ot++]);
    return it;
  }
  function q(Ie, ot) {
    return (Ie[ot + 0] << 0 | Ie[ot + 1] << 8 | Ie[ot + 2] << 16) >>> 0;
  }
  function j(Ie, ot) {
    return (Ie[ot + 0] << 0 | Ie[ot + 1] << 8 | Ie[ot + 2] << 16 | Ie[ot + 3] << 24) >>> 0;
  }
  new C();
  var V = [0], F = [0], de = [], ae = new C(), ye = x, se = function(Ie, ot) {
    var it = {}, oe = 0, le = !1, Le = 0, Se = 0;
    if (it.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(fe, _e, Ce, De) {
      for (var Oe = 0; Oe < De; Oe++) if (fe[_e + Oe] != Ce.charCodeAt(Oe)) return !0;
      return !1;
    }(Ie, ot, "RIFF", 4)) {
      var He, We;
      for (j(Ie, ot += 4), ot += 8; ot < Ie.length; ) {
        var Je = N(Ie, ot), je = j(Ie, ot += 4);
        ot += 4;
        var rt = je + (1 & je);
        switch (Je) {
          case "VP8 ":
          case "VP8L":
            it.frames[oe] === void 0 && (it.frames[oe] = {}), (J = it.frames[oe]).src_off = le ? Se : ot - 8, J.src_size = Le + je + 8, oe++, le && (le = !1, Le = 0, Se = 0);
            break;
          case "VP8X":
            (J = it.header = {}).feature_flags = Ie[ot];
            var Ke = ot + 4;
            J.canvas_width = 1 + q(Ie, Ke), Ke += 3, J.canvas_height = 1 + q(Ie, Ke), Ke += 3;
            break;
          case "ALPH":
            le = !0, Le = rt + 8, Se = ot - 8;
            break;
          case "ANIM":
            (J = it.header).bgcolor = j(Ie, ot), Ke = ot + 4, J.loop_count = (He = Ie)[(We = Ke) + 0] << 0 | He[We + 1] << 8, Ke += 2;
            break;
          case "ANMF":
            var St, J;
            (J = it.frames[oe] = {}).offset_x = 2 * q(Ie, ot), ot += 3, J.offset_y = 2 * q(Ie, ot), ot += 3, J.width = 1 + q(Ie, ot), ot += 3, J.height = 1 + q(Ie, ot), ot += 3, J.duration = q(Ie, ot), ot += 3, St = Ie[ot++], J.dispose = 1 & St, J.blend = St >> 1 & 1;
        }
        Je != "ANMF" && (ot += rt);
      }
      return it;
    }
  }(ye, 0);
  se.response = ye, se.rgbaoutput = !0, se.dataurl = !1;
  var ge = se.header ? se.header : null, Me = se.frames ? se.frames : null;
  if (ge) {
    ge.loop_counter = ge.loop_count, V = [ge.canvas_height], F = [ge.canvas_width];
    for (var Ye = 0; Ye < Me.length && Me[Ye].blend != 0; Ye++) ;
  }
  var $e = Me[0], tt = ae.WebPDecodeRGBA(ye, $e.src_off, $e.src_size, F, V);
  $e.rgba = tt, $e.imgwidth = F[0], $e.imgheight = V[0];
  for (var Be = 0; Be < F[0] * V[0] * 4; Be++) de[Be] = tt[Be];
  return this.width = F, this.height = V, this.data = de, this;
}
(function(x) {
  var d = function() {
    return typeof ad == "function";
  }, p = function(V, F, de, ae) {
    var ye = 4, se = _;
    switch (ae) {
      case x.image_compression.FAST:
        ye = 1, se = w;
        break;
      case x.image_compression.MEDIUM:
        ye = 6, se = c;
        break;
      case x.image_compression.SLOW:
        ye = 9, se = C;
    }
    V = v(V, F, de, se);
    var ge = ad(V, { level: ye });
    return x.__addimage__.arrayBufferToBinaryString(ge);
  }, v = function(V, F, de, ae) {
    for (var ye, se, ge, Me = V.length / F, Ye = new Uint8Array(V.length + Me), $e = q(), tt = 0; tt < Me; tt += 1) {
      if (ge = tt * F, ye = V.subarray(ge, ge + F), ae) Ye.set(ae(ye, de, se), ge + tt);
      else {
        for (var Be, Ie = $e.length, ot = []; Be < Ie; Be += 1) ot[Be] = $e[Be](ye, de, se);
        var it = j(ot.concat());
        Ye.set(ot[it], ge + tt);
      }
      se = ye;
    }
    return Ye;
  }, S = function(V) {
    var F = Array.apply([], V);
    return F.unshift(0), F;
  }, w = function(V, F) {
    var de, ae = [], ye = V.length;
    ae[0] = 1;
    for (var se = 0; se < ye; se += 1) de = V[se - F] || 0, ae[se + 1] = V[se] - de + 256 & 255;
    return ae;
  }, _ = function(V, F, de) {
    var ae, ye = [], se = V.length;
    ye[0] = 2;
    for (var ge = 0; ge < se; ge += 1) ae = de && de[ge] || 0, ye[ge + 1] = V[ge] - ae + 256 & 255;
    return ye;
  }, c = function(V, F, de) {
    var ae, ye, se = [], ge = V.length;
    se[0] = 3;
    for (var Me = 0; Me < ge; Me += 1) ae = V[Me - F] || 0, ye = de && de[Me] || 0, se[Me + 1] = V[Me] + 256 - (ae + ye >>> 1) & 255;
    return se;
  }, C = function(V, F, de) {
    var ae, ye, se, ge, Me = [], Ye = V.length;
    Me[0] = 4;
    for (var $e = 0; $e < Ye; $e += 1) ae = V[$e - F] || 0, ye = de && de[$e] || 0, se = de && de[$e - F] || 0, ge = N(ae, ye, se), Me[$e + 1] = V[$e] - ge + 256 & 255;
    return Me;
  }, N = function(V, F, de) {
    if (V === F && F === de) return V;
    var ae = Math.abs(F - de), ye = Math.abs(V - de), se = Math.abs(V + F - de - de);
    return ae <= ye && ae <= se ? V : ye <= se ? F : de;
  }, q = function() {
    return [S, w, _, c, C];
  }, j = function(V) {
    var F = V.map(function(de) {
      return de.reduce(function(ae, ye) {
        return ae + Math.abs(ye);
      }, 0);
    });
    return F.indexOf(Math.min.apply(null, F));
  };
  x.processPNG = function(V, F, de, ae) {
    var ye, se, ge, Me, Ye, $e, tt, Be, Ie, ot, it, oe, le, Le, Se, He = this.decode.FLATE_DECODE, We = "";
    if (this.__addimage__.isArrayBuffer(V) && (V = new Uint8Array(V)), this.__addimage__.isArrayBufferView(V)) {
      if (V = (ge = new O0(V)).imgData, se = ge.bits, ye = ge.colorSpace, Ye = ge.colors, [4, 6].indexOf(ge.colorType) !== -1) {
        if (ge.bits === 8) {
          Ie = (Be = ge.pixelBitlength == 32 ? new Uint32Array(ge.decodePixels().buffer) : ge.pixelBitlength == 16 ? new Uint16Array(ge.decodePixels().buffer) : new Uint8Array(ge.decodePixels().buffer)).length, it = new Uint8Array(Ie * ge.colors), ot = new Uint8Array(Ie);
          var Je, je = ge.pixelBitlength - ge.bits;
          for (Le = 0, Se = 0; Le < Ie; Le++) {
            for (le = Be[Le], Je = 0; Je < je; ) it[Se++] = le >>> Je & 255, Je += ge.bits;
            ot[Le] = le >>> Je & 255;
          }
        }
        if (ge.bits === 16) {
          Ie = (Be = new Uint32Array(ge.decodePixels().buffer)).length, it = new Uint8Array(Ie * (32 / ge.pixelBitlength) * ge.colors), ot = new Uint8Array(Ie * (32 / ge.pixelBitlength)), oe = ge.colors > 1, Le = 0, Se = 0;
          for (var rt = 0; Le < Ie; ) le = Be[Le++], it[Se++] = le >>> 0 & 255, oe && (it[Se++] = le >>> 16 & 255, le = Be[Le++], it[Se++] = le >>> 0 & 255), ot[rt++] = le >>> 16 & 255;
          se = 8;
        }
        ae !== x.image_compression.NONE && d() ? (V = p(it, ge.width * ge.colors, ge.colors, ae), tt = p(ot, ge.width, 1, ae)) : (V = it, tt = ot, He = void 0);
      }
      if (ge.colorType === 3 && (ye = this.color_spaces.INDEXED, $e = ge.palette, ge.transparency.indexed)) {
        var Ke = ge.transparency.indexed, St = 0;
        for (Le = 0, Ie = Ke.length; Le < Ie; ++Le) St += Ke[Le];
        if ((St /= 255) === Ie - 1 && Ke.indexOf(0) !== -1) Me = [Ke.indexOf(0)];
        else if (St !== Ie) {
          for (Be = ge.decodePixels(), ot = new Uint8Array(Be.length), Le = 0, Ie = Be.length; Le < Ie; Le++) ot[Le] = Ke[Be[Le]];
          tt = p(ot, ge.width, 1);
        }
      }
      var J = function(fe) {
        var _e;
        switch (fe) {
          case x.image_compression.FAST:
            _e = 11;
            break;
          case x.image_compression.MEDIUM:
            _e = 13;
            break;
          case x.image_compression.SLOW:
            _e = 14;
            break;
          default:
            _e = 12;
        }
        return _e;
      }(ae);
      return He === this.decode.FLATE_DECODE && (We = "/Predictor " + J + " "), We += "/Colors " + Ye + " /BitsPerComponent " + se + " /Columns " + ge.width, (this.__addimage__.isArrayBuffer(V) || this.__addimage__.isArrayBufferView(V)) && (V = this.__addimage__.arrayBufferToBinaryString(V)), (tt && this.__addimage__.isArrayBuffer(tt) || this.__addimage__.isArrayBufferView(tt)) && (tt = this.__addimage__.arrayBufferToBinaryString(tt)), { alias: de, data: V, index: F, filter: He, decodeParameters: We, transparency: Me, palette: $e, sMask: tt, predictor: J, width: ge.width, height: ge.height, bitsPerComponent: se, colorSpace: ye };
    }
  };
})(yi.API), function(x) {
  x.processGIF89A = function(d, p, v, S) {
    var w = new j0(d), _ = w.width, c = w.height, C = [];
    w.decodeAndBlitFrameRGBA(0, C);
    var N = { data: C, width: _, height: c }, q = new Ku(100).encode(N, 100);
    return x.processJPEG.call(this, q, p, v, S);
  }, x.processGIF87A = x.processGIF89A;
}(yi.API), Uo.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var x = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(x);
    for (var d = 0; d < x; d++) {
      var p = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), S = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0);
      this.palette[d] = { red: S, green: v, blue: p, quad: w };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, Uo.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var x = "bit" + this.bitPP, d = this.width * this.height * 4;
    this.data = new Uint8Array(d), this[x]();
  } catch (p) {
    pr.log("bit decode error:" + p);
  }
}, Uo.prototype.bit1 = function() {
  var x, d = Math.ceil(this.width / 8), p = d % 4;
  for (x = this.height - 1; x >= 0; x--) {
    for (var v = this.bottom_up ? x : this.height - 1 - x, S = 0; S < d; S++) for (var w = this.datav.getUint8(this.pos++, !0), _ = v * this.width * 4 + 8 * S * 4, c = 0; c < 8 && 8 * S + c < this.width; c++) {
      var C = this.palette[w >> 7 - c & 1];
      this.data[_ + 4 * c] = C.blue, this.data[_ + 4 * c + 1] = C.green, this.data[_ + 4 * c + 2] = C.red, this.data[_ + 4 * c + 3] = 255;
    }
    p !== 0 && (this.pos += 4 - p);
  }
}, Uo.prototype.bit4 = function() {
  for (var x = Math.ceil(this.width / 2), d = x % 4, p = this.height - 1; p >= 0; p--) {
    for (var v = this.bottom_up ? p : this.height - 1 - p, S = 0; S < x; S++) {
      var w = this.datav.getUint8(this.pos++, !0), _ = v * this.width * 4 + 2 * S * 4, c = w >> 4, C = 15 & w, N = this.palette[c];
      if (this.data[_] = N.blue, this.data[_ + 1] = N.green, this.data[_ + 2] = N.red, this.data[_ + 3] = 255, 2 * S + 1 >= this.width) break;
      N = this.palette[C], this.data[_ + 4] = N.blue, this.data[_ + 4 + 1] = N.green, this.data[_ + 4 + 2] = N.red, this.data[_ + 4 + 3] = 255;
    }
    d !== 0 && (this.pos += 4 - d);
  }
}, Uo.prototype.bit8 = function() {
  for (var x = this.width % 4, d = this.height - 1; d >= 0; d--) {
    for (var p = this.bottom_up ? d : this.height - 1 - d, v = 0; v < this.width; v++) {
      var S = this.datav.getUint8(this.pos++, !0), w = p * this.width * 4 + 4 * v;
      if (S < this.palette.length) {
        var _ = this.palette[S];
        this.data[w] = _.red, this.data[w + 1] = _.green, this.data[w + 2] = _.blue, this.data[w + 3] = 255;
      } else this.data[w] = 255, this.data[w + 1] = 255, this.data[w + 2] = 255, this.data[w + 3] = 255;
    }
    x !== 0 && (this.pos += 4 - x);
  }
}, Uo.prototype.bit15 = function() {
  for (var x = this.width % 3, d = parseInt("11111", 2), p = this.height - 1; p >= 0; p--) {
    for (var v = this.bottom_up ? p : this.height - 1 - p, S = 0; S < this.width; S++) {
      var w = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var _ = (w & d) / d * 255 | 0, c = (w >> 5 & d) / d * 255 | 0, C = (w >> 10 & d) / d * 255 | 0, N = w >> 15 ? 255 : 0, q = v * this.width * 4 + 4 * S;
      this.data[q] = C, this.data[q + 1] = c, this.data[q + 2] = _, this.data[q + 3] = N;
    }
    this.pos += x;
  }
}, Uo.prototype.bit16 = function() {
  for (var x = this.width % 3, d = parseInt("11111", 2), p = parseInt("111111", 2), v = this.height - 1; v >= 0; v--) {
    for (var S = this.bottom_up ? v : this.height - 1 - v, w = 0; w < this.width; w++) {
      var _ = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (_ & d) / d * 255 | 0, C = (_ >> 5 & p) / p * 255 | 0, N = (_ >> 11) / d * 255 | 0, q = S * this.width * 4 + 4 * w;
      this.data[q] = N, this.data[q + 1] = C, this.data[q + 2] = c, this.data[q + 3] = 255;
    }
    this.pos += x;
  }
}, Uo.prototype.bit24 = function() {
  for (var x = this.height - 1; x >= 0; x--) {
    for (var d = this.bottom_up ? x : this.height - 1 - x, p = 0; p < this.width; p++) {
      var v = this.datav.getUint8(this.pos++, !0), S = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0), _ = d * this.width * 4 + 4 * p;
      this.data[_] = w, this.data[_ + 1] = S, this.data[_ + 2] = v, this.data[_ + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, Uo.prototype.bit32 = function() {
  for (var x = this.height - 1; x >= 0; x--) for (var d = this.bottom_up ? x : this.height - 1 - x, p = 0; p < this.width; p++) {
    var v = this.datav.getUint8(this.pos++, !0), S = this.datav.getUint8(this.pos++, !0), w = this.datav.getUint8(this.pos++, !0), _ = this.datav.getUint8(this.pos++, !0), c = d * this.width * 4 + 4 * p;
    this.data[c] = w, this.data[c + 1] = S, this.data[c + 2] = v, this.data[c + 3] = _;
  }
}, Uo.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.processBMP = function(d, p, v, S) {
    var w = new Uo(d, !1), _ = w.width, c = w.height, C = { data: w.getData(), width: _, height: c }, N = new Ku(100).encode(C, 100);
    return x.processJPEG.call(this, N, p, v, S);
  };
}(yi.API), pf.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.processWEBP = function(d, p, v, S) {
    var w = new pf(d), _ = w.width, c = w.height, C = { data: w.getData(), width: _, height: c }, N = new Ku(100).encode(C, 100);
    return x.processJPEG.call(this, N, p, v, S);
  };
}(yi.API), yi.API.processRGBA = function(x, d, p) {
  for (var v = x.data, S = v.length, w = new Uint8Array(S / 4 * 3), _ = new Uint8Array(S / 4), c = 0, C = 0, N = 0; N < S; N += 4) {
    var q = v[N], j = v[N + 1], V = v[N + 2], F = v[N + 3];
    w[c++] = q, w[c++] = j, w[c++] = V, _[C++] = F;
  }
  var de = this.__addimage__.arrayBufferToBinaryString(w);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(_), data: de, index: d, alias: p, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: x.width, height: x.height };
}, yi.API.setLanguage = function(x) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[x] !== void 0 && (this.internal.languageSettings.languageCode = x, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Cc = yi.API, Vh = Cc.getCharWidthsArray = function(x, d) {
  var p, v, S = (d = d || {}).font || this.internal.getFont(), w = d.fontSize || this.internal.getFontSize(), _ = d.charSpace || this.internal.getCharSpace(), c = d.widths ? d.widths : S.metadata.Unicode.widths, C = c.fof ? c.fof : 1, N = d.kerning ? d.kerning : S.metadata.Unicode.kerning, q = N.fof ? N.fof : 1, j = d.doKerning !== !1, V = 0, F = x.length, de = 0, ae = c[0] || C, ye = [];
  for (p = 0; p < F; p++) v = x.charCodeAt(p), typeof S.metadata.widthOfString == "function" ? ye.push((S.metadata.widthOfGlyph(S.metadata.characterToGlyph(v)) + _ * (1e3 / w) || 0) / 1e3) : (V = j && rr(N[v]) === "object" && !isNaN(parseInt(N[v][de], 10)) ? N[v][de] / q : 0, ye.push((c[v] || ae) / C + V)), de = v;
  return ye;
}, cf = Cc.getStringUnitWidth = function(x, d) {
  var p = (d = d || {}).fontSize || this.internal.getFontSize(), v = d.font || this.internal.getFont(), S = d.charSpace || this.internal.getCharSpace();
  return Cc.processArabic && (x = Cc.processArabic(x)), typeof v.metadata.widthOfString == "function" ? v.metadata.widthOfString(x, p, S) / p : Vh.apply(this, arguments).reduce(function(w, _) {
    return w + _;
  }, 0);
}, hf = function(x, d, p, v) {
  for (var S = [], w = 0, _ = x.length, c = 0; w !== _ && c + d[w] < p; ) c += d[w], w++;
  S.push(x.slice(0, w));
  var C = w;
  for (c = 0; w !== _; ) c + d[w] > v && (S.push(x.slice(C, w)), c = 0, C = w), c += d[w], w++;
  return C !== w && S.push(x.slice(C, w)), S;
}, uf = function(x, d, p) {
  p || (p = {});
  var v, S, w, _, c, C, N, q = [], j = [q], V = p.textIndent || 0, F = 0, de = 0, ae = x.split(" "), ye = Vh.apply(this, [" ", p])[0];
  if (C = p.lineIndent === -1 ? ae[0].length + 2 : p.lineIndent || 0) {
    var se = Array(C).join(" "), ge = [];
    ae.map(function(Ye) {
      (Ye = Ye.split(/\s*\n/)).length > 1 ? ge = ge.concat(Ye.map(function($e, tt) {
        return (tt && $e.length ? `
` : "") + $e;
      })) : ge.push(Ye[0]);
    }), ae = ge, C = cf.apply(this, [se, p]);
  }
  for (w = 0, _ = ae.length; w < _; w++) {
    var Me = 0;
    if (v = ae[w], C && v[0] == `
` && (v = v.substr(1), Me = 1), V + F + (de = (S = Vh.apply(this, [v, p])).reduce(function(Ye, $e) {
      return Ye + $e;
    }, 0)) > d || Me) {
      if (de > d) {
        for (c = hf.apply(this, [v, S, d - (V + F), d]), q.push(c.shift()), q = [c.pop()]; c.length; ) j.push([c.shift()]);
        de = S.slice(v.length - (q[0] ? q[0].length : 0)).reduce(function(Ye, $e) {
          return Ye + $e;
        }, 0);
      } else q = [v];
      j.push(q), V = de + C, F = ye;
    } else q.push(v), V += F + de, F = ye;
  }
  return N = C ? function(Ye, $e) {
    return ($e ? se : "") + Ye.join(" ");
  } : function(Ye) {
    return Ye.join(" ");
  }, j.map(N);
}, Cc.splitTextToSize = function(x, d, p) {
  var v, S = (p = p || {}).fontSize || this.internal.getFontSize(), w = (function(q) {
    if (q.widths && q.kerning) return { widths: q.widths, kerning: q.kerning };
    var j = this.internal.getFont(q.fontName, q.fontStyle);
    return j.metadata.Unicode ? { widths: j.metadata.Unicode.widths || { 0: 1 }, kerning: j.metadata.Unicode.kerning || {} } : { font: j.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, p);
  v = Array.isArray(x) ? x : String(x).split(/\r?\n/);
  var _ = 1 * this.internal.scaleFactor * d / S;
  w.textIndent = p.textIndent ? 1 * p.textIndent * this.internal.scaleFactor / S : 0, w.lineIndent = p.lineIndent;
  var c, C, N = [];
  for (c = 0, C = v.length; c < C; c++) N = N.concat(uf.apply(this, [v[c], _, w]));
  return N;
}, function(x) {
  x.__fontmetrics__ = x.__fontmetrics__ || {};
  for (var d = "klmnopqrstuvwxyz", p = {}, v = {}, S = 0; S < d.length; S++) p[d[S]] = "0123456789abcdef"[S], v["0123456789abcdef"[S]] = d[S];
  var w = function(j) {
    return "0x" + parseInt(j, 10).toString(16);
  }, _ = x.__fontmetrics__.compress = function(j) {
    var V, F, de, ae, ye = ["{"];
    for (var se in j) {
      if (V = j[se], isNaN(parseInt(se, 10)) ? F = "'" + se + "'" : (se = parseInt(se, 10), F = (F = w(se).slice(2)).slice(0, -1) + v[F.slice(-1)]), typeof V == "number") V < 0 ? (de = w(V).slice(3), ae = "-") : (de = w(V).slice(2), ae = ""), de = ae + de.slice(0, -1) + v[de.slice(-1)];
      else {
        if (rr(V) !== "object") throw new Error("Don't know what to do with value type " + rr(V) + ".");
        de = _(V);
      }
      ye.push(F + de);
    }
    return ye.push("}"), ye.join("");
  }, c = x.__fontmetrics__.uncompress = function(j) {
    if (typeof j != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var V, F, de, ae, ye = {}, se = 1, ge = ye, Me = [], Ye = "", $e = "", tt = j.length - 1, Be = 1; Be < tt; Be += 1) (ae = j[Be]) == "'" ? V ? (de = V.join(""), V = void 0) : V = [] : V ? V.push(ae) : ae == "{" ? (Me.push([ge, de]), ge = {}, de = void 0) : ae == "}" ? ((F = Me.pop())[0][F[1]] = ge, de = void 0, ge = F[0]) : ae == "-" ? se = -1 : de === void 0 ? p.hasOwnProperty(ae) ? (Ye += p[ae], de = parseInt(Ye, 16) * se, se = 1, Ye = "") : Ye += ae : p.hasOwnProperty(ae) ? ($e += p[ae], ge[de] = parseInt($e, 16) * se, se = 1, de = void 0, $e = "") : $e += ae;
    return ye;
  }, C = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, N = { Unicode: { Courier: C, "Courier-Bold": C, "Courier-BoldOblique": C, "Courier-Oblique": C, Helvetica: C, "Helvetica-Bold": C, "Helvetica-BoldOblique": C, "Helvetica-Oblique": C, "Times-Roman": C, "Times-Bold": C, "Times-BoldItalic": C, "Times-Italic": C } }, q = { Unicode: { "Courier-Oblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  x.events.push(["addFont", function(j) {
    var V = j.font, F = q.Unicode[V.postScriptName];
    F && (V.metadata.Unicode = {}, V.metadata.Unicode.widths = F.widths, V.metadata.Unicode.kerning = F.kerning);
    var de = N.Unicode[V.postScriptName];
    de && (V.metadata.Unicode.encoding = de, V.encoding = de.codePages[0]);
  }]);
}(yi.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = function(p) {
    for (var v = p.length, S = new Uint8Array(v), w = 0; w < v; w++) S[w] = p.charCodeAt(w);
    return S;
  };
  x.API.events.push(["addFont", function(p) {
    var v = void 0, S = p.font, w = p.instance;
    if (!S.isStandardFont) {
      if (w === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + S.postScriptName + "').");
      if (typeof (v = w.existsFileInVFS(S.postScriptName) === !1 ? w.loadFile(S.postScriptName) : w.getFileFromVFS(S.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + S.postScriptName + "').");
      (function(_, c) {
        c = /^\x00\x01\x00\x00/.test(c) ? d(c) : d(yh(c)), _.metadata = x.API.TTFFont.open(c), _.metadata.Unicode = _.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, _.metadata.glyIdsUsed = [0];
      })(S, v);
    }
  }]);
}(yi), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(x) {
  function d() {
    return (_i.canvg ? Promise.resolve(_i.canvg) : import("./index.es-DoMiftKY-DCTHeYrH.js")).catch(function(p) {
      return Promise.reject(new Error("Could not load canvg: " + p));
    }).then(function(p) {
      return p.default ? p.default : p;
    });
  }
  yi.API.addSvgAsImage = function(p, v, S, w, _, c, C, N) {
    if (isNaN(v) || isNaN(S)) throw pr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(w) || isNaN(_)) throw pr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var q = document.createElement("canvas");
    q.width = w, q.height = _;
    var j = q.getContext("2d");
    j.fillStyle = "#fff", j.fillRect(0, 0, q.width, q.height);
    var V = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, F = this;
    return d().then(function(de) {
      return de.fromString(j, p, V);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(de) {
      return de.render(V);
    }).then(function() {
      F.addImage(q.toDataURL("image/jpeg", 1), v, S, w, _, C, N);
    });
  };
}(), yi.API.putTotalPages = function(x) {
  var d, p = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (d = new RegExp(x, "g"), p = this.internal.getNumberOfPages()) : (d = new RegExp(this.pdfEscape16(x, this.internal.getFont()), "g"), p = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var v = 1; v <= this.internal.getNumberOfPages(); v++) for (var S = 0; S < this.internal.pages[v].length; S++) this.internal.pages[v][S] = this.internal.pages[v][S].replace(d, p);
  return this;
}, yi.API.viewerPreferences = function(x, d) {
  var p;
  x = x || {}, d = d || !1;
  var v, S, w, _ = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, c = Object.keys(_), C = [], N = 0, q = 0, j = 0;
  function V(de, ae) {
    var ye, se = !1;
    for (ye = 0; ye < de.length; ye += 1) de[ye] === ae && (se = !0);
    return se;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(_)), this.internal.viewerpreferences.isSubscribed = !1), p = this.internal.viewerpreferences.configuration, x === "reset" || d === !0) {
    var F = c.length;
    for (j = 0; j < F; j += 1) p[c[j]].value = p[c[j]].defaultValue, p[c[j]].explicitSet = !1;
  }
  if (rr(x) === "object") {
    for (S in x) if (w = x[S], V(c, S) && w !== void 0) {
      if (p[S].type === "boolean" && typeof w == "boolean") p[S].value = w;
      else if (p[S].type === "name" && V(p[S].valueSet, w)) p[S].value = w;
      else if (p[S].type === "integer" && Number.isInteger(w)) p[S].value = w;
      else if (p[S].type === "array") {
        for (N = 0; N < w.length; N += 1) if (v = !0, w[N].length === 1 && typeof w[N][0] == "number") C.push(String(w[N] - 1));
        else if (w[N].length > 1) {
          for (q = 0; q < w[N].length; q += 1) typeof w[N][q] != "number" && (v = !1);
          v === !0 && C.push([w[N][0] - 1, w[N][1] - 1].join(" "));
        }
        p[S].value = "[" + C.join(" ") + "]";
      } else p[S].value = p[S].defaultValue;
      p[S].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var de, ae = [];
    for (de in p) p[de].explicitSet === !0 && (p[de].type === "name" ? ae.push("/" + de + " /" + p[de].value) : ae.push("/" + de + " " + p[de].value));
    ae.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + ae.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = p, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(x) {
  var d = function() {
    var v = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', S = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), w = unescape(encodeURIComponent(v)), _ = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), c = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), C = unescape(encodeURIComponent("</x:xmpmeta>")), N = w.length + _.length + c.length + S.length + C.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + N + " >>"), this.internal.write("stream"), this.internal.write(S + w + _ + c + C), this.internal.write("endstream"), this.internal.write("endobj");
  }, p = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  x.addMetadata = function(v, S) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: v, namespaceuri: S || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", p), this.internal.events.subscribe("postPutResources", d)), this;
  };
}(yi.API), function(x) {
  var d = x.API, p = d.pdfEscape16 = function(w, _) {
    for (var c, C = _.metadata.Unicode.widths, N = ["", "0", "00", "000", "0000"], q = [""], j = 0, V = w.length; j < V; ++j) {
      if (c = _.metadata.characterToGlyph(w.charCodeAt(j)), _.metadata.glyIdsUsed.push(c), _.metadata.toUnicode[c] = w.charCodeAt(j), C.indexOf(c) == -1 && (C.push(c), C.push([parseInt(_.metadata.widthOfGlyph(c), 10)])), c == "0") return q.join("");
      c = c.toString(16), q.push(N[4 - c.length], c);
    }
    return q.join("");
  }, v = function(w) {
    var _, c, C, N, q, j, V;
    for (q = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, C = [], j = 0, V = (c = Object.keys(w).sort(function(F, de) {
      return F - de;
    })).length; j < V; j++) _ = c[j], C.length >= 100 && (q += `
` + C.length + ` beginbfchar
` + C.join(`
`) + `
endbfchar`, C = []), w[_] !== void 0 && w[_] !== null && typeof w[_].toString == "function" && (N = ("0000" + w[_].toString(16)).slice(-4), _ = ("0000" + (+_).toString(16)).slice(-4), C.push("<" + _ + "><" + N + ">"));
    return C.length && (q += `
` + C.length + ` beginbfchar
` + C.join(`
`) + `
endbfchar
`), q += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  d.events.push(["putFont", function(w) {
    (function(_) {
      var c = _.font, C = _.out, N = _.newObject, q = _.putStream;
      if (c.metadata instanceof x.API.TTFFont && c.encoding === "Identity-H") {
        for (var j = c.metadata.Unicode.widths, V = c.metadata.subset.encode(c.metadata.glyIdsUsed, 1), F = "", de = 0; de < V.length; de++) F += String.fromCharCode(V[de]);
        var ae = N();
        q({ data: F, addLength1: !0, objectId: ae }), C("endobj");
        var ye = N();
        q({ data: v(c.metadata.toUnicode), addLength1: !0, objectId: ye }), C("endobj");
        var se = N();
        C("<<"), C("/Type /FontDescriptor"), C("/FontName /" + Mc(c.fontName)), C("/FontFile2 " + ae + " 0 R"), C("/FontBBox " + x.API.PDFObject.convert(c.metadata.bbox)), C("/Flags " + c.metadata.flags), C("/StemV " + c.metadata.stemV), C("/ItalicAngle " + c.metadata.italicAngle), C("/Ascent " + c.metadata.ascender), C("/Descent " + c.metadata.decender), C("/CapHeight " + c.metadata.capHeight), C(">>"), C("endobj");
        var ge = N();
        C("<<"), C("/Type /Font"), C("/BaseFont /" + Mc(c.fontName)), C("/FontDescriptor " + se + " 0 R"), C("/W " + x.API.PDFObject.convert(j)), C("/CIDToGIDMap /Identity"), C("/DW 1000"), C("/Subtype /CIDFontType2"), C("/CIDSystemInfo"), C("<<"), C("/Supplement 0"), C("/Registry (Adobe)"), C("/Ordering (" + c.encoding + ")"), C(">>"), C(">>"), C("endobj"), c.objectNumber = N(), C("<<"), C("/Type /Font"), C("/Subtype /Type0"), C("/ToUnicode " + ye + " 0 R"), C("/BaseFont /" + Mc(c.fontName)), C("/Encoding /" + c.encoding), C("/DescendantFonts [" + ge + " 0 R]"), C(">>"), C("endobj"), c.isAlreadyPutted = !0;
      }
    })(w);
  }]), d.events.push(["putFont", function(w) {
    (function(_) {
      var c = _.font, C = _.out, N = _.newObject, q = _.putStream;
      if (c.metadata instanceof x.API.TTFFont && c.encoding === "WinAnsiEncoding") {
        for (var j = c.metadata.rawData, V = "", F = 0; F < j.length; F++) V += String.fromCharCode(j[F]);
        var de = N();
        q({ data: V, addLength1: !0, objectId: de }), C("endobj");
        var ae = N();
        q({ data: v(c.metadata.toUnicode), addLength1: !0, objectId: ae }), C("endobj");
        var ye = N();
        C("<<"), C("/Descent " + c.metadata.decender), C("/CapHeight " + c.metadata.capHeight), C("/StemV " + c.metadata.stemV), C("/Type /FontDescriptor"), C("/FontFile2 " + de + " 0 R"), C("/Flags 96"), C("/FontBBox " + x.API.PDFObject.convert(c.metadata.bbox)), C("/FontName /" + Mc(c.fontName)), C("/ItalicAngle " + c.metadata.italicAngle), C("/Ascent " + c.metadata.ascender), C(">>"), C("endobj"), c.objectNumber = N();
        for (var se = 0; se < c.metadata.hmtx.widths.length; se++) c.metadata.hmtx.widths[se] = parseInt(c.metadata.hmtx.widths[se] * (1e3 / c.metadata.head.unitsPerEm));
        C("<</Subtype/TrueType/Type/Font/ToUnicode " + ae + " 0 R/BaseFont/" + Mc(c.fontName) + "/FontDescriptor " + ye + " 0 R/Encoding/" + c.encoding + " /FirstChar 29 /LastChar 255 /Widths " + x.API.PDFObject.convert(c.metadata.hmtx.widths) + ">>"), C("endobj"), c.isAlreadyPutted = !0;
      }
    })(w);
  }]);
  var S = function(w) {
    var _, c = w.text || "", C = w.x, N = w.y, q = w.options || {}, j = w.mutex || {}, V = j.pdfEscape, F = j.activeFontKey, de = j.fonts, ae = F, ye = "", se = 0, ge = "", Me = de[ae].encoding;
    if (de[ae].encoding !== "Identity-H") return { text: c, x: C, y: N, options: q, mutex: j };
    for (ge = c, ae = F, Array.isArray(c) && (ge = c[0]), se = 0; se < ge.length; se += 1) de[ae].metadata.hasOwnProperty("cmap") && (_ = de[ae].metadata.cmap.unicode.codeMap[ge[se].charCodeAt(0)]), _ || ge[se].charCodeAt(0) < 256 && de[ae].metadata.hasOwnProperty("Unicode") ? ye += ge[se] : ye += "";
    var Ye = "";
    return parseInt(ae.slice(1)) < 14 || Me === "WinAnsiEncoding" ? Ye = V(ye, ae).split("").map(function($e) {
      return $e.charCodeAt(0).toString(16);
    }).join("") : Me === "Identity-H" && (Ye = p(ye, de[ae])), j.isHex = !0, { text: Ye, x: C, y: N, options: q, mutex: j };
  };
  d.events.push(["postProcessText", function(w) {
    var _ = w.text || "", c = [], C = { text: _, x: w.x, y: w.y, options: w.options, mutex: w.mutex };
    if (Array.isArray(_)) {
      var N = 0;
      for (N = 0; N < _.length; N += 1) Array.isArray(_[N]) && _[N].length === 3 ? c.push([S(Object.assign({}, C, { text: _[N][0] })).text, _[N][1], _[N][2]]) : c.push(S(Object.assign({}, C, { text: _[N] })).text);
      w.text = c;
    } else w.text = S(Object.assign({}, C, { text: _ })).text;
  }]);
}(yi), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var d = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  x.existsFileInVFS = function(p) {
    return d.call(this), this.internal.vFS[p] !== void 0;
  }, x.addFileToVFS = function(p, v) {
    return d.call(this), this.internal.vFS[p] = v, this;
  }, x.getFileFromVFS = function(p) {
    return d.call(this), this.internal.vFS[p] !== void 0 ? this.internal.vFS[p] : null;
  };
}(yi.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(x) {
  x.__bidiEngine__ = x.prototype.__bidiEngine__ = function(v) {
    var S, w, _, c, C, N, q, j = d, V = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], F = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], de = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, ae = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, ye = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], se = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), ge = !1, Me = 0;
    this.__bidiEngine__ = {};
    var Ye = function(oe) {
      var le = oe.charCodeAt(), Le = le >> 8, Se = ae[Le];
      return Se !== void 0 ? j[256 * Se + (255 & le)] : Le === 252 || Le === 253 ? "AL" : se.test(Le) ? "L" : Le === 8 ? "R" : "N";
    }, $e = function(oe) {
      for (var le, Le = 0; Le < oe.length; Le++) {
        if ((le = Ye(oe.charAt(Le))) === "L") return !1;
        if (le === "R") return !0;
      }
      return !1;
    }, tt = function(oe, le, Le, Se) {
      var He, We, Je, je, rt = le[Se];
      switch (rt) {
        case "L":
        case "R":
          ge = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          ge && (rt = "AN");
          break;
        case "AL":
          ge = !0, rt = "R";
          break;
        case "WS":
          rt = "N";
          break;
        case "CS":
          Se < 1 || Se + 1 >= le.length || (He = Le[Se - 1]) !== "EN" && He !== "AN" || (We = le[Se + 1]) !== "EN" && We !== "AN" ? rt = "N" : ge && (We = "AN"), rt = We === He ? We : "N";
          break;
        case "ES":
          rt = (He = Se > 0 ? Le[Se - 1] : "B") === "EN" && Se + 1 < le.length && le[Se + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Se > 0 && Le[Se - 1] === "EN") {
            rt = "EN";
            break;
          }
          if (ge) {
            rt = "N";
            break;
          }
          for (Je = Se + 1, je = le.length; Je < je && le[Je] === "ET"; ) Je++;
          rt = Je < je && le[Je] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (_ && !c) {
            for (je = le.length, Je = Se + 1; Je < je && le[Je] === "NSM"; ) Je++;
            if (Je < je) {
              var Ke = oe[Se], St = Ke >= 1425 && Ke <= 2303 || Ke === 64286;
              if (He = le[Je], St && (He === "R" || He === "AL")) {
                rt = "R";
                break;
              }
            }
          }
          rt = Se < 1 || (He = le[Se - 1]) === "B" ? "N" : Le[Se - 1];
          break;
        case "B":
          ge = !1, S = !0, rt = Me;
          break;
        case "S":
          w = !0, rt = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          ge = !1;
          break;
        case "BN":
          rt = "N";
      }
      return rt;
    }, Be = function(oe, le, Le) {
      var Se = oe.split("");
      return Le && Ie(Se, Le, { hiLevel: Me }), Se.reverse(), le && le.reverse(), Se.join("");
    }, Ie = function(oe, le, Le) {
      var Se, He, We, Je, je, rt = -1, Ke = oe.length, St = 0, J = [], fe = Me ? F : V, _e = [];
      for (ge = !1, S = !1, w = !1, He = 0; He < Ke; He++) _e[He] = Ye(oe[He]);
      for (We = 0; We < Ke; We++) {
        if (je = St, J[We] = tt(oe, _e, J, We), Se = 240 & (St = fe[je][de[J[We]]]), St &= 15, le[We] = Je = fe[St][5], Se > 0) if (Se === 16) {
          for (He = rt; He < We; He++) le[He] = 1;
          rt = -1;
        } else rt = -1;
        if (fe[St][6]) rt === -1 && (rt = We);
        else if (rt > -1) {
          for (He = rt; He < We; He++) le[He] = Je;
          rt = -1;
        }
        _e[We] === "B" && (le[We] = 0), Le.hiLevel |= Je;
      }
      w && function(Ce, De, Oe) {
        for (var qe = 0; qe < Oe; qe++) if (Ce[qe] === "S") {
          De[qe] = Me;
          for (var Ze = qe - 1; Ze >= 0 && Ce[Ze] === "WS"; Ze--) De[Ze] = Me;
        }
      }(_e, le, Ke);
    }, ot = function(oe, le, Le, Se, He) {
      if (!(He.hiLevel < oe)) {
        if (oe === 1 && Me === 1 && !S) return le.reverse(), void (Le && Le.reverse());
        for (var We, Je, je, rt, Ke = le.length, St = 0; St < Ke; ) {
          if (Se[St] >= oe) {
            for (je = St + 1; je < Ke && Se[je] >= oe; ) je++;
            for (rt = St, Je = je - 1; rt < Je; rt++, Je--) We = le[rt], le[rt] = le[Je], le[Je] = We, Le && (We = Le[rt], Le[rt] = Le[Je], Le[Je] = We);
            St = je;
          }
          St++;
        }
      }
    }, it = function(oe, le, Le) {
      var Se = oe.split(""), He = { hiLevel: Me };
      return Le || (Le = []), Ie(Se, Le, He), function(We, Je, je) {
        if (je.hiLevel !== 0 && q) for (var rt, Ke = 0; Ke < We.length; Ke++) Je[Ke] === 1 && (rt = ye.indexOf(We[Ke])) >= 0 && (We[Ke] = ye[rt + 1]);
      }(Se, Le, He), ot(2, Se, le, Le, He), ot(1, Se, le, Le, He), Se.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(oe, le, Le) {
      if (function(He, We) {
        if (We) for (var Je = 0; Je < He.length; Je++) We[Je] = Je;
        c === void 0 && (c = $e(He)), N === void 0 && (N = $e(He));
      }(oe, le), _ || !C || N) if (_ && C && c ^ N) Me = c ? 1 : 0, oe = Be(oe, le, Le);
      else if (!_ && C && N) Me = c ? 1 : 0, oe = it(oe, le, Le), oe = Be(oe, le);
      else if (!_ || c || C || N) {
        if (_ && !C && c ^ N) oe = Be(oe, le), c ? (Me = 0, oe = it(oe, le, Le)) : (Me = 1, oe = it(oe, le, Le), oe = Be(oe, le));
        else if (_ && c && !C && N) Me = 1, oe = it(oe, le, Le), oe = Be(oe, le);
        else if (!_ && !C && c ^ N) {
          var Se = q;
          c ? (Me = 1, oe = it(oe, le, Le), Me = 0, q = !1, oe = it(oe, le, Le), q = Se) : (Me = 0, oe = it(oe, le, Le), oe = Be(oe, le), Me = 1, q = !1, oe = it(oe, le, Le), q = Se, oe = Be(oe, le));
        }
      } else Me = 0, oe = it(oe, le, Le);
      else Me = c ? 1 : 0, oe = it(oe, le, Le);
      return oe;
    }, this.__bidiEngine__.setOptions = function(oe) {
      oe && (_ = oe.isInputVisual, C = oe.isOutputVisual, c = oe.isInputRtl, N = oe.isOutputRtl, q = oe.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(v), this.__bidiEngine__;
  };
  var d = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], p = new x.__bidiEngine__({ isInputVisual: !0 });
  x.API.events.push(["postProcessText", function(v) {
    var S = v.text, w = (v.x, v.y, v.options || {}), _ = (v.mutex, w.lang, []);
    if (w.isInputVisual = typeof w.isInputVisual != "boolean" || w.isInputVisual, p.setOptions(w), Object.prototype.toString.call(S) === "[object Array]") {
      var c = 0;
      for (_ = [], c = 0; c < S.length; c += 1) Object.prototype.toString.call(S[c]) === "[object Array]" ? _.push([p.doBidiReorder(S[c][0]), S[c][1], S[c][2]]) : _.push([p.doBidiReorder(S[c])]);
      v.text = _;
    } else v.text = p.doBidiReorder(S);
    p.setOptions({ isInputVisual: !0 });
  }]);
}(yi), yi.API.TTFFont = function() {
  function x(d) {
    var p;
    if (this.rawData = d, p = this.contents = new Dl(d), this.contents.pos = 4, p.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    p.pos = 0, this.parse(), this.subset = new t1(this), this.registerTTF();
  }
  return x.open = function(d) {
    return new x(d);
  }, x.prototype.parse = function() {
    return this.directory = new q0(this.contents), this.head = new U0(this), this.name = new H0(this), this.cmap = new Bf(this), this.toUnicode = {}, this.hhea = new $0(this), this.maxp = new X0(this), this.hmtx = new Y0(this), this.post = new G0(this), this.os2 = new Z0(this), this.loca = new e1(this), this.glyf = new J0(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, x.prototype.registerTTF = function() {
    var d, p, v, S, w;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var _, c, C, N;
      for (N = [], _ = 0, c = (C = this.bbox).length; _ < c; _++) d = C[_], N.push(Math.round(d * this.scaleFactor));
      return N;
    }).call(this), this.stemV = 0, this.post.exists ? (v = 255 & (S = this.post.italic_angle), 32768 & (p = S >> 16) && (p = -(1 + (65535 ^ p))), this.italicAngle = +(p + "." + v)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (w = this.familyClass) === 1 || w === 2 || w === 3 || w === 4 || w === 5 || w === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, x.prototype.characterToGlyph = function(d) {
    var p;
    return ((p = this.cmap.unicode) != null ? p.codeMap[d] : void 0) || 0;
  }, x.prototype.widthOfGlyph = function(d) {
    var p;
    return p = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(d).advance * p;
  }, x.prototype.widthOfString = function(d, p, v) {
    var S, w, _, c;
    for (_ = 0, w = 0, c = (d = "" + d).length; 0 <= c ? w < c : w > c; w = 0 <= c ? ++w : --w) S = d.charCodeAt(w), _ += this.widthOfGlyph(this.characterToGlyph(S)) + v * (1e3 / p) || 0;
    return _ * (p / 1e3);
  }, x.prototype.lineHeight = function(d, p) {
    var v;
    return p == null && (p = !1), v = p ? this.lineGap : 0, (this.ascender + v - this.decender) / 1e3 * d;
  }, x;
}();
var Go, Dl = function() {
  function x(d) {
    this.data = d ?? [], this.pos = 0, this.length = this.data.length;
  }
  return x.prototype.readByte = function() {
    return this.data[this.pos++];
  }, x.prototype.writeByte = function(d) {
    return this.data[this.pos++] = d;
  }, x.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, x.prototype.writeUInt32 = function(d) {
    return this.writeByte(d >>> 24 & 255), this.writeByte(d >> 16 & 255), this.writeByte(d >> 8 & 255), this.writeByte(255 & d);
  }, x.prototype.readInt32 = function() {
    var d;
    return (d = this.readUInt32()) >= 2147483648 ? d - 4294967296 : d;
  }, x.prototype.writeInt32 = function(d) {
    return d < 0 && (d += 4294967296), this.writeUInt32(d);
  }, x.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, x.prototype.writeUInt16 = function(d) {
    return this.writeByte(d >> 8 & 255), this.writeByte(255 & d);
  }, x.prototype.readInt16 = function() {
    var d;
    return (d = this.readUInt16()) >= 32768 ? d - 65536 : d;
  }, x.prototype.writeInt16 = function(d) {
    return d < 0 && (d += 65536), this.writeUInt16(d);
  }, x.prototype.readString = function(d) {
    var p, v;
    for (v = [], p = 0; 0 <= d ? p < d : p > d; p = 0 <= d ? ++p : --p) v[p] = String.fromCharCode(this.readByte());
    return v.join("");
  }, x.prototype.writeString = function(d) {
    var p, v, S;
    for (S = [], p = 0, v = d.length; 0 <= v ? p < v : p > v; p = 0 <= v ? ++p : --p) S.push(this.writeByte(d.charCodeAt(p)));
    return S;
  }, x.prototype.readShort = function() {
    return this.readInt16();
  }, x.prototype.writeShort = function(d) {
    return this.writeInt16(d);
  }, x.prototype.readLongLong = function() {
    var d, p, v, S, w, _, c, C;
    return d = this.readByte(), p = this.readByte(), v = this.readByte(), S = this.readByte(), w = this.readByte(), _ = this.readByte(), c = this.readByte(), C = this.readByte(), 128 & d ? -1 * (72057594037927940 * (255 ^ d) + 281474976710656 * (255 ^ p) + 1099511627776 * (255 ^ v) + 4294967296 * (255 ^ S) + 16777216 * (255 ^ w) + 65536 * (255 ^ _) + 256 * (255 ^ c) + (255 ^ C) + 1) : 72057594037927940 * d + 281474976710656 * p + 1099511627776 * v + 4294967296 * S + 16777216 * w + 65536 * _ + 256 * c + C;
  }, x.prototype.writeLongLong = function(d) {
    var p, v;
    return p = Math.floor(d / 4294967296), v = 4294967295 & d, this.writeByte(p >> 24 & 255), this.writeByte(p >> 16 & 255), this.writeByte(p >> 8 & 255), this.writeByte(255 & p), this.writeByte(v >> 24 & 255), this.writeByte(v >> 16 & 255), this.writeByte(v >> 8 & 255), this.writeByte(255 & v);
  }, x.prototype.readInt = function() {
    return this.readInt32();
  }, x.prototype.writeInt = function(d) {
    return this.writeInt32(d);
  }, x.prototype.read = function(d) {
    var p, v;
    for (p = [], v = 0; 0 <= d ? v < d : v > d; v = 0 <= d ? ++v : --v) p.push(this.readByte());
    return p;
  }, x.prototype.write = function(d) {
    var p, v, S, w;
    for (w = [], v = 0, S = d.length; v < S; v++) p = d[v], w.push(this.writeByte(p));
    return w;
  }, x;
}(), q0 = function() {
  var x;
  function d(p) {
    var v, S, w;
    for (this.scalarType = p.readInt(), this.tableCount = p.readShort(), this.searchRange = p.readShort(), this.entrySelector = p.readShort(), this.rangeShift = p.readShort(), this.tables = {}, S = 0, w = this.tableCount; 0 <= w ? S < w : S > w; S = 0 <= w ? ++S : --S) v = { tag: p.readString(4), checksum: p.readInt(), offset: p.readInt(), length: p.readInt() }, this.tables[v.tag] = v;
  }
  return d.prototype.encode = function(p) {
    var v, S, w, _, c, C, N, q, j, V, F, de, ae;
    for (ae in F = Object.keys(p).length, C = Math.log(2), j = 16 * Math.floor(Math.log(F) / C), _ = Math.floor(j / C), q = 16 * F - j, (S = new Dl()).writeInt(this.scalarType), S.writeShort(F), S.writeShort(j), S.writeShort(_), S.writeShort(q), w = 16 * F, N = S.pos + w, c = null, de = [], p) for (V = p[ae], S.writeString(ae), S.writeInt(x(V)), S.writeInt(N), S.writeInt(V.length), de = de.concat(V), ae === "head" && (c = N), N += V.length; N % 4; ) de.push(0), N++;
    return S.write(de), v = 2981146554 - x(S.data), S.pos = c + 8, S.writeUInt32(v), S.data;
  }, x = function(p) {
    var v, S, w, _;
    for (p = Of.call(p); p.length % 4; ) p.push(0);
    for (w = new Dl(p), S = 0, v = 0, _ = p.length; v < _; v = v += 4) S += w.readUInt32();
    return 4294967295 & S;
  }, d;
}(), V0 = {}.hasOwnProperty, Da = function(x, d) {
  for (var p in d) V0.call(d, p) && (x[p] = d[p]);
  function v() {
    this.constructor = x;
  }
  return v.prototype = d.prototype, x.prototype = new v(), x.__super__ = d.prototype, x;
};
Go = function() {
  function x(d) {
    var p;
    this.file = d, p = this.file.directory.tables[this.tag], this.exists = !!p, p && (this.offset = p.offset, this.length = p.length, this.parse(this.file.contents));
  }
  return x.prototype.parse = function() {
  }, x.prototype.encode = function() {
  }, x.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, x;
}();
var U0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "head", d.prototype.parse = function(p) {
    return p.pos = this.offset, this.version = p.readInt(), this.revision = p.readInt(), this.checkSumAdjustment = p.readInt(), this.magicNumber = p.readInt(), this.flags = p.readShort(), this.unitsPerEm = p.readShort(), this.created = p.readLongLong(), this.modified = p.readLongLong(), this.xMin = p.readShort(), this.yMin = p.readShort(), this.xMax = p.readShort(), this.yMax = p.readShort(), this.macStyle = p.readShort(), this.lowestRecPPEM = p.readShort(), this.fontDirectionHint = p.readShort(), this.indexToLocFormat = p.readShort(), this.glyphDataFormat = p.readShort();
  }, d.prototype.encode = function(p) {
    var v;
    return (v = new Dl()).writeInt(this.version), v.writeInt(this.revision), v.writeInt(this.checkSumAdjustment), v.writeInt(this.magicNumber), v.writeShort(this.flags), v.writeShort(this.unitsPerEm), v.writeLongLong(this.created), v.writeLongLong(this.modified), v.writeShort(this.xMin), v.writeShort(this.yMin), v.writeShort(this.xMax), v.writeShort(this.yMax), v.writeShort(this.macStyle), v.writeShort(this.lowestRecPPEM), v.writeShort(this.fontDirectionHint), v.writeShort(p), v.writeShort(this.glyphDataFormat), v.data;
  }, d;
}(), ff = function() {
  function x(d, p) {
    var v, S, w, _, c, C, N, q, j, V, F, de, ae, ye, se, ge, Me;
    switch (this.platformID = d.readUInt16(), this.encodingID = d.readShort(), this.offset = p + d.readInt(), j = d.pos, d.pos = this.offset, this.format = d.readUInt16(), this.length = d.readUInt16(), this.language = d.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (C = 0; C < 256; ++C) this.codeMap[C] = d.readByte();
        break;
      case 4:
        for (F = d.readUInt16(), V = F / 2, d.pos += 6, w = function() {
          var Ye, $e;
          for ($e = [], C = Ye = 0; 0 <= V ? Ye < V : Ye > V; C = 0 <= V ? ++Ye : --Ye) $e.push(d.readUInt16());
          return $e;
        }(), d.pos += 2, ae = function() {
          var Ye, $e;
          for ($e = [], C = Ye = 0; 0 <= V ? Ye < V : Ye > V; C = 0 <= V ? ++Ye : --Ye) $e.push(d.readUInt16());
          return $e;
        }(), N = function() {
          var Ye, $e;
          for ($e = [], C = Ye = 0; 0 <= V ? Ye < V : Ye > V; C = 0 <= V ? ++Ye : --Ye) $e.push(d.readUInt16());
          return $e;
        }(), q = function() {
          var Ye, $e;
          for ($e = [], C = Ye = 0; 0 <= V ? Ye < V : Ye > V; C = 0 <= V ? ++Ye : --Ye) $e.push(d.readUInt16());
          return $e;
        }(), S = (this.length - d.pos + this.offset) / 2, c = function() {
          var Ye, $e;
          for ($e = [], C = Ye = 0; 0 <= S ? Ye < S : Ye > S; C = 0 <= S ? ++Ye : --Ye) $e.push(d.readUInt16());
          return $e;
        }(), C = se = 0, Me = w.length; se < Me; C = ++se) for (ye = w[C], v = ge = de = ae[C]; de <= ye ? ge <= ye : ge >= ye; v = de <= ye ? ++ge : --ge) q[C] === 0 ? _ = v + N[C] : (_ = c[q[C] / 2 + (v - de) - (V - C)] || 0) !== 0 && (_ += N[C]), this.codeMap[v] = 65535 & _;
    }
    d.pos = j;
  }
  return x.encode = function(d, p) {
    var v, S, w, _, c, C, N, q, j, V, F, de, ae, ye, se, ge, Me, Ye, $e, tt, Be, Ie, ot, it, oe, le, Le, Se, He, We, Je, je, rt, Ke, St, J, fe, _e, Ce, De, Oe, qe, Ze, wt, bt, Tt;
    switch (Se = new Dl(), _ = Object.keys(d).sort(function(Mt, Qt) {
      return Mt - Qt;
    }), p) {
      case "macroman":
        for (ae = 0, ye = function() {
          var Mt = [];
          for (de = 0; de < 256; ++de) Mt.push(0);
          return Mt;
        }(), ge = { 0: 0 }, w = {}, He = 0, rt = _.length; He < rt; He++) ge[Ze = d[S = _[He]]] == null && (ge[Ze] = ++ae), w[S] = { old: d[S], new: ge[d[S]] }, ye[S] = ge[d[S]];
        return Se.writeUInt16(1), Se.writeUInt16(0), Se.writeUInt32(12), Se.writeUInt16(0), Se.writeUInt16(262), Se.writeUInt16(0), Se.write(ye), { charMap: w, subtable: Se.data, maxGlyphID: ae + 1 };
      case "unicode":
        for (le = [], j = [], Me = 0, ge = {}, v = {}, se = N = null, We = 0, Ke = _.length; We < Ke; We++) ge[$e = d[S = _[We]]] == null && (ge[$e] = ++Me), v[S] = { old: $e, new: ge[$e] }, c = ge[$e] - S, se != null && c === N || (se && j.push(se), le.push(S), N = c), se = S;
        for (se && j.push(se), j.push(65535), le.push(65535), it = 2 * (ot = le.length), Ie = 2 * Math.pow(Math.log(ot) / Math.LN2, 2), V = Math.log(Ie / 2) / Math.LN2, Be = 2 * ot - Ie, C = [], tt = [], F = [], de = Je = 0, St = le.length; Je < St; de = ++Je) {
          if (oe = le[de], q = j[de], oe === 65535) {
            C.push(0), tt.push(0);
            break;
          }
          if (oe - (Le = v[oe].new) >= 32768) for (C.push(0), tt.push(2 * (F.length + ot - de)), S = je = oe; oe <= q ? je <= q : je >= q; S = oe <= q ? ++je : --je) F.push(v[S].new);
          else C.push(Le - oe), tt.push(0);
        }
        for (Se.writeUInt16(3), Se.writeUInt16(1), Se.writeUInt32(12), Se.writeUInt16(4), Se.writeUInt16(16 + 8 * ot + 2 * F.length), Se.writeUInt16(0), Se.writeUInt16(it), Se.writeUInt16(Ie), Se.writeUInt16(V), Se.writeUInt16(Be), Oe = 0, J = j.length; Oe < J; Oe++) S = j[Oe], Se.writeUInt16(S);
        for (Se.writeUInt16(0), qe = 0, fe = le.length; qe < fe; qe++) S = le[qe], Se.writeUInt16(S);
        for (wt = 0, _e = C.length; wt < _e; wt++) c = C[wt], Se.writeUInt16(c);
        for (bt = 0, Ce = tt.length; bt < Ce; bt++) Ye = tt[bt], Se.writeUInt16(Ye);
        for (Tt = 0, De = F.length; Tt < De; Tt++) ae = F[Tt], Se.writeUInt16(ae);
        return { charMap: v, subtable: Se.data, maxGlyphID: Me + 1 };
    }
  }, x;
}(), Bf = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "cmap", d.prototype.parse = function(p) {
    var v, S, w;
    for (p.pos = this.offset, this.version = p.readUInt16(), w = p.readUInt16(), this.tables = [], this.unicode = null, S = 0; 0 <= w ? S < w : S > w; S = 0 <= w ? ++S : --S) v = new ff(p, this.offset), this.tables.push(v), v.isUnicode && this.unicode == null && (this.unicode = v);
    return !0;
  }, d.encode = function(p, v) {
    var S, w;
    return v == null && (v = "macroman"), S = ff.encode(p, v), (w = new Dl()).writeUInt16(0), w.writeUInt16(1), S.table = w.data.concat(S.subtable), S;
  }, d;
}(), $0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "hhea", d.prototype.parse = function(p) {
    return p.pos = this.offset, this.version = p.readInt(), this.ascender = p.readShort(), this.decender = p.readShort(), this.lineGap = p.readShort(), this.advanceWidthMax = p.readShort(), this.minLeftSideBearing = p.readShort(), this.minRightSideBearing = p.readShort(), this.xMaxExtent = p.readShort(), this.caretSlopeRise = p.readShort(), this.caretSlopeRun = p.readShort(), this.caretOffset = p.readShort(), p.pos += 8, this.metricDataFormat = p.readShort(), this.numberOfMetrics = p.readUInt16();
  }, d;
}(), Z0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "OS/2", d.prototype.parse = function(p) {
    if (p.pos = this.offset, this.version = p.readUInt16(), this.averageCharWidth = p.readShort(), this.weightClass = p.readUInt16(), this.widthClass = p.readUInt16(), this.type = p.readShort(), this.ySubscriptXSize = p.readShort(), this.ySubscriptYSize = p.readShort(), this.ySubscriptXOffset = p.readShort(), this.ySubscriptYOffset = p.readShort(), this.ySuperscriptXSize = p.readShort(), this.ySuperscriptYSize = p.readShort(), this.ySuperscriptXOffset = p.readShort(), this.ySuperscriptYOffset = p.readShort(), this.yStrikeoutSize = p.readShort(), this.yStrikeoutPosition = p.readShort(), this.familyClass = p.readShort(), this.panose = function() {
      var v, S;
      for (S = [], v = 0; v < 10; ++v) S.push(p.readByte());
      return S;
    }(), this.charRange = function() {
      var v, S;
      for (S = [], v = 0; v < 4; ++v) S.push(p.readInt());
      return S;
    }(), this.vendorID = p.readString(4), this.selection = p.readShort(), this.firstCharIndex = p.readShort(), this.lastCharIndex = p.readShort(), this.version > 0 && (this.ascent = p.readShort(), this.descent = p.readShort(), this.lineGap = p.readShort(), this.winAscent = p.readShort(), this.winDescent = p.readShort(), this.codePageRange = function() {
      var v, S;
      for (S = [], v = 0; v < 2; v = ++v) S.push(p.readInt());
      return S;
    }(), this.version > 1)) return this.xHeight = p.readShort(), this.capHeight = p.readShort(), this.defaultChar = p.readShort(), this.breakChar = p.readShort(), this.maxContext = p.readShort();
  }, d;
}(), G0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "post", d.prototype.parse = function(p) {
    var v, S, w;
    switch (p.pos = this.offset, this.format = p.readInt(), this.italicAngle = p.readInt(), this.underlinePosition = p.readShort(), this.underlineThickness = p.readShort(), this.isFixedPitch = p.readInt(), this.minMemType42 = p.readInt(), this.maxMemType42 = p.readInt(), this.minMemType1 = p.readInt(), this.maxMemType1 = p.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var _;
        for (S = p.readUInt16(), this.glyphNameIndex = [], _ = 0; 0 <= S ? _ < S : _ > S; _ = 0 <= S ? ++_ : --_) this.glyphNameIndex.push(p.readUInt16());
        for (this.names = [], w = []; p.pos < this.offset + this.length; ) v = p.readByte(), w.push(this.names.push(p.readString(v)));
        return w;
      case 151552:
        return S = p.readUInt16(), this.offsets = p.read(S);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var c, C, N;
          for (N = [], _ = c = 0, C = this.file.maxp.numGlyphs; 0 <= C ? c < C : c > C; _ = 0 <= C ? ++c : --c) N.push(p.readUInt32());
          return N;
        }).call(this);
    }
  }, d;
}(), W0 = function(x, d) {
  this.raw = x, this.length = x.length, this.platformID = d.platformID, this.encodingID = d.encodingID, this.languageID = d.languageID;
}, H0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "name", d.prototype.parse = function(p) {
    var v, S, w, _, c, C, N, q, j, V, F;
    for (p.pos = this.offset, p.readShort(), v = p.readShort(), C = p.readShort(), S = [], _ = 0; 0 <= v ? _ < v : _ > v; _ = 0 <= v ? ++_ : --_) S.push({ platformID: p.readShort(), encodingID: p.readShort(), languageID: p.readShort(), nameID: p.readShort(), length: p.readShort(), offset: this.offset + C + p.readShort() });
    for (N = {}, _ = j = 0, V = S.length; j < V; _ = ++j) w = S[_], p.pos = w.offset, q = p.readString(w.length), c = new W0(q, w), N[F = w.nameID] == null && (N[F] = []), N[w.nameID].push(c);
    this.strings = N, this.copyright = N[0], this.fontFamily = N[1], this.fontSubfamily = N[2], this.uniqueSubfamily = N[3], this.fontName = N[4], this.version = N[5];
    try {
      this.postscriptName = N[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = N[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = N[7], this.manufacturer = N[8], this.designer = N[9], this.description = N[10], this.vendorUrl = N[11], this.designerUrl = N[12], this.license = N[13], this.licenseUrl = N[14], this.preferredFamily = N[15], this.preferredSubfamily = N[17], this.compatibleFull = N[18], this.sampleText = N[19];
  }, d;
}(), X0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "maxp", d.prototype.parse = function(p) {
    return p.pos = this.offset, this.version = p.readInt(), this.numGlyphs = p.readUInt16(), this.maxPoints = p.readUInt16(), this.maxContours = p.readUInt16(), this.maxCompositePoints = p.readUInt16(), this.maxComponentContours = p.readUInt16(), this.maxZones = p.readUInt16(), this.maxTwilightPoints = p.readUInt16(), this.maxStorage = p.readUInt16(), this.maxFunctionDefs = p.readUInt16(), this.maxInstructionDefs = p.readUInt16(), this.maxStackElements = p.readUInt16(), this.maxSizeOfInstructions = p.readUInt16(), this.maxComponentElements = p.readUInt16(), this.maxComponentDepth = p.readUInt16();
  }, d;
}(), Y0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "hmtx", d.prototype.parse = function(p) {
    var v, S, w, _, c, C, N;
    for (p.pos = this.offset, this.metrics = [], v = 0, C = this.file.hhea.numberOfMetrics; 0 <= C ? v < C : v > C; v = 0 <= C ? ++v : --v) this.metrics.push({ advance: p.readUInt16(), lsb: p.readInt16() });
    for (w = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var q, j;
      for (j = [], v = q = 0; 0 <= w ? q < w : q > w; v = 0 <= w ? ++q : --q) j.push(p.readInt16());
      return j;
    }(), this.widths = (function() {
      var q, j, V, F;
      for (F = [], q = 0, j = (V = this.metrics).length; q < j; q++) _ = V[q], F.push(_.advance);
      return F;
    }).call(this), S = this.widths[this.widths.length - 1], N = [], v = c = 0; 0 <= w ? c < w : c > w; v = 0 <= w ? ++c : --c) N.push(this.widths.push(S));
    return N;
  }, d.prototype.forGlyph = function(p) {
    return p in this.metrics ? this.metrics[p] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[p - this.metrics.length] };
  }, d;
}(), Of = [].slice, J0 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "glyf", d.prototype.parse = function() {
    return this.cache = {};
  }, d.prototype.glyphFor = function(p) {
    var v, S, w, _, c, C, N, q, j, V;
    return p in this.cache ? this.cache[p] : (_ = this.file.loca, v = this.file.contents, S = _.indexOf(p), (w = _.lengthOf(p)) === 0 ? this.cache[p] = null : (v.pos = this.offset + S, c = (C = new Dl(v.read(w))).readShort(), q = C.readShort(), V = C.readShort(), N = C.readShort(), j = C.readShort(), this.cache[p] = c === -1 ? new Q0(C, q, V, N, j) : new K0(C, c, q, V, N, j), this.cache[p]));
  }, d.prototype.encode = function(p, v, S) {
    var w, _, c, C, N;
    for (c = [], _ = [], C = 0, N = v.length; C < N; C++) w = p[v[C]], _.push(c.length), w && (c = c.concat(w.encode(S)));
    return _.push(c.length), { table: c, offsets: _ };
  }, d;
}(), K0 = function() {
  function x(d, p, v, S, w, _) {
    this.raw = d, this.numberOfContours = p, this.xMin = v, this.yMin = S, this.xMax = w, this.yMax = _, this.compound = !1;
  }
  return x.prototype.encode = function() {
    return this.raw.data;
  }, x;
}(), Q0 = function() {
  function x(d, p, v, S, w) {
    var _, c;
    for (this.raw = d, this.xMin = p, this.yMin = v, this.xMax = S, this.yMax = w, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], _ = this.raw; c = _.readShort(), this.glyphOffsets.push(_.pos), this.glyphIDs.push(_.readUInt16()), 32 & c; ) _.pos += 1 & c ? 4 : 2, 128 & c ? _.pos += 8 : 64 & c ? _.pos += 4 : 8 & c && (_.pos += 2);
  }
  return x.prototype.encode = function() {
    var d, p, v;
    for (p = new Dl(Of.call(this.raw.data)), d = 0, v = this.glyphIDs.length; d < v; ++d) p.pos = this.glyphOffsets[d];
    return p.data;
  }, x;
}(), e1 = function(x) {
  function d() {
    return d.__super__.constructor.apply(this, arguments);
  }
  return Da(d, Go), d.prototype.tag = "loca", d.prototype.parse = function(p) {
    var v, S;
    return p.pos = this.offset, v = this.file.head.indexToLocFormat, this.offsets = v === 0 ? (function() {
      var w, _;
      for (_ = [], S = 0, w = this.length; S < w; S += 2) _.push(2 * p.readUInt16());
      return _;
    }).call(this) : (function() {
      var w, _;
      for (_ = [], S = 0, w = this.length; S < w; S += 4) _.push(p.readUInt32());
      return _;
    }).call(this);
  }, d.prototype.indexOf = function(p) {
    return this.offsets[p];
  }, d.prototype.lengthOf = function(p) {
    return this.offsets[p + 1] - this.offsets[p];
  }, d.prototype.encode = function(p, v) {
    for (var S = new Uint32Array(this.offsets.length), w = 0, _ = 0, c = 0; c < S.length; ++c) if (S[c] = w, _ < v.length && v[_] == c) {
      ++_, S[c] = w;
      var C = this.offsets[c], N = this.offsets[c + 1] - C;
      N > 0 && (w += N);
    }
    for (var q = new Array(4 * S.length), j = 0; j < S.length; ++j) q[4 * j + 3] = 255 & S[j], q[4 * j + 2] = (65280 & S[j]) >> 8, q[4 * j + 1] = (16711680 & S[j]) >> 16, q[4 * j] = (4278190080 & S[j]) >> 24;
    return q;
  }, d;
}(), t1 = function() {
  function x(d) {
    this.font = d, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return x.prototype.generateCmap = function() {
    var d, p, v, S, w;
    for (p in S = this.font.cmap.tables[0].codeMap, d = {}, w = this.subset) v = w[p], d[p] = S[v];
    return d;
  }, x.prototype.glyphsFor = function(d) {
    var p, v, S, w, _, c, C;
    for (S = {}, _ = 0, c = d.length; _ < c; _++) S[w = d[_]] = this.font.glyf.glyphFor(w);
    for (w in p = [], S) (v = S[w]) != null && v.compound && p.push.apply(p, v.glyphIDs);
    if (p.length > 0) for (w in C = this.glyphsFor(p)) v = C[w], S[w] = v;
    return S;
  }, x.prototype.encode = function(d, p) {
    var v, S, w, _, c, C, N, q, j, V, F, de, ae, ye, se;
    for (S in v = Bf.encode(this.generateCmap(), "unicode"), _ = this.glyphsFor(d), F = { 0: 0 }, se = v.charMap) F[(C = se[S]).old] = C.new;
    for (de in V = v.maxGlyphID, _) de in F || (F[de] = V++);
    return q = function(ge) {
      var Me, Ye;
      for (Me in Ye = {}, ge) Ye[ge[Me]] = Me;
      return Ye;
    }(F), j = Object.keys(q).sort(function(ge, Me) {
      return ge - Me;
    }), ae = function() {
      var ge, Me, Ye;
      for (Ye = [], ge = 0, Me = j.length; ge < Me; ge++) c = j[ge], Ye.push(q[c]);
      return Ye;
    }(), w = this.font.glyf.encode(_, ae, F), N = this.font.loca.encode(w.offsets, ae), ye = { cmap: this.font.cmap.raw(), glyf: w.table, loca: N, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(p) }, this.font.os2.exists && (ye["OS/2"] = this.font.os2.raw()), this.font.directory.encode(ye);
  }, x;
}();
yi.API.PDFObject = function() {
  var x;
  function d() {
  }
  return x = function(p, v) {
    return (Array(v + 1).join("0") + p).slice(-v);
  }, d.convert = function(p) {
    var v, S, w, _;
    if (Array.isArray(p)) return "[" + function() {
      var c, C, N;
      for (N = [], c = 0, C = p.length; c < C; c++) v = p[c], N.push(d.convert(v));
      return N;
    }().join(" ") + "]";
    if (typeof p == "string") return "/" + p;
    if (p != null && p.isString) return "(" + p + ")";
    if (p instanceof Date) return "(D:" + x(p.getUTCFullYear(), 4) + x(p.getUTCMonth(), 2) + x(p.getUTCDate(), 2) + x(p.getUTCHours(), 2) + x(p.getUTCMinutes(), 2) + x(p.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(p) === "[object Object]") {
      for (S in w = ["<<"], p) _ = p[S], w.push("/" + S + " " + d.convert(_));
      return w.push(">>"), w.join(`
`);
    }
    return "" + p;
  }, d;
}();
const yd = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, Kh = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, Qh = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class i1 {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(d, p = El.A4, v = 300, S = Ea.PNG, w = qc.mm, _ = "map", c = "maplibregl-marker", C = yd, N = "maplibregl-ctrl-attrib-inner", q = Kh, j = Qh) {
    $i(this, "map"), $i(this, "width"), $i(this, "height"), $i(this, "dpi"), $i(this, "format"), $i(this, "unit"), $i(this, "fileName"), $i(this, "markerClassName"), $i(this, "markerCirclePaint"), $i(this, "attributionClassName"), $i(this, "attributionOptions"), $i(this, "northIconOptions"), this.map = d, this.width = p[0], this.height = p[1], this.dpi = v, this.format = S, this.unit = w, this.fileName = _, this.markerClassName = c, this.markerCirclePaint = C, this.attributionClassName = N, this.attributionOptions = q, this.northIconOptions = j;
  }
  renderMapPost(d) {
    return d;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(d) {
    const p = this.getMarkers();
    for (let v = 0; v < p.length; v++) {
      const S = p.item(v);
      if (!S) continue;
      const w = S.getAttribute("style");
      if (!w) continue;
      const _ = /translate\(([^,]+)px,\s*([^,]+)px\)/, c = w.match(_);
      if (!c) continue;
      const C = parseInt(c[1]), N = parseInt(c[2]), q = this.map.unproject([C, N]), j = `point${v}`;
      d.addSource(j, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [q.lng, q.lat]
        }
      }), d.addLayer({
        id: j,
        source: j,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return d;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const d = this;
    JsLoadingOverlay.show({
      overlayBackgroundColor: "#5D5959",
      overlayOpacity: "0.6",
      spinnerIcon: "ball-spin",
      spinnerColor: "#2400FD",
      spinnerSize: "2x",
      overlayIDName: "overlay",
      spinnerIDName: "spinner",
      offsetX: 0,
      offsetY: 0,
      containerID: null,
      lockScroll: !1,
      overlayZIndex: 9998,
      spinnerZIndex: 9999
    });
    const p = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return d.dpi / 96;
      }
    });
    const v = document.createElement("div");
    v.className = "hidden-map", document.body.appendChild(v);
    const S = document.createElement("div");
    S.style.width = this.toPixels(this.width), S.style.height = this.toPixels(this.height), v.appendChild(S);
    const w = this.map.getStyle();
    if (w && w.sources) {
      const c = w.sources;
      Object.keys(c).forEach((C) => {
        const N = c[C];
        Object.keys(N).forEach((q) => {
          N[q] || delete N[q];
        });
      });
    }
    let _ = this.getRenderedMap(S, w);
    _.on("load", () => {
      this.addNorthIconToMap(_).then(() => {
        _.once("idle", () => {
          this.addAttributions(_) ? _.once("idle", () => {
            _ = this.renderMapPost(_), this.getMarkers().length === 0 ? this.exportImage(_, v, p) : (_ = this.renderMarkers(_), _.once("idle", () => {
              this.exportImage(_, v, p);
            }));
          }) : (_ = this.renderMapPost(_), this.getMarkers().length === 0 ? this.exportImage(_, v, p) : (_ = this.renderMarkers(_), _.once("idle", () => {
            this.exportImage(_, v, p);
          })));
        });
      });
    });
  }
  stripHtml(d) {
    const p = document.createElement("div");
    return p.innerHTML = d, p.textContent || p.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(d, p) {
    const v = d.getContainer(), S = parseInt(v.style.width.replace("px", ""));
    return parseInt(`${S * p}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(d, p, v = 0) {
    const S = d.getContainer();
    let w = 0, _ = 0;
    switch (p) {
      case "top-left":
        w = 0 + v, _ = 0 + v;
        break;
      case "top-right":
        w = parseInt(S.style.width.replace("px", "")) - v, _ = 0 + v;
        break;
      case "bottom-left":
        w = 0 + v, _ = parseInt(S.style.height.replace("px", "")) - v;
        break;
      case "bottom-right":
        w = parseInt(S.style.width.replace("px", "")) - v, _ = parseInt(S.style.height.replace("px", "")) - v;
        break;
    }
    return [w, _];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(d) {
    const p = this.getIconWidth(d, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((v) => {
      const S = new Image(p, p);
      S.onload = () => {
        this.northIconOptions.imageName && d.addImage(this.northIconOptions.imageName, S), v();
      };
      function w(_) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(_);
      }
      this.northIconOptions.image && (S.src = w(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(d) {
    let p = this.northIconOptions.visibility ?? "visible";
    return d.getZoom() < 2 && this.width > this.height && (p = "none"), new Promise((v) => {
      this.addNorthIconImage(d).then(() => {
        const S = this.getIconWidth(
          d,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, w = this.getElementPosition(
          d,
          this.northIconOptions.position ?? "top-right",
          S
        ), _ = d.unproject(w), c = this.northIconOptions.imageName ?? "gl-export-north-icon";
        d.addSource(c, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [_.lng, _.lat]
            },
            properties: {}
          }
        }), d.addLayer({
          id: c,
          source: c,
          type: "symbol",
          layout: {
            "icon-image": c,
            "icon-size": 1,
            "icon-rotate": d.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: p
          },
          paint: {}
        }), v();
      });
    });
  }
  addAttributions(d) {
    var p;
    if (!this.map.getStyle().glyphs) return !1;
    const v = d.getContainer(), S = this.attributionOptions.position ?? "bottom-right", w = this.getElementPosition(d, S, 5), _ = w[0], c = d.unproject(w), C = v.getElementsByClassName(this.attributionClassName), N = [];
    if ((C == null ? void 0 : C.length) > 0) {
      const ye = C.item(0);
      if (ye)
        for (let se = 0; se < ye.children.length; se++) {
          const ge = ye.children.item(se);
          ge && N.push(this.stripHtml(ge.outerHTML));
        }
    } else {
      const ye = this.map.getStyle().sources;
      Object.keys(ye).forEach((se) => {
        const ge = ye[se];
        if ("attribution" in ge) {
          const Me = ge.attribution;
          N.push(this.stripHtml(Me));
        }
      });
    }
    if (N.length === 0) return !1;
    const q = N.join(" | "), j = "attribution";
    d.addSource(j, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [c.lng, c.lat]
        },
        properties: {
          attribution: q
        }
      }
    });
    const V = this.map.getStyle().layers.filter(
      (ye) => ye.type === "symbol" && ye.layout && "text-font" in ye.layout
    ), F = V.length > 0 && V[0].layout ? V[0].layout["text-font"] : (p = this.attributionOptions.style) == null ? void 0 : p.fallbackTextFont;
    let de = this.attributionOptions.visibility ?? "visible";
    d.getZoom() < 2 && this.width > this.height && (de = "none");
    const ae = this.attributionOptions.style;
    return d.addLayer({
      id: j,
      source: j,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": F,
        "text-max-width": parseInt(`${_ / ae.textSize}`),
        "text-anchor": S,
        "text-justify": ["top-right", "bottom-right"].includes(S) ? "right" : "left",
        "text-size": ae.textSize,
        "text-allow-overlap": !0,
        visibility: de
      },
      paint: {
        "text-halo-color": ae.textHaloColor,
        "text-halo-width": ae.textHaloWidth,
        "text-color": ae.textColor
      }
    }), !0;
  }
  exportImage(d, p, v) {
    var S;
    const w = d.getCanvas(), _ = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Ea.PNG:
        this.toPNG(w, _);
        break;
      case Ea.JPEG:
        this.toJPEG(w, _);
        break;
      case Ea.PDF:
        this.toPDF(d, _);
        break;
      case Ea.SVG:
        this.toSVG(w, _);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    d.remove(), (S = p.parentNode) == null || S.removeChild(p), Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return v;
      }
    }), p.remove(), JsLoadingOverlay.hide();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(d, p) {
    const v = document.createElement("a");
    v.href = d.toDataURL(), v.download = p, v.click(), v.remove();
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toJPEG(d, p) {
    const v = d.toDataURL("image/jpeg", 0.85), S = document.createElement("a");
    S.href = v, S.download = p, S.click(), S.remove();
  }
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(d, p) {
    const v = d.getCanvas(), S = new yi({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    S.addImage(
      v.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: w, lat: _ } = d.getCenter();
    S.setProperties({
      title: d.getStyle().name,
      subject: `center: [${w}, ${_}], zoom: ${d.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), S.save(p);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toSVG(d, p) {
    const v = d.toDataURL("image/png"), S = Number(this.toPixels(this.width, this.dpi).replace("px", "")), w = Number(this.toPixels(this.height, this.dpi).replace("px", "")), _ = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${S}" 
      height="${w}" 
      viewBox="0 0 ${S} ${w}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${v}" width="${S}" height="${w}"></image>
    </svg>`, c = document.createElement("a");
    c.href = `data:application/xml,${encodeURIComponent(_)}`, c.download = p, c.click(), c.remove();
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(d, p = 96) {
    return this.unit === qc.mm && (p /= 25.4), `${p * d}px`;
  }
}
class r1 extends i1 {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. deafult is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(d, p = El.A4, v = 300, S = Ea.PNG, w = qc.mm, _ = "map", c = yd, C = Kh, N = Qh) {
    super(
      d,
      p,
      v,
      S,
      w,
      _,
      "maplibregl-marker",
      c,
      "maplibregl-ctrl-attrib-inner",
      C,
      N
    );
  }
  getRenderedMap(d, p) {
    const v = new jc.Map({
      container: d,
      style: p,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transfrom request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (v.setMaxPitch(85), v.setPitch(this.map.getPitch()));
    const S = (this.map.style.imageManager || {}).images || [];
    return Object.keys(S).forEach((w) => {
      S[w].data && v.addImage(w, S[w].data);
    }), v;
  }
  renderMapPost(d) {
    const p = this.map.getTerrain();
    return p && d.setTerrain({
      source: p.source,
      exaggeration: p.exaggeration
    }), d;
  }
}
class jf {
  constructor(d) {
    $i(this, "controlContainer"), $i(this, "exportContainer"), $i(this, "crosshair"), $i(this, "printableArea"), $i(this, "map"), $i(this, "exportButton"), $i(this, "options", {
      PageSize: El.A4,
      PageOrientation: zc.Landscape,
      Format: Ea.PDF,
      DPI: Xh[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(El),
      Filename: "map",
      markerCirclePaint: yd,
      attributionOptions: Kh,
      northIconOptions: Qh
    }), $i(this, "MAPLIB_CSS_PREFIX", "maplibregl"), d && (d.attributionOptions = Object.assign(
      Kh,
      d.attributionOptions
    ), d.northIconOptions = Object.assign(Qh, d.northIconOptions), this.options = Object.assign(this.options, d)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const d = this.options.Local ?? "en";
    return s0(d);
  }
  onAdd(d) {
    var p;
    this.map = d, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const v = document.createElement("TABLE");
    v.className = "print-table";
    const S = {};
    (p = this.options.AllowedSizes) == null || p.forEach((q) => {
      El[q] && (S[q] = El[q]);
    });
    const w = this.createSelection(
      S,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      (q, j) => JSON.stringify(q[j])
    );
    v.appendChild(w);
    const _ = this.createSelection(
      zc,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      (q, j) => q[j]
    );
    v.appendChild(_);
    const c = this.createSelection(
      Ea,
      this.getTranslation().Format,
      "format-type",
      this.options.Format,
      (q, j) => q[j]
    );
    v.appendChild(c);
    const C = this.createSelection(
      Xh,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      (q, j) => q[j]
    );
    v.appendChild(C), this.exportContainer.appendChild(v);
    const N = document.createElement("button");
    return N.type = "button", N.textContent = this.getTranslation().Generate, N.classList.add("generate-button"), N.addEventListener("click", () => {
      const q = document.getElementById("mapbox-gl-export-page-size"), j = document.getElementById("mapbox-gl-export-page-orientation"), V = document.getElementById("mapbox-gl-export-format-type"), F = document.getElementById("mapbox-gl-export-dpi-type"), de = j.value;
      let ae = JSON.parse(q.value);
      de === zc.Portrait && (ae = ae.reverse()), this.generateMap(
        d,
        ae,
        Number(F.value),
        V.value,
        qc.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(N), this.controlContainer;
  }
  generateMap(d, p, v, S, w, _) {
    new r1(
      d,
      p,
      v,
      S,
      w,
      _,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(d, p, v, S, w) {
    const _ = document.createElement("label");
    _.textContent = p;
    const c = document.createElement("select");
    c.setAttribute("id", `mapbox-gl-export-${v}`), c.style.width = "100%", Object.keys(d).forEach((j) => {
      const V = document.createElement("option");
      V.setAttribute("value", w(d, j)), V.appendChild(document.createTextNode(j)), V.setAttribute("name", v), S === d[j] && (V.selected = !0), c.appendChild(V);
    }), c.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const C = document.createElement("TR"), N = document.createElement("TD"), q = document.createElement("TD");
    return N.appendChild(_), q.appendChild(c), C.appendChild(N), C.appendChild(q), C;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(d) {
    this.controlContainer && !this.controlContainer.contains(d.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(d) {
    this.options.Crosshair === !0 && (d === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new $g(this.map), this.crosshair.create()));
  }
  togglePrintableArea(d) {
    this.options.PrintableArea === !0 && (d === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new Zg(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const d = document.getElementById("mapbox-gl-export-page-size"), p = document.getElementById("mapbox-gl-export-page-orientation").value;
    let v = JSON.parse(d.value);
    p === zc.Portrait && (v = v.reverse()), this.printableArea.updateArea(v[0], v[1]);
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function Qu(x, d, p, v) {
  return new (p || (p = Promise))(function(S, w) {
    function _(N) {
      try {
        C(v.next(N));
      } catch (q) {
        w(q);
      }
    }
    function c(N) {
      try {
        C(v.throw(N));
      } catch (q) {
        w(q);
      }
    }
    function C(N) {
      N.done ? S(N.value) : new p(function(q) {
        q(N.value);
      }).then(_, c);
    }
    C((v = v.apply(x, d || [])).next());
  });
}
var gh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function su(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var qf = s1, n1 = Object.prototype.hasOwnProperty;
function s1() {
  for (var x = {}, d = 0; d < arguments.length; d++) {
    var p = arguments[d];
    for (var v in p)
      n1.call(p, v) && (x[v] = p[v]);
  }
  return x;
}
var $o = /* @__PURE__ */ su(qf), Vf = { exports: {} };
(function(x, d) {
  (function() {
    var p = {};
    x.exports = p, p.simpleFilter = function(v, S) {
      return S.filter(function(w) {
        return p.test(v, w);
      });
    }, p.test = function(v, S) {
      return p.match(v, S) !== null;
    }, p.match = function(v, S, w) {
      w = w || {};
      var _ = 0, c = [], C = S.length, N = 0, q = 0, j = w.pre || "", V = w.post || "", F = w.caseSensitive && S || S.toLowerCase(), de;
      v = w.caseSensitive && v || v.toLowerCase();
      for (var ae = 0; ae < C; ae++)
        de = S[ae], F[ae] === v[_] ? (de = j + de + V, _ += 1, q += 1 + q) : q = 0, N += q, c[c.length] = de;
      return _ === v.length ? (N = F === v ? 1 / 0 : N, { rendered: c.join(""), score: N }) : null;
    }, p.filter = function(v, S, w) {
      return !S || S.length === 0 ? [] : typeof v != "string" ? S : (w = w || {}, S.reduce(function(_, c, C, N) {
        var q = c;
        w.extract && (q = w.extract(c));
        var j = p.match(v, q, w);
        return j != null && (_[_.length] = {
          string: j.rendered,
          score: j.score,
          index: C,
          original: c
        }), _;
      }, []).sort(function(_, c) {
        var C = c.score - _.score;
        return C || _.index - c.index;
      }));
    };
  })();
})(Vf);
var o1 = Vf.exports, Ds = function(x) {
  return this.component = x, this.items = [], this.active = x.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, x.el.parentNode.insertBefore(this.wrapper, x.el.nextSibling), this;
};
Ds.prototype.show = function() {
  this.element.style.display = "block";
};
Ds.prototype.hide = function() {
  this.element.style.display = "none";
};
Ds.prototype.add = function(x) {
  this.items.push(x);
};
Ds.prototype.clear = function() {
  this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
};
Ds.prototype.isEmpty = function() {
  return !this.items.length;
};
Ds.prototype.isVisible = function() {
  return this.element.style.display === "block";
};
Ds.prototype.draw = function() {
  if (this.element.innerHTML = "", this.items.length === 0) {
    this.hide();
    return;
  }
  for (var x = 0; x < this.items.length; x++)
    this.drawItem(this.items[x], this.active === x);
  this.show();
};
Ds.prototype.drawItem = function(x, d) {
  var p = document.createElement("li"), v = document.createElement("a");
  d && (p.className += " active"), v.innerHTML = x.string, p.appendChild(v), this.element.appendChild(p), p.addEventListener("mousedown", (function() {
    this.selectingListItem = !0;
  }).bind(this)), p.addEventListener("mouseup", (function() {
    this.handleMouseUp.call(this, x);
  }).bind(this));
};
Ds.prototype.handleMouseUp = function(x) {
  this.selectingListItem = !1, this.component.value(x.original), this.clear(), this.draw();
};
Ds.prototype.move = function(x) {
  this.active = x, this.draw();
};
Ds.prototype.previous = function() {
  this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
};
Ds.prototype.next = function() {
  this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
};
Ds.prototype.drawError = function(x) {
  var d = document.createElement("li");
  d.innerHTML = x, this.element.appendChild(d), this.show();
};
var a1 = Ds, l1 = qf, c1 = o1, h1 = a1, es = function(x, d, p) {
  return p = p || {}, this.options = l1({
    minLength: 2,
    limit: 5,
    filter: !0,
    hideOnBlur: !0,
    noInitialSelection: !0
  }, p), this.el = x, this.data = d || [], this.list = new h1(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(v) {
    this.handleKeyUp(v.keyCode, v);
  }).bind(this), !1), this.el.addEventListener("keydown", (function(v) {
    this.handleKeyDown(v);
  }).bind(this)), this.el.addEventListener("focus", (function() {
    this.handleFocus();
  }).bind(this)), this.el.addEventListener("blur", (function() {
    this.handleBlur();
  }).bind(this)), this.el.addEventListener("paste", (function(v) {
    this.handlePaste(v);
  }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
};
es.prototype.handleKeyUp = function(x, d) {
  if (!(x === 40 || x === 38 || x === 27 || x === 9)) {
    if (x === 13) {
      this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), d.stopPropagation());
      return;
    }
    this.handleInputChange(this.el.value);
  }
};
es.prototype.handleKeyDown = function(x) {
  switch (x.keyCode) {
    case 13:
      this.list.active >= 0 && (this.list.selectingListItem = !0);
      break;
    case 9:
      this.list.isEmpty() || (this.list.isVisible() && x.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
      break;
    case 27:
      this.list.isEmpty() || this.list.hide();
      break;
    case 38:
      this.list.previous();
      break;
    case 40:
      this.list.next();
      break;
  }
};
es.prototype.handleBlur = function() {
  !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
};
es.prototype.handlePaste = function(x) {
  if (x.clipboardData)
    this.handleInputChange(x.clipboardData.getData("Text"));
  else {
    var d = this;
    setTimeout(function() {
      d.handleInputChange(x.target.value);
    }, 100);
  }
};
es.prototype.handleInputChange = function(x) {
  if (this.query = this.normalize(x), this.list.clear(), this.query.length < this.options.minLength) {
    this.list.draw();
    return;
  }
  this.getCandidates((function(d) {
    for (var p = 0; p < d.length && (this.list.add(d[p]), p !== this.options.limit - 1); p++)
      ;
    this.list.draw();
  }).bind(this));
};
es.prototype.handleFocus = function() {
  this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
};
es.prototype.update = function(x) {
  this.data = x, this.handleKeyUp();
};
es.prototype.clear = function() {
  this.data = [], this.list.clear();
};
es.prototype.normalize = function(x) {
  return x = x.toLowerCase(), x;
};
es.prototype.match = function(x, d) {
  return x.indexOf(d) > -1;
};
es.prototype.value = function(x) {
  if (this.selected = x, this.el.value = this.getItemValue(x || { place_name: this.query }), document.createEvent) {
    var d = document.createEvent("HTMLEvents");
    d.initEvent("change", !0, !1), this.el.dispatchEvent(d);
  } else
    this.el.fireEvent("onchange");
};
es.prototype.getCandidates = function(x) {
  var d = {
    pre: "<strong>",
    post: "</strong>",
    extract: (function(v) {
      return this.getItemValue(v);
    }).bind(this)
  }, p;
  this.options.filter ? (p = c1.filter(this.query, this.data, d), p = p.map((function(v) {
    return {
      original: v.original,
      string: this.render(v.original, v.string)
    };
  }).bind(this))) : p = this.data.map((function(v) {
    var S = this.render(v);
    return {
      original: v,
      string: S
    };
  }).bind(this)), x(p);
};
es.prototype.getItemValue = function(x) {
  return x;
};
es.prototype.render = function(x, d) {
  if (d)
    return d;
  for (var p = x.original ? this.getItemValue(x.original) : this.getItemValue(x), v = this.normalize(p), S = v.lastIndexOf(this.query); S > -1; ) {
    var w = S + this.query.length;
    p = p.slice(0, S) + "<strong>" + p.slice(S, w) + "</strong>" + p.slice(w), S = v.slice(0, S).lastIndexOf(this.query);
  }
  return p;
};
es.prototype.renderError = function(x) {
  this.list.drawError(x);
};
var u1 = es, Uf = u1, d1 = Uf;
typeof window < "u" && (window.Suggestions = Uf);
var p1 = /* @__PURE__ */ su(d1), $f = { exports: {} };
(function(x) {
  (function(d, p, v) {
    x.exports ? x.exports = v() : d[p] = v();
  })(gh, "subtag", function() {
    var d = "", p = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
    function v(C) {
      return C.match(p) || [];
    }
    function S(C) {
      return v(C).filter(function(N, q) {
        return N && q;
      });
    }
    function w(C) {
      return C = v(C), {
        language: C[1] || d,
        extlang: C[2] || d,
        script: C[3] || d,
        region: C[4] || d
      };
    }
    function _(C, N, q) {
      Object.defineProperty(C, N, {
        value: q,
        enumerable: !0
      });
    }
    function c(C, N, q) {
      function j(V) {
        return v(V)[C] || d;
      }
      _(j, "pattern", N), _(w, q, j);
    }
    return c(1, /^[a-zA-Z]{2,3}$/, "language"), c(2, /^[a-zA-Z]{3}$/, "extlang"), c(3, /^[a-zA-Z]{4}$/, "script"), c(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), _(w, "split", S), w;
  });
})($f);
var f1 = $f.exports, m1 = /* @__PURE__ */ su(f1), g1 = "Expected a function", mf = NaN, y1 = "[object Symbol]", _1 = /^\s+|\s+$/g, v1 = /^[-+]0x[0-9a-f]+$/i, x1 = /^0b[01]+$/i, b1 = /^0o[0-7]+$/i, w1 = parseInt, S1 = typeof gh == "object" && gh && gh.Object === Object && gh, A1 = typeof self == "object" && self && self.Object === Object && self, P1 = S1 || A1 || Function("return this")(), I1 = Object.prototype, L1 = I1.toString, T1 = Math.max, k1 = Math.min, ed = function() {
  return P1.Date.now();
};
function C1(x, d, p) {
  var v, S, w, _, c, C, N = 0, q = !1, j = !1, V = !0;
  if (typeof x != "function")
    throw new TypeError(g1);
  d = gf(d) || 0, fd(p) && (q = !!p.leading, j = "maxWait" in p, w = j ? T1(gf(p.maxWait) || 0, d) : w, V = "trailing" in p ? !!p.trailing : V);
  function F(tt) {
    var Be = v, Ie = S;
    return v = S = void 0, N = tt, _ = x.apply(Ie, Be), _;
  }
  function de(tt) {
    return N = tt, c = setTimeout(se, d), q ? F(tt) : _;
  }
  function ae(tt) {
    var Be = tt - C, Ie = tt - N, ot = d - Be;
    return j ? k1(ot, w - Ie) : ot;
  }
  function ye(tt) {
    var Be = tt - C, Ie = tt - N;
    return C === void 0 || Be >= d || Be < 0 || j && Ie >= w;
  }
  function se() {
    var tt = ed();
    if (ye(tt))
      return ge(tt);
    c = setTimeout(se, ae(tt));
  }
  function ge(tt) {
    return c = void 0, V && v ? F(tt) : (v = S = void 0, _);
  }
  function Me() {
    c !== void 0 && clearTimeout(c), N = 0, v = C = S = c = void 0;
  }
  function Ye() {
    return c === void 0 ? _ : ge(ed());
  }
  function $e() {
    var tt = ed(), Be = ye(tt);
    if (v = arguments, S = this, C = tt, Be) {
      if (c === void 0)
        return de(C);
      if (j)
        return c = setTimeout(se, d), F(C);
    }
    return c === void 0 && (c = setTimeout(se, d)), _;
  }
  return $e.cancel = Me, $e.flush = Ye, $e;
}
function fd(x) {
  var d = typeof x;
  return !!x && (d == "object" || d == "function");
}
function E1(x) {
  return !!x && typeof x == "object";
}
function M1(x) {
  return typeof x == "symbol" || E1(x) && L1.call(x) == y1;
}
function gf(x) {
  if (typeof x == "number")
    return x;
  if (M1(x))
    return mf;
  if (fd(x)) {
    var d = typeof x.valueOf == "function" ? x.valueOf() : x;
    x = fd(d) ? d + "" : d;
  }
  if (typeof x != "string")
    return x === 0 ? x : +x;
  x = x.replace(_1, "");
  var p = x1.test(x);
  return p || b1.test(x) ? w1(x.slice(2), p ? 2 : 8) : v1.test(x) ? mf : +x;
}
var z1 = C1, D1 = /* @__PURE__ */ su(z1), _d = { exports: {} }, Oc = typeof Reflect == "object" ? Reflect : null, yf = Oc && typeof Oc.apply == "function" ? Oc.apply : function(d, p, v) {
  return Function.prototype.apply.call(d, p, v);
}, Wh;
Oc && typeof Oc.ownKeys == "function" ? Wh = Oc.ownKeys : Object.getOwnPropertySymbols ? Wh = function(d) {
  return Object.getOwnPropertyNames(d).concat(Object.getOwnPropertySymbols(d));
} : Wh = function(d) {
  return Object.getOwnPropertyNames(d);
};
function N1(x) {
  console && console.warn && console.warn(x);
}
var Zf = Number.isNaN || function(d) {
  return d !== d;
};
function lr() {
  lr.init.call(this);
}
_d.exports = lr;
_d.exports.once = O1;
lr.EventEmitter = lr;
lr.prototype._events = void 0;
lr.prototype._eventsCount = 0;
lr.prototype._maxListeners = void 0;
var _f = 10;
function ou(x) {
  if (typeof x != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof x);
}
Object.defineProperty(lr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return _f;
  },
  set: function(x) {
    if (typeof x != "number" || x < 0 || Zf(x))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + x + ".");
    _f = x;
  }
});
lr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
lr.prototype.setMaxListeners = function(d) {
  if (typeof d != "number" || d < 0 || Zf(d))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + d + ".");
  return this._maxListeners = d, this;
};
function Gf(x) {
  return x._maxListeners === void 0 ? lr.defaultMaxListeners : x._maxListeners;
}
lr.prototype.getMaxListeners = function() {
  return Gf(this);
};
lr.prototype.emit = function(d) {
  for (var p = [], v = 1; v < arguments.length; v++) p.push(arguments[v]);
  var S = d === "error", w = this._events;
  if (w !== void 0)
    S = S && w.error === void 0;
  else if (!S)
    return !1;
  if (S) {
    var _;
    if (p.length > 0 && (_ = p[0]), _ instanceof Error)
      throw _;
    var c = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw c.context = _, c;
  }
  var C = w[d];
  if (C === void 0)
    return !1;
  if (typeof C == "function")
    yf(C, this, p);
  else
    for (var N = C.length, q = Jf(C, N), v = 0; v < N; ++v)
      yf(q[v], this, p);
  return !0;
};
function Wf(x, d, p, v) {
  var S, w, _;
  if (ou(p), w = x._events, w === void 0 ? (w = x._events = /* @__PURE__ */ Object.create(null), x._eventsCount = 0) : (w.newListener !== void 0 && (x.emit(
    "newListener",
    d,
    p.listener ? p.listener : p
  ), w = x._events), _ = w[d]), _ === void 0)
    _ = w[d] = p, ++x._eventsCount;
  else if (typeof _ == "function" ? _ = w[d] = v ? [p, _] : [_, p] : v ? _.unshift(p) : _.push(p), S = Gf(x), S > 0 && _.length > S && !_.warned) {
    _.warned = !0;
    var c = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(d) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = x, c.type = d, c.count = _.length, N1(c);
  }
  return x;
}
lr.prototype.addListener = function(d, p) {
  return Wf(this, d, p, !1);
};
lr.prototype.on = lr.prototype.addListener;
lr.prototype.prependListener = function(d, p) {
  return Wf(this, d, p, !0);
};
function F1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Hf(x, d, p) {
  var v = { fired: !1, wrapFn: void 0, target: x, type: d, listener: p }, S = F1.bind(v);
  return S.listener = p, v.wrapFn = S, S;
}
lr.prototype.once = function(d, p) {
  return ou(p), this.on(d, Hf(this, d, p)), this;
};
lr.prototype.prependOnceListener = function(d, p) {
  return ou(p), this.prependListener(d, Hf(this, d, p)), this;
};
lr.prototype.removeListener = function(d, p) {
  var v, S, w, _, c;
  if (ou(p), S = this._events, S === void 0)
    return this;
  if (v = S[d], v === void 0)
    return this;
  if (v === p || v.listener === p)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete S[d], S.removeListener && this.emit("removeListener", d, v.listener || p));
  else if (typeof v != "function") {
    for (w = -1, _ = v.length - 1; _ >= 0; _--)
      if (v[_] === p || v[_].listener === p) {
        c = v[_].listener, w = _;
        break;
      }
    if (w < 0)
      return this;
    w === 0 ? v.shift() : R1(v, w), v.length === 1 && (S[d] = v[0]), S.removeListener !== void 0 && this.emit("removeListener", d, c || p);
  }
  return this;
};
lr.prototype.off = lr.prototype.removeListener;
lr.prototype.removeAllListeners = function(d) {
  var p, v, S;
  if (v = this._events, v === void 0)
    return this;
  if (v.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : v[d] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete v[d]), this;
  if (arguments.length === 0) {
    var w = Object.keys(v), _;
    for (S = 0; S < w.length; ++S)
      _ = w[S], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (p = v[d], typeof p == "function")
    this.removeListener(d, p);
  else if (p !== void 0)
    for (S = p.length - 1; S >= 0; S--)
      this.removeListener(d, p[S]);
  return this;
};
function Xf(x, d, p) {
  var v = x._events;
  if (v === void 0)
    return [];
  var S = v[d];
  return S === void 0 ? [] : typeof S == "function" ? p ? [S.listener || S] : [S] : p ? B1(S) : Jf(S, S.length);
}
lr.prototype.listeners = function(d) {
  return Xf(this, d, !0);
};
lr.prototype.rawListeners = function(d) {
  return Xf(this, d, !1);
};
lr.listenerCount = function(x, d) {
  return typeof x.listenerCount == "function" ? x.listenerCount(d) : Yf.call(x, d);
};
lr.prototype.listenerCount = Yf;
function Yf(x) {
  var d = this._events;
  if (d !== void 0) {
    var p = d[x];
    if (typeof p == "function")
      return 1;
    if (p !== void 0)
      return p.length;
  }
  return 0;
}
lr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Wh(this._events) : [];
};
function Jf(x, d) {
  for (var p = new Array(d), v = 0; v < d; ++v)
    p[v] = x[v];
  return p;
}
function R1(x, d) {
  for (; d + 1 < x.length; d++)
    x[d] = x[d + 1];
  x.pop();
}
function B1(x) {
  for (var d = new Array(x.length), p = 0; p < d.length; ++p)
    d[p] = x[p].listener || x[p];
  return d;
}
function O1(x, d) {
  return new Promise(function(p, v) {
    function S(_) {
      x.removeListener(d, w), v(_);
    }
    function w() {
      typeof x.removeListener == "function" && x.removeListener("error", S), p([].slice.call(arguments));
    }
    Kf(x, d, w, { once: !0 }), d !== "error" && j1(x, S, { once: !0 });
  });
}
function j1(x, d, p) {
  typeof x.on == "function" && Kf(x, "error", d, p);
}
function Kf(x, d, p, v) {
  if (typeof x.on == "function")
    v.once ? x.once(d, p) : x.on(d, p);
  else if (typeof x.addEventListener == "function")
    x.addEventListener(d, function S(w) {
      v.once && x.removeEventListener(d, S), p(w);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof x);
}
var q1 = _d.exports;
const vf = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, V1 = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "לחפש",
  //hebrew
  ja: "サーチ",
  //japanese
  lv: "Meklēt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "Претрага",
  //serbian
  zh: "搜索",
  //chinese-simplified
  cs: "Vyhledávání",
  //czech
  hu: "Keresés",
  //hungarian
  ka: "ძიება",
  // georgian
  nb: "Søke",
  //norwegian
  sk: "Vyhľadávanie",
  //slovak
  th: "ค้นหา",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "수색",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "جستجو",
  //persian(aka farsi)
  ru: "Поиск"
  //russian
}, U1 = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class Qf {
  constructor(d, p) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      getItemValue: (v) => v.text !== void 0 ? v.text : v.place_name,
      render: function(v) {
        if (!v.geometry) {
          const w = v.text, _ = w.toLowerCase().indexOf(this.query.toLowerCase()), c = this.query.length, C = w.substring(0, _), N = w.substring(_, _ + c), q = w.substring(_ + c);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + C + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + N + "</span>" + q + "</div></div></div>";
        }
        const S = v.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + S[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + S.splice(1, S.length).join(",") + "</div></div></div>";
      },
      popupRender: (v) => {
        const S = v.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + S[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + S.splice(1, S.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new q1.EventEmitter(), this.options = $o({}, this.options, p), this.fresh = !0, this.lastSelected = null, this.geocoderApi = d;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(d) {
    function p(v, S) {
      if (!document.body.contains(S))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const w = v.onAdd();
      S.appendChild(w);
    }
    if (d instanceof HTMLElement)
      p(this, d);
    else if (typeof d == "string") {
      const v = document.querySelectorAll(d);
      if (v.length === 0)
        throw new Error("Element " + d + "not found.");
      if (v.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      p(this, v[0]);
    } else if ("addControl" in d)
      d.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(d) {
    if (d && typeof d != "string" && (this._map = d), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const p = this.container = document.createElement("div");
    p.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const v = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", D1(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const S = document.createElement("div");
    S.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const w = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(w), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), S.appendChild(this._clearEl), S.appendChild(this._loadingEl), p.appendChild(v), p.appendChild(this._inputEl), p.appendChild(S), this._typeahead = new p1(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), p;
  }
  createIcon(d, p) {
    const v = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (v.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + d), v.setAttribute("viewBox", "0 0 18 18"), v.setAttribute("xml:space", "preserve"), v.setAttribute("width", "18"), v.setAttribute("height", "18"), "innerHTML" in v)
      v.innerHTML = p;
    else {
      const S = document.createElement("div");
      S.innerHTML = "<svg>" + p.valueOf().toString() + "</svg>";
      const w = S.firstChild, _ = w.firstChild;
      v.appendChild(_);
    }
    return v;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(d) {
    const p = (d.clipboardData || window.clipboardData).getData("text");
    p.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(p);
  }
  _onKeyDown(d) {
    if (d.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(d), this._inputEl.blur();
    const w = d.target && d.target.shadowRoot ? d.target.shadowRoot.activeElement : d.target;
    if (!(w ? w.value : ""))
      return this.fresh = !0, d.keyCode !== 9 && this.clear(d), this._clearEl.style.display = "none";
    if (!(d.metaKey || [9, 27, 37, 39, 38, 40].indexOf(d.keyCode) !== -1)) {
      if (d.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(w.value);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(w.value, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      w.value.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(w.value);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(d) {
    this.options.clearOnBlur && this._clearOnBlur(d), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const d = this._typeahead.selected;
    if (d && !d.geometry)
      d.placeId ? this._geocode(d.placeId, !0, !0) : this._geocode(d.text, !0);
    else if (d && JSON.stringify(d) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let p;
        if (this._removeResultMarkers(), d.properties && vf[d.properties.short_code])
          p = $o({}, this.options.flyTo), this._map && this._map.fitBounds(vf[d.properties.short_code].bbox, p);
        else if (d.bbox) {
          const v = d.bbox;
          p = $o({}, this.options.flyTo), this._map && this._map.fitBounds([
            [v[0], v[1]],
            [v[2], v[3]]
          ], p);
        } else {
          const v = {
            zoom: this.options.zoom
          };
          p = $o({}, v, this.options.flyTo), d.center ? p.center = d.center : d.geometry && d.geometry.type && d.geometry.type === "Point" && d.geometry.coordinates && (p.center = d.geometry.coordinates), this._map && this._map.flyTo(p);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(d), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(d), this._typeahead.selected = null, this._eventEmitter.emit("result", { result: d });
    }
  }
  _getConfigForRequest() {
    return [
      "bbox",
      "limit",
      "proximity",
      "countries",
      "types",
      "language",
      "reverseMode"
    ].reduce((v, S) => (this.options[S] && (["countries", "types", "language"].indexOf(S) > -1 ? v[S] = this.options[S].split(/[\s,]+/) : v[S] = this.options[S], S === "proximity" && this.options[S] && typeof this.options[S].longitude == "number" && typeof this.options[S].latitude == "number" && (v[S] = [
      this.options[S].longitude,
      this.options[S].latitude
    ])), v), {});
  }
  _geocode(d) {
    return Qu(this, arguments, void 0, function* (p, v = !1, S = !1) {
      this._loadingEl.style.display = "block", this._eventEmitter.emit("loading", { query: p });
      const w = this._getConfigForRequest(), _ = this._createGeocodeRequest(w, p, v, S), c = this.options.localGeocoder ? this.options.localGeocoder(p) || [] : [];
      try {
        const C = yield _;
        yield this._handleGeocodeResponse(C, w, p, v, c);
      } catch (C) {
        this._handleGeocodeErrorResponse(C, c);
      }
      return _;
    });
  }
  _createGeocodeRequest(d, p, v, S) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && U1.test(p) ? this._createReverseGeocodeRequest(p, d) : (d.query = p, this.geocoderApi.getSuggestions ? v ? this.geocoderApi.searchByPlaceId && S ? this.geocoderApi.searchByPlaceId(d) : this.geocoderApi.forwardGeocode(d) : this.geocoderApi.getSuggestions(d) : this.geocoderApi.forwardGeocode(d));
  }
  _createReverseGeocodeRequest(d, p) {
    const v = d.split(/[\s(,)?]+/).map((S) => parseFloat(S)).reverse();
    return p.query = v, p.limit = 1, "proximity" in p && delete p.proximity, this.geocoderApi.reverseGeocode(p);
  }
  _handleGeocodeResponse(d, p, v, S, w) {
    return Qu(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let _ = {};
      d ? _ = d : _ = {
        type: "FeatureCollection",
        features: []
      }, _.config = p, this.fresh && (this.fresh = !1), _.features = _.features ? w.concat(_.features) : w;
      const c = this.options.externalGeocoder ? this.options.externalGeocoder(v, _.features, p) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const N = yield c;
        _.features = _.features ? N.concat(_.features) : N;
      } catch {
      }
      this.options.filter && _.features.length && (_.features = _.features.filter(this.options.filter));
      let C = [];
      "suggestions" in _ ? C = _.suggestions : "place" in _ ? C = [_.place] : C = _.features, C.length ? (this._clearEl.style.display = "block", this._typeahead.update(C), (!this.options.showResultsWhileTyping || S) && this.options.showResultMarkers && (_.features.length > 0 || "place" in _) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", _)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", _));
    });
  }
  _handleGeocodeErrorResponse(d, p) {
    this._loadingEl.style.display = "none", p.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(p)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", { features: p }), this._eventEmitter.emit("error", { error: d });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(d) {
    d && d.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(d) {
    this._clear(d), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(d) {
    d.relatedTarget && this._clear(d);
  }
  _onQueryResult(d) {
    if (!("features" in d) || !d.features.length)
      return;
    const p = d.features[0];
    this._typeahead.selected = p, this._inputEl.value = p.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > 9) {
        const d = this._map.getCenter().wrap();
        this.setProximity({ longitude: d.lng, latitude: d.lat });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(d) {
    return Qu(this, void 0, void 0, function* () {
      const p = yield this._geocode(d);
      this._onQueryResult(p);
    });
  }
  _renderError() {
    this._renderMessage("<div class='maplibre-gl-geocoder--error'>There was an error reaching the server</div>");
  }
  _renderNoResults() {
    this._renderMessage("<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>");
  }
  _renderMessage(d) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(d);
  }
  /**
   * Get the text to use as the search bar placeholder
   *
   * If placeholder is provided in options, then use options.placeholder
   * Otherwise, if language is provided in options, then use the localized string of the first language if available
   * Otherwise use the default
   *
   * @returns the value to use as the search bar placeholder
   */
  _getPlaceholderText() {
    if (this.options.placeholder)
      return this.options.placeholder;
    if (this.options.language) {
      const d = this.options.language.split(",")[0], p = m1.language(d), v = V1[p];
      if (v)
        return v;
    }
    return "Search";
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1)
      return;
    const d = this._typeahead.data.filter((p) => typeof p != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const v = $o({}, { padding: 100 }, this.options.flyTo), S = new this._maplibregl.LngLatBounds();
      for (const w of d)
        S.extend(w.geometry.coordinates);
      this._map.fitBounds(S, v);
    }
    return d.length > 0 && this._maplibregl && this._handleResultMarkers(d), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(d) {
    return this._inputEl.value = d, this._typeahead.selected = null, this._typeahead.clear(), d.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(d), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(d) {
    return this.options.proximity = d, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(d) {
    return d && typeof d == "function" && (this._typeahead.render = d), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(d) {
    return this.options.language = d || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(d) {
    return this.options.zoom = d, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(d) {
    return this.options.flyTo = d, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(d) {
    return this.placeholder = d || this._getPlaceholderText(), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(d) {
    return this.options.bbox = d, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(d) {
    return this.options.countries = d, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(d) {
    return this.options.types = d, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(d) {
    return this.options.minLength = d, this._typeahead && (this._typeahead.options.minLength = d), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(d) {
    return this.options.limit = d, this._typeahead && (this._typeahead.options.limit = d), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(d) {
    return this.options.filter = d, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(d) {
    return this.geocoderApi = d, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(d) {
    if (!this._map)
      return;
    this._removeMarker();
    const v = $o({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(v);
    let S;
    if (this.options.popup) {
      const _ = $o({}, {}, this.options.popup);
      S = new this._maplibregl.Popup(_).setHTML(this.options.popupRender(d));
    }
    return d.center ? (this.mapMarker.setLngLat(d.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(S)) : d.geometry && d.geometry.type && d.geometry.type === "Point" && d.geometry.coordinates && (this.mapMarker.setLngLat(d.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(S)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(d) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let v = $o({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const S of d) {
      let w;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (w = this.options.showResultMarkers.element.cloneNode(!0), v = $o(v, { element: w }));
        const _ = new this._maplibregl.Marker($o({}, v, { element: w }));
        let c;
        if (this.options.popup) {
          const N = $o({}, {}, this.options.popup);
          c = new this._maplibregl.Popup(N).setHTML(this.options.popupRender(S));
        }
        S.center ? (_.setLngLat(S.center).addTo(this._map), this.options.popup && _.setPopup(c)) : S.geometry && S.geometry.type && S.geometry.type === "Point" && S.geometry.coordinates && (_.setLngLat(S.geometry.coordinates).addTo(this._map), this.options.popup && _.setPopup(c)), this.resultMarkers.push(_);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(d) {
      d.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(d, p) {
    return this._eventEmitter.on(d, p), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(d) {
    return new Promise((p) => {
      this._eventEmitter.once(d, p);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(d, p) {
    return this._eventEmitter.removeListener(d, p), this;
  }
}
const td = [
  {
    style: "std",
    title: "標準地図",
    uri: "https://gsi-cyberjapan.github.io/gsivectortile-mapbox-gl-js/std.json"
  },
  {
    style: "pale",
    title: "淡色地図",
    uri: "https://gsi-cyberjapan.github.io/gsivectortile-mapbox-gl-js/pale.json"
  },
  {
    style: "blank",
    title: "白地図",
    uri: "https://gsi-cyberjapan.github.io/gsivectortile-mapbox-gl-js/blank.json"
  }
], eu = (x) => {
  const d = parseInt(x.substring(0, 4)), p = parseInt(x.substring(4, 6)), v = parseInt(x.substring(6, 8)), S = parseInt(x.substring(8, 10)), w = parseInt(x.substring(10, 12)), _ = parseInt(x.substring(12, 14)), c = new Date(d, p - 1, v, S, w, _), C = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
  return new Date(c.getTime() - C);
}, tu = (x, d) => (d = d.replace(/yyyy/g, x.getFullYear()), d = d.replace(/MM/g, ("0" + (x.getMonth() + 1)).slice(-2)), d = d.replace(/dd/g, ("0" + x.getDate()).slice(-2)), d = d.replace(/HH/g, ("0" + x.getHours()).slice(-2)), d = d.replace(/mm/g, ("0" + x.getMinutes()).slice(-2)), d = d.replace(/ss/g, ("0" + x.getSeconds()).slice(-2)), d), $1 = () => {
  if (window.WebGLRenderingContext) {
    const x = document.createElement("canvas");
    try {
      const d = x.getContext("webgl2") || x.getContext("webgl");
      if (d && typeof d.getParameter == "function")
        return !0;
    } catch {
    }
    return !1;
  }
  return !1;
}, Z1 = (x) => {
  const d = new Hh.Map({
    container: "map",
    // container id
    hash: !0,
    // style: './style/pale.json', // style URL
    style: x,
    center: [139.767125, 35.681236],
    // starting position [lng, lat]
    zoom: 10,
    // starting zoom
    minZoom: 4,
    maxZoom: 10,
    localIdeographFontFamily: !1
  });
  d.addControl(
    new jc.NavigationControl({
      visualizePitch: !0,
      showZoom: !0,
      showCompass: !0
    }),
    "bottom-right"
  ), d.addControl(
    new jc.ScaleControl()
  );
  const p = new jf({
    PageSize: El.A3,
    PageOrientation: zc.Portrait,
    Format: Ea.PNG,
    DPI: Xh[96],
    Crosshair: !0,
    PrintableArea: !0,
    Local: "ja"
  });
  d.addControl(p, "bottom-right"), d.addControl(
    new Qf({
      forwardGeocode: async (v) => {
        const S = v.query, w = await fetch(
          `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(S)}`
        );
        return w.ok ? {
          features: (await w.json()).map(({ geometry: { coordinates: C }, properties: N }) => ({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: C
            },
            place_name: N.title,
            center: C
          }))
        } : {};
      }
    }, {
      maplibregl: Hh,
      marker: !1,
      showResultsWhileTyping: !0,
      placeholder: "地名検索",
      reverseGeocode: !0
    }),
    "top-right"
  ), d.addControl(new StyleSwitcherControl()), d.addControl(new NowcastControl(), "top-right"), d.on("load", () => {
    d.addSource("All", {
      type: "vector",
      tiles: [
        "https://yzkn.github.io/MyKMLsMap/tiles/{z}/{x}/{y}.pbf"
      ],
      minzoom: 4,
      maxzoom: 10
    }), d.addLayer(
      {
        id: "All",
        type: "line",
        source: "All",
        "source-layer": "All",
        layout: {
          "line-cap": "round",
          "line-join": "round"
        },
        paint: {
          "line-opacity": 0.8,
          "line-color": "rgb(255, 0, 0)",
          "line-width": 1
        }
      }
    );
    const v = "https://www.jma.go.jp/bosai/jmatile/data/nowc/targetTimes_N2.json", S = "https://www.jma.go.jp/bosai/jmatile/data/rasrf/targetTimes.json";
    let w = [];
    fetch(v).then(function(_) {
      return _.json();
    }).then(function(_) {
      _.sort(function(C, N) {
        return C.validtime - N.validtime;
      }), _.forEach((C) => {
        const N = C.basetime, q = C.validtime, j = `Nowcast${N}${q}`;
        w.push({ id: j, validtime: q }), d.addSource(j, {
          type: "raster",
          tiles: [
            `https://www.jma.go.jp/bosai/jmatile/data/nowc/${C.basetime}/none/${C.validtime}/surf/hrpns/{z}/{x}/{y}.png`
          ],
          minzoom: 4,
          maxzoom: 10
        }), d.addLayer(
          {
            id: j,
            type: "raster",
            source: j,
            "source-layer": j
          }
        ), d.setLayoutProperty(j, "visibility", "none"), d.setPaintProperty(j, "raster-opacity", 1);
      });
      const c = w[w.length - 1].validtime;
      fetch(S).then(function(C) {
        return C.json();
      }).then(function(C) {
        C.sort(function(N, q) {
          return N.validtime - q.validtime;
        }), C.filter((N) => N.validtime > c).forEach((N) => {
          const q = N.basetime, j = N.validtime, V = `Rasrf${q}${j}`;
          w.push({ id: V, validtime: j }), d.addSource(V, {
            type: "raster",
            tiles: [
              `https://www.jma.go.jp/bosai/jmatile/data/rasrf/${N.basetime}/${N.member}/${N.validtime}/surf/rasrf/{z}/{x}/{y}.png`
            ],
            minzoom: 4,
            maxzoom: 10
          }), d.addLayer(
            {
              id: V,
              type: "raster",
              source: V,
              "source-layer": V
            }
          ), d.setLayoutProperty(V, "visibility", "none"), d.setPaintProperty(V, "raster-opacity", 1);
        }), console.log("nowcastSources", w), document.getElementById("nowcast-slider").max = w.length - 1, document.getElementById("nowcast-slider").addEventListener("change", () => {
          document.getElementById("nowcast-datetime").innerHTML = (w[document.getElementById("nowcast-slider").value].id.startsWith("Nowcast") ? '<font color="#4caf50">' : '<font color="#3f51b5">') + tu(eu(w[document.getElementById("nowcast-slider").value].validtime), "MM/dd HH:mm") + "</font>", w.forEach((N) => {
            d.setLayoutProperty(N.id, "visibility", "none");
          }), d.setLayoutProperty(w[document.getElementById("nowcast-slider").value].id, "visibility", "visible");
        }, !1), document.getElementById("nowcast-datetime").innerHTML = '<font color="#4caf50">' + tu(eu(w[0].validtime), "MM/dd HH:mm") + "</font>", d.setLayoutProperty(w[0].id, "visibility", "visible");
      });
    });
  });
}, G1 = (x) => {
  const d = new Hh.Map({
    container: "map",
    // container id
    hash: !0,
    // style: './style/pale.json', // style URL
    style: x,
    center: [139.767125, 35.681236],
    // starting position [lng, lat]
    zoom: 10,
    // starting zoom
    minZoom: 4,
    maxZoom: 10,
    localIdeographFontFamily: !1
  });
  d.addControl(
    new jc.NavigationControl({
      visualizePitch: !0,
      showZoom: !0,
      showCompass: !0
    }),
    "bottom-right"
  ), d.addControl(
    new jc.ScaleControl()
  );
  const p = new jf({
    PageSize: El.A3,
    PageOrientation: zc.Portrait,
    Format: Ea.PNG,
    DPI: Xh[96],
    Crosshair: !0,
    PrintableArea: !0,
    Local: "ja"
  });
  d.addControl(p, "bottom-right"), d.addControl(
    new Qf({
      forwardGeocode: async (v) => {
        const S = v.query, w = await fetch(
          `https://msearch.gsi.go.jp/address-search/AddressSearch?q=${encodeURIComponent(S)}`
        );
        return w.ok ? {
          features: (await w.json()).map(({ geometry: { coordinates: C }, properties: N }) => ({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: C
            },
            place_name: N.title,
            center: C
          }))
        } : {};
      }
    }, {
      maplibregl: Hh,
      marker: !1,
      showResultsWhileTyping: !0,
      placeholder: "地名検索",
      reverseGeocode: !0
    }),
    "top-right"
  ), d.addControl(new StyleSwitcherControl()), d.addControl(new NowcastControl(), "top-right"), d.on("load", () => {
    d.addSource("All", {
      type: "vector",
      tiles: [
        "https://yzkn.github.io/MyKMLsMap/tiles/{z}/{x}/{y}.pbf"
      ],
      minzoom: 4,
      maxzoom: 10
    }), d.addLayer(
      {
        id: "All",
        type: "line",
        source: "All",
        "source-layer": "All",
        layout: {
          "line-cap": "round",
          "line-join": "round"
        },
        paint: {
          "line-opacity": 0.8,
          "line-color": "rgb(255, 0, 0)",
          "line-width": 1
        }
      }
    );
    const v = "https://www.jma.go.jp/bosai/jmatile/data/nowc/targetTimes_N2.json", S = "https://www.jma.go.jp/bosai/jmatile/data/rasrf/targetTimes.json";
    let w = [];
    fetch(v).then(function(_) {
      return _.json();
    }).then(function(_) {
      _.sort(function(N, q) {
        return N.validtime - q.validtime;
      });
      let c = !0;
      _.forEach((N) => {
        const q = N.basetime, j = N.validtime, V = `Nowcast${q}${j}`;
        w.push({ id: V, validtime: j }), d.addSource(V, {
          type: "raster",
          tiles: [
            `https://www.jma.go.jp/bosai/jmatile/data/nowc/${N.basetime}/none/${N.validtime}/surf/hrpns/{z}/{x}/{y}.png`
          ],
          minzoom: 4,
          maxzoom: 10
        }), d.addLayer(
          {
            id: V,
            type: "raster",
            source: V,
            "source-layer": V
          }
        ), d.setLayoutProperty(V, "visibility", c ? "visible" : "none"), d.setPaintProperty(V, "raster-opacity", 0.2), c = !1;
      });
      const C = w[w.length - 1].validtime;
      fetch(S).then(function(N) {
        return N.json();
      }).then(function(N) {
        N.sort(function(q, j) {
          return q.validtime - j.validtime;
        }), N.filter((q) => q.validtime > C).forEach((q) => {
          const j = q.basetime, V = q.validtime, F = `Rasrf${j}${V}`;
          w.push({ id: F, validtime: V }), d.addSource(F, {
            type: "raster",
            tiles: [
              `https://www.jma.go.jp/bosai/jmatile/data/rasrf/${q.basetime}/${q.member}/${q.validtime}/surf/rasrf/{z}/{x}/{y}.png`
            ],
            minzoom: 4,
            maxzoom: 10
          }), d.addLayer(
            {
              id: F,
              type: "raster",
              source: F,
              "source-layer": F
            }
          ), d.setLayoutProperty(F, "visibility", "none"), d.setPaintProperty(F, "raster-opacity", 0.1);
        }), console.log("nowcastSources", w), document.getElementById("nowcast-slider").max = w.length - 1, document.getElementById("nowcast-slider").addEventListener("change", () => {
          document.getElementById("nowcast-datetime").innerHTML = (w[document.getElementById("nowcast-slider").value].id.startsWith("Nowcast") ? '<font color="#4caf50">' : '<font color="#3f51b5">') + tu(eu(w[document.getElementById("nowcast-slider").value].validtime), "MM/dd HH:mm") + "まで";
          let q = !0;
          w.forEach((j) => {
            d.setLayoutProperty(j.id, "visibility", q ? "visible" : "none"), j.id == w[document.getElementById("nowcast-slider").value].id && (console.log(j.id, w[document.getElementById("nowcast-slider").value].id), q = !1);
          }), d.setLayoutProperty(w[document.getElementById("nowcast-slider").value].id, "visibility", "visible");
        }, !1), document.getElementById("nowcast-datetime").innerHTML = '<font color="#4caf50">' + tu(eu(w[0].validtime), "MM/dd HH:mm") + "</font>", d.setLayoutProperty(w[0].id, "visibility", "visible");
      });
    });
  });
};
window.addEventListener("DOMContentLoaded", (x) => {
  const d = new URLSearchParams(window.location.search), p = document.getElementById("style-switch");
  if (p.innerHTML = "", td.forEach((v) => {
    const S = document.createElement("option");
    S.value = v.style, S.textContent = v.title, d.has("style") && d.get("style") == v.style && (S.selected = "selected"), p.appendChild(S);
  }), p.addEventListener("change", (v) => {
    const S = v.target.value;
    window.location = location.pathname + "?style=" + S;
  }), !$1())
    alert("Your browser does not support MapLibre GL");
  else {
    const v = document.getElementById("style-switch").value;
    location.pathname.includes("all") ? G1(
      td.find((S) => S.style === v).uri
    ) : Z1(
      td.find((S) => S.style === v).uri
    );
  }
});
export {
  rr as p
};
